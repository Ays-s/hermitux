
is.b:     file format elf64-x86-64


Disassembly of section .init:

0000000000400120 <_init>:
.section .init
.global _init
_init:
	push %rax
  400120:	50                   	push   %rax
.section .init
	pop %rax
  400121:	58                   	pop    %rax
	ret
  400122:	c3                   	retq   

Disassembly of section .text:

0000000000400130 <exit>:
}

weak_alias(libc_exit_fini, __libc_exit_fini);

_Noreturn void exit(int code)
{
  400130:	48 83 ec 18          	sub    $0x18,%rsp
	__funcs_on_exit();
  400134:	31 c0                	xor    %eax,%eax
{
  400136:	89 7c 24 0c          	mov    %edi,0xc(%rsp)
	__funcs_on_exit();
  40013a:	e8 90 12 00 00       	callq  4013cf <__funcs_on_exit>
	__libc_exit_fini();
  40013f:	e8 8c 12 00 00       	callq  4013d0 <__libc_exit_fini>
	__stdio_exit();
  400144:	31 c0                	xor    %eax,%eax
  400146:	e8 05 58 00 00       	callq  405950 <__stdio_exit>
	_Exit(code);
  40014b:	8b 7c 24 0c          	mov    0xc(%rsp),%edi
  40014f:	e8 bb 33 00 00       	callq  40350f <_Exit>

0000000000400154 <_start>:
  400154:	48 31 ed             	xor    %rbp,%rbp
  400157:	48 89 e7             	mov    %rsp,%rdi
  40015a:	48 8d 35 9f fe bf ff 	lea    -0x400161(%rip),%rsi        # 0 <_init-0x400120>
  400161:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  400165:	e8 00 00 00 00       	callq  40016a <_start_c>

000000000040016a <_start_c>:
void _fini() __attribute__((weak));
_Noreturn int __libc_start_main(int (*)(), int, char **,
	void (*)(), void(*)(), void(*)());

void _start_c(long *p)
{
  40016a:	48 83 ec 08          	sub    $0x8,%rsp
	int argc = p[0];
	char **argv = (void *)(p+1);
  40016e:	48 8d 57 08          	lea    0x8(%rdi),%rdx
	int argc = p[0];
  400172:	48 8b 37             	mov    (%rdi),%rsi
	__libc_start_main(main, argc, argv, _init, _fini, 0);
  400175:	49 c7 c0 c3 59 40 00 	mov    $0x4059c3,%r8
  40017c:	48 c7 c1 20 01 40 00 	mov    $0x400120,%rcx
  400183:	45 31 c9             	xor    %r9d,%r9d
  400186:	48 c7 c7 00 0b 40 00 	mov    $0x400b00,%rdi
  40018d:	e8 00 12 00 00       	callq  401392 <__libc_start_main>
  400192:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  400199:	00 00 00 
  40019c:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004001a0 <deregister_tm_clones>:
  4001a0:	b8 b7 72 60 00       	mov    $0x6072b7,%eax
  4001a5:	55                   	push   %rbp
  4001a6:	48 2d b0 72 60 00    	sub    $0x6072b0,%rax
  4001ac:	48 83 f8 0e          	cmp    $0xe,%rax
  4001b0:	48 89 e5             	mov    %rsp,%rbp
  4001b3:	76 1b                	jbe    4001d0 <deregister_tm_clones+0x30>
  4001b5:	b8 00 00 00 00       	mov    $0x0,%eax
  4001ba:	48 85 c0             	test   %rax,%rax
  4001bd:	74 11                	je     4001d0 <deregister_tm_clones+0x30>
  4001bf:	5d                   	pop    %rbp
  4001c0:	bf b0 72 60 00       	mov    $0x6072b0,%edi
  4001c5:	ff e0                	jmpq   *%rax
  4001c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4001ce:	00 00 
  4001d0:	5d                   	pop    %rbp
  4001d1:	c3                   	retq   
  4001d2:	0f 1f 40 00          	nopl   0x0(%rax)
  4001d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4001dd:	00 00 00 

00000000004001e0 <register_tm_clones>:
  4001e0:	be b0 72 60 00       	mov    $0x6072b0,%esi
  4001e5:	55                   	push   %rbp
  4001e6:	48 81 ee b0 72 60 00 	sub    $0x6072b0,%rsi
  4001ed:	48 c1 fe 03          	sar    $0x3,%rsi
  4001f1:	48 89 e5             	mov    %rsp,%rbp
  4001f4:	48 89 f0             	mov    %rsi,%rax
  4001f7:	48 c1 e8 3f          	shr    $0x3f,%rax
  4001fb:	48 01 c6             	add    %rax,%rsi
  4001fe:	48 d1 fe             	sar    %rsi
  400201:	74 15                	je     400218 <register_tm_clones+0x38>
  400203:	b8 00 00 00 00       	mov    $0x0,%eax
  400208:	48 85 c0             	test   %rax,%rax
  40020b:	74 0b                	je     400218 <register_tm_clones+0x38>
  40020d:	5d                   	pop    %rbp
  40020e:	bf b0 72 60 00       	mov    $0x6072b0,%edi
  400213:	ff e0                	jmpq   *%rax
  400215:	0f 1f 00             	nopl   (%rax)
  400218:	5d                   	pop    %rbp
  400219:	c3                   	retq   
  40021a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000400220 <__do_global_dtors_aux>:
  400220:	80 3d 99 70 20 00 00 	cmpb   $0x0,0x207099(%rip)        # 6072c0 <completed.6963>
  400227:	75 11                	jne    40023a <__do_global_dtors_aux+0x1a>
  400229:	55                   	push   %rbp
  40022a:	48 89 e5             	mov    %rsp,%rbp
  40022d:	e8 6e ff ff ff       	callq  4001a0 <deregister_tm_clones>
  400232:	5d                   	pop    %rbp
  400233:	c6 05 86 70 20 00 01 	movb   $0x1,0x207086(%rip)        # 6072c0 <completed.6963>
  40023a:	f3 c3                	repz retq 
  40023c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000400240 <frame_dummy>:
  400240:	bf f0 6f 60 00       	mov    $0x606ff0,%edi
  400245:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  400249:	75 05                	jne    400250 <frame_dummy+0x10>
  40024b:	eb 93                	jmp    4001e0 <register_tm_clones>
  40024d:	0f 1f 00             	nopl   (%rax)
  400250:	b8 00 00 00 00       	mov    $0x0,%eax
  400255:	48 85 c0             	test   %rax,%rax
  400258:	74 f1                	je     40024b <frame_dummy+0xb>
  40025a:	55                   	push   %rbp
  40025b:	48 89 e5             	mov    %rsp,%rbp
  40025e:	ff d0                	callq  *%rax
  400260:	5d                   	pop    %rbp
  400261:	e9 7a ff ff ff       	jmpq   4001e0 <register_tm_clones>

0000000000400266 <randlc>:
/*************                                        ************/
/*************    portable random number generator    ************/
/*****************************************************************/

double	randlc( double *X, double *A )
{
  400266:	55                   	push   %rbp
  400267:	48 89 e5             	mov    %rsp,%rbp
  40026a:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  40026e:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
      double		X1;
      double		X2;
      double		Z;
      int     		i, j;

      if (KS == 0) 
  400272:	8b 05 50 70 20 00    	mov    0x207050(%rip),%eax        # 6072c8 <KS.2295>
  400278:	85 c0                	test   %eax,%eax
  40027a:	0f 85 d0 00 00 00    	jne    400350 <randlc+0xea>
      {
        R23 = 1.0;
  400280:	f2 0f 10 05 c8 59 00 	movsd  0x59c8(%rip),%xmm0        # 405c50 <_fini+0x28d>
  400287:	00 
  400288:	f2 0f 11 05 40 70 20 	movsd  %xmm0,0x207040(%rip)        # 6072d0 <R23.2296>
  40028f:	00 
        R46 = 1.0;
  400290:	f2 0f 10 05 b8 59 00 	movsd  0x59b8(%rip),%xmm0        # 405c50 <_fini+0x28d>
  400297:	00 
  400298:	f2 0f 11 05 38 70 20 	movsd  %xmm0,0x207038(%rip)        # 6072d8 <R46.2297>
  40029f:	00 
        T23 = 1.0;
  4002a0:	f2 0f 10 05 a8 59 00 	movsd  0x59a8(%rip),%xmm0        # 405c50 <_fini+0x28d>
  4002a7:	00 
  4002a8:	f2 0f 11 05 30 70 20 	movsd  %xmm0,0x207030(%rip)        # 6072e0 <T23.2298>
  4002af:	00 
        T46 = 1.0;
  4002b0:	f2 0f 10 05 98 59 00 	movsd  0x5998(%rip),%xmm0        # 405c50 <_fini+0x28d>
  4002b7:	00 
  4002b8:	f2 0f 11 05 28 70 20 	movsd  %xmm0,0x207028(%rip)        # 6072e8 <T46.2299>
  4002bf:	00 
    
        for (i=1; i<=23; i++)
  4002c0:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  4002c7:	eb 34                	jmp    4002fd <randlc+0x97>
        {
          R23 = 0.50 * R23;
  4002c9:	f2 0f 10 0d ff 6f 20 	movsd  0x206fff(%rip),%xmm1        # 6072d0 <R23.2296>
  4002d0:	00 
  4002d1:	f2 0f 10 05 7f 59 00 	movsd  0x597f(%rip),%xmm0        # 405c58 <_fini+0x295>
  4002d8:	00 
  4002d9:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  4002dd:	f2 0f 11 05 eb 6f 20 	movsd  %xmm0,0x206feb(%rip)        # 6072d0 <R23.2296>
  4002e4:	00 
          T23 = 2.0 * T23;
  4002e5:	f2 0f 10 05 f3 6f 20 	movsd  0x206ff3(%rip),%xmm0        # 6072e0 <T23.2298>
  4002ec:	00 
  4002ed:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  4002f1:	f2 0f 11 05 e7 6f 20 	movsd  %xmm0,0x206fe7(%rip)        # 6072e0 <T23.2298>
  4002f8:	00 
        for (i=1; i<=23; i++)
  4002f9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  4002fd:	83 7d fc 17          	cmpl   $0x17,-0x4(%rbp)
  400301:	7e c6                	jle    4002c9 <randlc+0x63>
        }
        for (i=1; i<=46; i++)
  400303:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  40030a:	eb 34                	jmp    400340 <randlc+0xda>
        {
          R46 = 0.50 * R46;
  40030c:	f2 0f 10 0d c4 6f 20 	movsd  0x206fc4(%rip),%xmm1        # 6072d8 <R46.2297>
  400313:	00 
  400314:	f2 0f 10 05 3c 59 00 	movsd  0x593c(%rip),%xmm0        # 405c58 <_fini+0x295>
  40031b:	00 
  40031c:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  400320:	f2 0f 11 05 b0 6f 20 	movsd  %xmm0,0x206fb0(%rip)        # 6072d8 <R46.2297>
  400327:	00 
          T46 = 2.0 * T46;
  400328:	f2 0f 10 05 b8 6f 20 	movsd  0x206fb8(%rip),%xmm0        # 6072e8 <T46.2299>
  40032f:	00 
  400330:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  400334:	f2 0f 11 05 ac 6f 20 	movsd  %xmm0,0x206fac(%rip)        # 6072e8 <T46.2299>
  40033b:	00 
        for (i=1; i<=46; i++)
  40033c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400340:	83 7d fc 2e          	cmpl   $0x2e,-0x4(%rbp)
  400344:	7e c6                	jle    40030c <randlc+0xa6>
        }
        KS = 1;
  400346:	c7 05 78 6f 20 00 01 	movl   $0x1,0x206f78(%rip)        # 6072c8 <KS.2295>
  40034d:	00 00 00 
      }

/*  Break A into two parts such that A = 2^23 * A1 + A2 and set X = N.  */

      T1 = R23 * *A;
  400350:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  400354:	f2 0f 10 08          	movsd  (%rax),%xmm1
  400358:	f2 0f 10 05 70 6f 20 	movsd  0x206f70(%rip),%xmm0        # 6072d0 <R23.2296>
  40035f:	00 
  400360:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  400364:	f2 0f 11 45 f0       	movsd  %xmm0,-0x10(%rbp)
      j  = T1;
  400369:	f2 0f 10 45 f0       	movsd  -0x10(%rbp),%xmm0
  40036e:	f2 0f 2c c0          	cvttsd2si %xmm0,%eax
  400372:	89 45 ec             	mov    %eax,-0x14(%rbp)
      A1 = j;
  400375:	66 0f ef c0          	pxor   %xmm0,%xmm0
  400379:	f2 0f 2a 45 ec       	cvtsi2sdl -0x14(%rbp),%xmm0
  40037e:	f2 0f 11 45 e0       	movsd  %xmm0,-0x20(%rbp)
      A2 = *A - T23 * A1;
  400383:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  400387:	f2 0f 10 08          	movsd  (%rax),%xmm1
  40038b:	f2 0f 10 05 4d 6f 20 	movsd  0x206f4d(%rip),%xmm0        # 6072e0 <T23.2298>
  400392:	00 
  400393:	f2 0f 59 45 e0       	mulsd  -0x20(%rbp),%xmm0
  400398:	f2 0f 5c c8          	subsd  %xmm0,%xmm1
  40039c:	66 0f 28 c1          	movapd %xmm1,%xmm0
  4003a0:	f2 0f 11 45 d8       	movsd  %xmm0,-0x28(%rbp)

/*  Break X into two parts such that X = 2^23 * X1 + X2, compute
    Z = A1 * X2 + A2 * X1  (mod 2^23), and then
    X = 2^23 * Z + A2 * X2  (mod 2^46).                            */

      T1 = R23 * *X;
  4003a5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  4003a9:	f2 0f 10 08          	movsd  (%rax),%xmm1
  4003ad:	f2 0f 10 05 1b 6f 20 	movsd  0x206f1b(%rip),%xmm0        # 6072d0 <R23.2296>
  4003b4:	00 
  4003b5:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  4003b9:	f2 0f 11 45 f0       	movsd  %xmm0,-0x10(%rbp)
      j  = T1;
  4003be:	f2 0f 10 45 f0       	movsd  -0x10(%rbp),%xmm0
  4003c3:	f2 0f 2c c0          	cvttsd2si %xmm0,%eax
  4003c7:	89 45 ec             	mov    %eax,-0x14(%rbp)
      X1 = j;
  4003ca:	66 0f ef c0          	pxor   %xmm0,%xmm0
  4003ce:	f2 0f 2a 45 ec       	cvtsi2sdl -0x14(%rbp),%xmm0
  4003d3:	f2 0f 11 45 d0       	movsd  %xmm0,-0x30(%rbp)
      X2 = *X - T23 * X1;
  4003d8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  4003dc:	f2 0f 10 08          	movsd  (%rax),%xmm1
  4003e0:	f2 0f 10 05 f8 6e 20 	movsd  0x206ef8(%rip),%xmm0        # 6072e0 <T23.2298>
  4003e7:	00 
  4003e8:	f2 0f 59 45 d0       	mulsd  -0x30(%rbp),%xmm0
  4003ed:	f2 0f 5c c8          	subsd  %xmm0,%xmm1
  4003f1:	66 0f 28 c1          	movapd %xmm1,%xmm0
  4003f5:	f2 0f 11 45 c8       	movsd  %xmm0,-0x38(%rbp)
      T1 = A1 * X2 + A2 * X1;
  4003fa:	f2 0f 10 45 e0       	movsd  -0x20(%rbp),%xmm0
  4003ff:	66 0f 28 c8          	movapd %xmm0,%xmm1
  400403:	f2 0f 59 4d c8       	mulsd  -0x38(%rbp),%xmm1
  400408:	f2 0f 10 45 d8       	movsd  -0x28(%rbp),%xmm0
  40040d:	f2 0f 59 45 d0       	mulsd  -0x30(%rbp),%xmm0
  400412:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  400416:	f2 0f 11 45 f0       	movsd  %xmm0,-0x10(%rbp)
      
      j  = R23 * T1;
  40041b:	f2 0f 10 05 ad 6e 20 	movsd  0x206ead(%rip),%xmm0        # 6072d0 <R23.2296>
  400422:	00 
  400423:	f2 0f 59 45 f0       	mulsd  -0x10(%rbp),%xmm0
  400428:	f2 0f 2c c0          	cvttsd2si %xmm0,%eax
  40042c:	89 45 ec             	mov    %eax,-0x14(%rbp)
      T2 = j;
  40042f:	66 0f ef c0          	pxor   %xmm0,%xmm0
  400433:	f2 0f 2a 45 ec       	cvtsi2sdl -0x14(%rbp),%xmm0
  400438:	f2 0f 11 45 c0       	movsd  %xmm0,-0x40(%rbp)
      Z = T1 - T23 * T2;
  40043d:	f2 0f 10 05 9b 6e 20 	movsd  0x206e9b(%rip),%xmm0        # 6072e0 <T23.2298>
  400444:	00 
  400445:	f2 0f 59 45 c0       	mulsd  -0x40(%rbp),%xmm0
  40044a:	f2 0f 10 4d f0       	movsd  -0x10(%rbp),%xmm1
  40044f:	f2 0f 5c c8          	subsd  %xmm0,%xmm1
  400453:	66 0f 28 c1          	movapd %xmm1,%xmm0
  400457:	f2 0f 11 45 b8       	movsd  %xmm0,-0x48(%rbp)
      T3 = T23 * Z + A2 * X2;
  40045c:	f2 0f 10 05 7c 6e 20 	movsd  0x206e7c(%rip),%xmm0        # 6072e0 <T23.2298>
  400463:	00 
  400464:	66 0f 28 c8          	movapd %xmm0,%xmm1
  400468:	f2 0f 59 4d b8       	mulsd  -0x48(%rbp),%xmm1
  40046d:	f2 0f 10 45 d8       	movsd  -0x28(%rbp),%xmm0
  400472:	f2 0f 59 45 c8       	mulsd  -0x38(%rbp),%xmm0
  400477:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  40047b:	f2 0f 11 45 b0       	movsd  %xmm0,-0x50(%rbp)
      j  = R46 * T3;
  400480:	f2 0f 10 05 50 6e 20 	movsd  0x206e50(%rip),%xmm0        # 6072d8 <R46.2297>
  400487:	00 
  400488:	f2 0f 59 45 b0       	mulsd  -0x50(%rbp),%xmm0
  40048d:	f2 0f 2c c0          	cvttsd2si %xmm0,%eax
  400491:	89 45 ec             	mov    %eax,-0x14(%rbp)
      T4 = j;
  400494:	66 0f ef c0          	pxor   %xmm0,%xmm0
  400498:	f2 0f 2a 45 ec       	cvtsi2sdl -0x14(%rbp),%xmm0
  40049d:	f2 0f 11 45 a8       	movsd  %xmm0,-0x58(%rbp)
      *X = T3 - T46 * T4;
  4004a2:	f2 0f 10 05 3e 6e 20 	movsd  0x206e3e(%rip),%xmm0        # 6072e8 <T46.2299>
  4004a9:	00 
  4004aa:	f2 0f 59 45 a8       	mulsd  -0x58(%rbp),%xmm0
  4004af:	f2 0f 10 4d b0       	movsd  -0x50(%rbp),%xmm1
  4004b4:	f2 0f 5c c8          	subsd  %xmm0,%xmm1
  4004b8:	66 0f 28 c1          	movapd %xmm1,%xmm0
  4004bc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  4004c0:	f2 0f 11 00          	movsd  %xmm0,(%rax)
      return(R46 * *X);
  4004c4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  4004c8:	f2 0f 10 08          	movsd  (%rax),%xmm1
  4004cc:	f2 0f 10 05 04 6e 20 	movsd  0x206e04(%rip),%xmm0        # 6072d8 <R46.2297>
  4004d3:	00 
  4004d4:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
} 
  4004d8:	5d                   	pop    %rbp
  4004d9:	c3                   	retq   

00000000004004da <create_seq>:
/*****************************************************************/
/*************      C  R  E  A  T  E  _  S  E  Q      ************/
/*****************************************************************/

void	create_seq( double seed, double a )
{
  4004da:	55                   	push   %rbp
  4004db:	48 89 e5             	mov    %rsp,%rbp
  4004de:	48 83 ec 20          	sub    $0x20,%rsp
  4004e2:	f2 0f 11 45 e8       	movsd  %xmm0,-0x18(%rbp)
  4004e7:	f2 0f 11 4d e0       	movsd  %xmm1,-0x20(%rbp)
	double x;
	INT_TYPE i, k;

        k = MAX_KEY/4;
  4004ec:	c7 45 f8 00 00 08 00 	movl   $0x80000,-0x8(%rbp)

	for (i=0; i<NUM_KEYS; i++)
  4004f3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4004fa:	e9 b8 00 00 00       	jmpq   4005b7 <create_seq+0xdd>
	{
	    x = randlc(&seed, &a);
  4004ff:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  400503:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  400507:	48 89 d6             	mov    %rdx,%rsi
  40050a:	48 89 c7             	mov    %rax,%rdi
  40050d:	e8 54 fd ff ff       	callq  400266 <randlc>
  400512:	66 48 0f 7e c0       	movq   %xmm0,%rax
  400517:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	    x += randlc(&seed, &a);
  40051b:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  40051f:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  400523:	48 89 d6             	mov    %rdx,%rsi
  400526:	48 89 c7             	mov    %rax,%rdi
  400529:	e8 38 fd ff ff       	callq  400266 <randlc>
  40052e:	66 0f 28 c8          	movapd %xmm0,%xmm1
  400532:	f2 0f 10 45 f0       	movsd  -0x10(%rbp),%xmm0
  400537:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  40053b:	f2 0f 11 45 f0       	movsd  %xmm0,-0x10(%rbp)
    	    x += randlc(&seed, &a);
  400540:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  400544:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  400548:	48 89 d6             	mov    %rdx,%rsi
  40054b:	48 89 c7             	mov    %rax,%rdi
  40054e:	e8 13 fd ff ff       	callq  400266 <randlc>
  400553:	66 0f 28 c8          	movapd %xmm0,%xmm1
  400557:	f2 0f 10 45 f0       	movsd  -0x10(%rbp),%xmm0
  40055c:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  400560:	f2 0f 11 45 f0       	movsd  %xmm0,-0x10(%rbp)
	    x += randlc(&seed, &a);  
  400565:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  400569:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  40056d:	48 89 d6             	mov    %rdx,%rsi
  400570:	48 89 c7             	mov    %rax,%rdi
  400573:	e8 ee fc ff ff       	callq  400266 <randlc>
  400578:	66 0f 28 c8          	movapd %xmm0,%xmm1
  40057c:	f2 0f 10 45 f0       	movsd  -0x10(%rbp),%xmm0
  400581:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  400585:	f2 0f 11 45 f0       	movsd  %xmm0,-0x10(%rbp)

            key_array[i] = k*x;
  40058a:	66 0f ef c0          	pxor   %xmm0,%xmm0
  40058e:	f2 0f 2a 45 f8       	cvtsi2sdl -0x8(%rbp),%xmm0
  400593:	f2 0f 59 45 f0       	mulsd  -0x10(%rbp),%xmm0
  400598:	f2 0f 2c d0          	cvttsd2si %xmm0,%edx
  40059c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40059f:	48 98                	cltq   
  4005a1:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4005a8:	00 
  4005a9:	48 8d 05 f0 7b 20 00 	lea    0x207bf0(%rip),%rax        # 6081a0 <key_array>
  4005b0:	89 14 01             	mov    %edx,(%rcx,%rax,1)
	for (i=0; i<NUM_KEYS; i++)
  4005b3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  4005b7:	81 7d fc ff ff ff 01 	cmpl   $0x1ffffff,-0x4(%rbp)
  4005be:	0f 8e 3b ff ff ff    	jle    4004ff <create_seq+0x25>
	}
}
  4005c4:	90                   	nop
  4005c5:	c9                   	leaveq 
  4005c6:	c3                   	retq   

00000000004005c7 <full_verify>:
/*************    F  U  L  L  _  V  E  R  I  F  Y     ************/
/*****************************************************************/


void full_verify( void )
{
  4005c7:	55                   	push   %rbp
  4005c8:	48 89 e5             	mov    %rsp,%rbp
  4005cb:	48 83 ec 10          	sub    $0x10,%rsp
    for( i=0; i<NUM_KEYS; i++ )
        key_buff2[i] = key_array[i];

#endif

    for( i=0; i<NUM_KEYS; i++ )
  4005cf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4005d6:	eb 60                	jmp    400638 <full_verify+0x71>
        key_array[--key_buff_ptr_global[key_buff2[i]]] = key_buff2[i];
  4005d8:	48 8b 15 e1 7b 20 10 	mov    0x10207be1(%rip),%rdx        # 106081c0 <key_buff_ptr_global>
  4005df:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4005e2:	48 98                	cltq   
  4005e4:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4005eb:	00 
  4005ec:	48 8d 05 cd 7b 20 08 	lea    0x8207bcd(%rip),%rax        # 86081c0 <key_buff2>
  4005f3:	8b 04 01             	mov    (%rcx,%rax,1),%eax
  4005f6:	48 98                	cltq   
  4005f8:	48 c1 e0 02          	shl    $0x2,%rax
  4005fc:	48 01 d0             	add    %rdx,%rax
  4005ff:	8b 10                	mov    (%rax),%edx
  400601:	83 ea 01             	sub    $0x1,%edx
  400604:	89 10                	mov    %edx,(%rax)
  400606:	8b 08                	mov    (%rax),%ecx
  400608:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40060b:	48 98                	cltq   
  40060d:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400614:	00 
  400615:	48 8d 05 a4 7b 20 08 	lea    0x8207ba4(%rip),%rax        # 86081c0 <key_buff2>
  40061c:	8b 14 02             	mov    (%rdx,%rax,1),%edx
  40061f:	48 63 c1             	movslq %ecx,%rax
  400622:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400629:	00 
  40062a:	48 8d 05 6f 7b 20 00 	lea    0x207b6f(%rip),%rax        # 6081a0 <key_array>
  400631:	89 14 01             	mov    %edx,(%rcx,%rax,1)
    for( i=0; i<NUM_KEYS; i++ )
  400634:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400638:	81 7d fc ff ff ff 01 	cmpl   $0x1ffffff,-0x4(%rbp)
  40063f:	7e 97                	jle    4005d8 <full_verify+0x11>


/*  Confirm keys correctly sorted: count incorrectly sorted keys, if any */

    j = 0;
  400641:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    for( i=1; i<NUM_KEYS; i++ )
  400648:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  40064f:	eb 3d                	jmp    40068e <full_verify+0xc7>
        if( key_array[i-1] > key_array[i] )
  400651:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400654:	83 e8 01             	sub    $0x1,%eax
  400657:	48 98                	cltq   
  400659:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400660:	00 
  400661:	48 8d 05 38 7b 20 00 	lea    0x207b38(%rip),%rax        # 6081a0 <key_array>
  400668:	8b 14 02             	mov    (%rdx,%rax,1),%edx
  40066b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40066e:	48 98                	cltq   
  400670:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400677:	00 
  400678:	48 8d 05 21 7b 20 00 	lea    0x207b21(%rip),%rax        # 6081a0 <key_array>
  40067f:	8b 04 01             	mov    (%rcx,%rax,1),%eax
  400682:	39 c2                	cmp    %eax,%edx
  400684:	7e 04                	jle    40068a <full_verify+0xc3>
            j++;
  400686:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
    for( i=1; i<NUM_KEYS; i++ )
  40068a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  40068e:	81 7d fc ff ff ff 01 	cmpl   $0x1ffffff,-0x4(%rbp)
  400695:	7e ba                	jle    400651 <full_verify+0x8a>


    if( j != 0 )
  400697:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  40069b:	74 1b                	je     4006b8 <full_verify+0xf1>
    {
        printf( "Full_verify: number of keys out of sort: %ld\n",
  40069d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  4006a0:	48 98                	cltq   
  4006a2:	48 89 c6             	mov    %rax,%rsi
  4006a5:	48 8d 3d 34 53 00 00 	lea    0x5334(%rip),%rdi        # 4059e0 <_fini+0x1d>
  4006ac:	b8 00 00 00 00       	mov    $0x0,%eax
  4006b1:	e8 ca 0f 00 00       	callq  401680 <printf>
    }
    else
        passed_verification++;
           

}
  4006b6:	eb 0f                	jmp    4006c7 <full_verify+0x100>
        passed_verification++;
  4006b8:	8b 05 26 7b 20 10    	mov    0x10207b26(%rip),%eax        # 106081e4 <passed_verification>
  4006be:	83 c0 01             	add    $0x1,%eax
  4006c1:	89 05 1d 7b 20 10    	mov    %eax,0x10207b1d(%rip)        # 106081e4 <passed_verification>
}
  4006c7:	90                   	nop
  4006c8:	c9                   	leaveq 
  4006c9:	c3                   	retq   

00000000004006ca <rank>:
/*************             R  A  N  K             ****************/
/*****************************************************************/


void rank( int iteration )
{
  4006ca:	55                   	push   %rbp
  4006cb:	48 89 e5             	mov    %rsp,%rbp
  4006ce:	48 83 ec 40          	sub    $0x40,%rsp
  4006d2:	89 7d cc             	mov    %edi,-0x34(%rbp)
    INT_TYPE    i, k;

    INT_TYPE    *key_buff_ptr, *key_buff_ptr2;

#ifdef USE_BUCKETS
    int shift = MAX_KEY_LOG_2 - NUM_BUCKETS_LOG_2;
  4006d5:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%rbp)
    INT_TYPE    key;
#endif


    key_array[iteration] = iteration;
  4006dc:	8b 45 cc             	mov    -0x34(%rbp),%eax
  4006df:	48 98                	cltq   
  4006e1:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4006e8:	00 
  4006e9:	48 8d 05 b0 7a 20 00 	lea    0x207ab0(%rip),%rax        # 6081a0 <key_array>
  4006f0:	8b 55 cc             	mov    -0x34(%rbp),%edx
  4006f3:	89 14 01             	mov    %edx,(%rcx,%rax,1)
    key_array[iteration+MAX_ITERATIONS] = MAX_KEY - iteration;
  4006f6:	8b 45 cc             	mov    -0x34(%rbp),%eax
  4006f9:	83 c0 0a             	add    $0xa,%eax
  4006fc:	ba 00 00 20 00       	mov    $0x200000,%edx
  400701:	2b 55 cc             	sub    -0x34(%rbp),%edx
  400704:	48 98                	cltq   
  400706:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  40070d:	00 
  40070e:	48 8d 05 8b 7a 20 00 	lea    0x207a8b(%rip),%rax        # 6081a0 <key_array>
  400715:	89 14 01             	mov    %edx,(%rcx,%rax,1)


/*  Determine where the partial verify test keys are, load into  */
/*  top of array bucket_size                                     */
    for( i=0; i<TEST_ARRAY_SIZE; i++ )
  400718:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40071f:	eb 46                	jmp    400767 <rank+0x9d>
        partial_verify_vals[i] = key_array[test_index_array[i]];
  400721:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400724:	48 98                	cltq   
  400726:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  40072d:	00 
  40072e:	48 8d 05 cb 9a a0 10 	lea    0x10a09acb(%rip),%rax        # 10e0a200 <test_index_array>
  400735:	8b 04 02             	mov    (%rdx,%rax,1),%eax
  400738:	48 98                	cltq   
  40073a:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400741:	00 
  400742:	48 8d 05 57 7a 20 00 	lea    0x207a57(%rip),%rax        # 6081a0 <key_array>
  400749:	8b 14 02             	mov    (%rdx,%rax,1),%edx
  40074c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40074f:	48 98                	cltq   
  400751:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400758:	00 
  400759:	48 8d 05 40 7a 20 08 	lea    0x8207a40(%rip),%rax        # 86081a0 <partial_verify_vals>
  400760:	89 14 01             	mov    %edx,(%rcx,%rax,1)
    for( i=0; i<TEST_ARRAY_SIZE; i++ )
  400763:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400767:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  40076b:	7e b4                	jle    400721 <rank+0x57>

#ifdef USE_BUCKETS

/*  Initialize */
    for( i=0; i<NUM_BUCKETS; i++ )  
  40076d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400774:	eb 1f                	jmp    400795 <rank+0xcb>
        bucket_size[i] = 0;
  400776:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400779:	48 98                	cltq   
  40077b:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400782:	00 
  400783:	48 8d 05 76 7a 20 10 	lea    0x10207a76(%rip),%rax        # 10608200 <bucket_size>
  40078a:	c7 04 02 00 00 00 00 	movl   $0x0,(%rdx,%rax,1)
    for( i=0; i<NUM_BUCKETS; i++ )  
  400791:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400795:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  40079c:	7e d8                	jle    400776 <rank+0xac>

/*  Determine the number of keys in each bucket */
    for( i=0; i<NUM_KEYS; i++ )
  40079e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4007a5:	eb 50                	jmp    4007f7 <rank+0x12d>
        bucket_size[key_array[i] >> shift]++;
  4007a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4007aa:	48 98                	cltq   
  4007ac:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  4007b3:	00 
  4007b4:	48 8d 05 e5 79 20 00 	lea    0x2079e5(%rip),%rax        # 6081a0 <key_array>
  4007bb:	8b 14 02             	mov    (%rdx,%rax,1),%edx
  4007be:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4007c1:	89 c1                	mov    %eax,%ecx
  4007c3:	d3 fa                	sar    %cl,%edx
  4007c5:	89 d0                	mov    %edx,%eax
  4007c7:	48 63 d0             	movslq %eax,%rdx
  4007ca:	48 8d 0c 95 00 00 00 	lea    0x0(,%rdx,4),%rcx
  4007d1:	00 
  4007d2:	48 8d 15 27 7a 20 10 	lea    0x10207a27(%rip),%rdx        # 10608200 <bucket_size>
  4007d9:	8b 14 11             	mov    (%rcx,%rdx,1),%edx
  4007dc:	8d 4a 01             	lea    0x1(%rdx),%ecx
  4007df:	48 98                	cltq   
  4007e1:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  4007e8:	00 
  4007e9:	48 8d 05 10 7a 20 10 	lea    0x10207a10(%rip),%rax        # 10608200 <bucket_size>
  4007f0:	89 0c 02             	mov    %ecx,(%rdx,%rax,1)
    for( i=0; i<NUM_KEYS; i++ )
  4007f3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  4007f7:	81 7d fc ff ff ff 01 	cmpl   $0x1ffffff,-0x4(%rbp)
  4007fe:	7e a7                	jle    4007a7 <rank+0xdd>


/*  Accumulative bucket sizes are the bucket pointers */
    bucket_ptrs[0] = 0;
  400800:	c7 05 f6 89 20 10 00 	movl   $0x0,0x102089f6(%rip)        # 10609200 <bucket_ptrs>
  400807:	00 00 00 
    for( i=1; i< NUM_BUCKETS; i++ )  
  40080a:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  400811:	eb 52                	jmp    400865 <rank+0x19b>
        bucket_ptrs[i] = bucket_ptrs[i-1] + bucket_size[i-1];
  400813:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400816:	83 e8 01             	sub    $0x1,%eax
  400819:	48 98                	cltq   
  40081b:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400822:	00 
  400823:	48 8d 05 d6 89 20 10 	lea    0x102089d6(%rip),%rax        # 10609200 <bucket_ptrs>
  40082a:	8b 14 02             	mov    (%rdx,%rax,1),%edx
  40082d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400830:	83 e8 01             	sub    $0x1,%eax
  400833:	48 98                	cltq   
  400835:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  40083c:	00 
  40083d:	48 8d 05 bc 79 20 10 	lea    0x102079bc(%rip),%rax        # 10608200 <bucket_size>
  400844:	8b 04 01             	mov    (%rcx,%rax,1),%eax
  400847:	8d 0c 02             	lea    (%rdx,%rax,1),%ecx
  40084a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40084d:	48 98                	cltq   
  40084f:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400856:	00 
  400857:	48 8d 05 a2 89 20 10 	lea    0x102089a2(%rip),%rax        # 10609200 <bucket_ptrs>
  40085e:	89 0c 02             	mov    %ecx,(%rdx,%rax,1)
    for( i=1; i< NUM_BUCKETS; i++ )  
  400861:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400865:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  40086c:	7e a5                	jle    400813 <rank+0x149>


/*  Sort into appropriate bucket */
    for( i=0; i<NUM_KEYS; i++ )  
  40086e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400875:	eb 6c                	jmp    4008e3 <rank+0x219>
    {
        key = key_array[i];
  400877:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40087a:	48 98                	cltq   
  40087c:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400883:	00 
  400884:	48 8d 05 15 79 20 00 	lea    0x207915(%rip),%rax        # 6081a0 <key_array>
  40088b:	8b 04 02             	mov    (%rdx,%rax,1),%eax
  40088e:	89 45 f0             	mov    %eax,-0x10(%rbp)
        key_buff2[bucket_ptrs[key >> shift]++] = key;
  400891:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400894:	8b 55 f0             	mov    -0x10(%rbp),%edx
  400897:	89 c1                	mov    %eax,%ecx
  400899:	d3 fa                	sar    %cl,%edx
  40089b:	48 63 c2             	movslq %edx,%rax
  40089e:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4008a5:	00 
  4008a6:	48 8d 05 53 89 20 10 	lea    0x10208953(%rip),%rax        # 10609200 <bucket_ptrs>
  4008ad:	8b 04 01             	mov    (%rcx,%rax,1),%eax
  4008b0:	8d 48 01             	lea    0x1(%rax),%ecx
  4008b3:	48 63 d2             	movslq %edx,%rdx
  4008b6:	48 8d 34 95 00 00 00 	lea    0x0(,%rdx,4),%rsi
  4008bd:	00 
  4008be:	48 8d 15 3b 89 20 10 	lea    0x1020893b(%rip),%rdx        # 10609200 <bucket_ptrs>
  4008c5:	89 0c 16             	mov    %ecx,(%rsi,%rdx,1)
  4008c8:	48 98                	cltq   
  4008ca:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4008d1:	00 
  4008d2:	48 8d 05 e7 78 20 08 	lea    0x82078e7(%rip),%rax        # 86081c0 <key_buff2>
  4008d9:	8b 55 f0             	mov    -0x10(%rbp),%edx
  4008dc:	89 14 01             	mov    %edx,(%rcx,%rax,1)
    for( i=0; i<NUM_KEYS; i++ )  
  4008df:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  4008e3:	81 7d fc ff ff ff 01 	cmpl   $0x1ffffff,-0x4(%rbp)
  4008ea:	7e 8b                	jle    400877 <rank+0x1ad>
    }

    key_buff_ptr2 = key_buff2;
  4008ec:	48 8d 05 cd 78 20 08 	lea    0x82078cd(%rip),%rax        # 86081c0 <key_buff2>
  4008f3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    key_buff_ptr2 = key_array;

#endif

/*  Clear the work array */
    for( i=0; i<MAX_KEY; i++ )
  4008f7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4008fe:	eb 1f                	jmp    40091f <rank+0x255>
        key_buff1[i] = 0;
  400900:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400903:	48 98                	cltq   
  400905:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  40090c:	00 
  40090d:	48 8d 05 ec 98 20 10 	lea    0x102098ec(%rip),%rax        # 1060a200 <key_buff1>
  400914:	c7 04 02 00 00 00 00 	movl   $0x0,(%rdx,%rax,1)
    for( i=0; i<MAX_KEY; i++ )
  40091b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  40091f:	81 7d fc ff ff 1f 00 	cmpl   $0x1fffff,-0x4(%rbp)
  400926:	7e d8                	jle    400900 <rank+0x236>


/*  Ranking of all keys occurs in this section:                 */

    key_buff_ptr = key_buff1;
  400928:	48 8d 05 d1 98 20 10 	lea    0x102098d1(%rip),%rax        # 1060a200 <key_buff1>
  40092f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

/*  In this section, the keys themselves are used as their 
    own indexes to determine how many of each there are: their
    individual population                                       */

    for( i=0; i<NUM_KEYS; i++ )
  400933:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40093a:	eb 32                	jmp    40096e <rank+0x2a4>
        key_buff_ptr[key_buff_ptr2[i]]++;  /* Now they have individual key   */
  40093c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40093f:	48 98                	cltq   
  400941:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400948:	00 
  400949:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40094d:	48 01 d0             	add    %rdx,%rax
  400950:	8b 00                	mov    (%rax),%eax
  400952:	48 98                	cltq   
  400954:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  40095b:	00 
  40095c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400960:	48 01 d0             	add    %rdx,%rax
  400963:	8b 10                	mov    (%rax),%edx
  400965:	83 c2 01             	add    $0x1,%edx
  400968:	89 10                	mov    %edx,(%rax)
    for( i=0; i<NUM_KEYS; i++ )
  40096a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  40096e:	81 7d fc ff ff ff 01 	cmpl   $0x1ffffff,-0x4(%rbp)
  400975:	7e c5                	jle    40093c <rank+0x272>

/*  To obtain ranks of each key, successively add the individual key
    population                                                  */


    for( i=0; i<MAX_KEY-1; i++ )   
  400977:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40097e:	eb 52                	jmp    4009d2 <rank+0x308>
        key_buff_ptr[i+1] += key_buff_ptr[i];  
  400980:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400983:	48 98                	cltq   
  400985:	48 83 c0 01          	add    $0x1,%rax
  400989:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400990:	00 
  400991:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400995:	48 01 d0             	add    %rdx,%rax
  400998:	8b 55 fc             	mov    -0x4(%rbp),%edx
  40099b:	48 63 d2             	movslq %edx,%rdx
  40099e:	48 83 c2 01          	add    $0x1,%rdx
  4009a2:	48 8d 0c 95 00 00 00 	lea    0x0(,%rdx,4),%rcx
  4009a9:	00 
  4009aa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4009ae:	48 01 ca             	add    %rcx,%rdx
  4009b1:	8b 0a                	mov    (%rdx),%ecx
  4009b3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4009b6:	48 63 d2             	movslq %edx,%rdx
  4009b9:	48 8d 34 95 00 00 00 	lea    0x0(,%rdx,4),%rsi
  4009c0:	00 
  4009c1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4009c5:	48 01 f2             	add    %rsi,%rdx
  4009c8:	8b 12                	mov    (%rdx),%edx
  4009ca:	01 ca                	add    %ecx,%edx
  4009cc:	89 10                	mov    %edx,(%rax)
    for( i=0; i<MAX_KEY-1; i++ )   
  4009ce:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  4009d2:	81 7d fc fe ff 1f 00 	cmpl   $0x1ffffe,-0x4(%rbp)
  4009d9:	7e a5                	jle    400980 <rank+0x2b6>


/* This is the partial verify test section */
/* Observe that test_rank_array vals are   */
/* shifted differently for different cases */
    for( i=0; i<TEST_ARRAY_SIZE; i++ )
  4009db:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4009e2:	e9 fb 00 00 00       	jmpq   400ae2 <rank+0x418>
    {                                             
        k = partial_verify_vals[i];          /* test vals were put here */
  4009e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4009ea:	48 98                	cltq   
  4009ec:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  4009f3:	00 
  4009f4:	48 8d 05 a5 77 20 08 	lea    0x82077a5(%rip),%rax        # 86081a0 <partial_verify_vals>
  4009fb:	8b 04 02             	mov    (%rdx,%rax,1),%eax
  4009fe:	89 45 dc             	mov    %eax,-0x24(%rbp)
        if( 0 < k  &&  k <= NUM_KEYS-1 )
  400a01:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  400a05:	0f 8e d3 00 00 00    	jle    400ade <rank+0x414>
  400a0b:	81 7d dc ff ff ff 01 	cmpl   $0x1ffffff,-0x24(%rbp)
  400a12:	0f 8f c6 00 00 00    	jg     400ade <rank+0x414>
        {
            INT_TYPE key_rank = key_buff_ptr[k-1];
  400a18:	8b 45 dc             	mov    -0x24(%rbp),%eax
  400a1b:	48 98                	cltq   
  400a1d:	48 c1 e0 02          	shl    $0x2,%rax
  400a21:	48 8d 50 fc          	lea    -0x4(%rax),%rdx
  400a25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400a29:	48 01 d0             	add    %rdx,%rax
  400a2c:	8b 00                	mov    (%rax),%eax
  400a2e:	89 45 d8             	mov    %eax,-0x28(%rbp)
            int failed = 0;
  400a31:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
                        else
                            passed_verification++;
                    }
                    break;
                case 'B':
                    if( i == 1 || i == 2 || i == 4 )
  400a38:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  400a3c:	74 0c                	je     400a4a <rank+0x380>
  400a3e:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  400a42:	74 06                	je     400a4a <rank+0x380>
  400a44:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  400a48:	75 3b                	jne    400a85 <rank+0x3bb>
        	    {
                        if( key_rank != test_rank_array[i]+iteration )
  400a4a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400a4d:	48 98                	cltq   
  400a4f:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400a56:	00 
  400a57:	48 8d 05 72 77 20 10 	lea    0x10207772(%rip),%rax        # 106081d0 <test_rank_array>
  400a5e:	8b 14 02             	mov    (%rdx,%rax,1),%edx
  400a61:	8b 45 cc             	mov    -0x34(%rbp),%eax
  400a64:	01 d0                	add    %edx,%eax
  400a66:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  400a69:	74 09                	je     400a74 <rank+0x3aa>
                            failed = 1;
  400a6b:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
                        if( key_rank != test_rank_array[i]+iteration )
  400a72:	eb 4a                	jmp    400abe <rank+0x3f4>
                        else
                            passed_verification++;
  400a74:	8b 05 6a 77 20 10    	mov    0x1020776a(%rip),%eax        # 106081e4 <passed_verification>
  400a7a:	83 c0 01             	add    $0x1,%eax
  400a7d:	89 05 61 77 20 10    	mov    %eax,0x10207761(%rip)        # 106081e4 <passed_verification>
                        if( key_rank != test_rank_array[i]+iteration )
  400a83:	eb 39                	jmp    400abe <rank+0x3f4>
        	    }
                    else
                    {
                        if( key_rank != test_rank_array[i]-iteration )
  400a85:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400a88:	48 98                	cltq   
  400a8a:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400a91:	00 
  400a92:	48 8d 05 37 77 20 10 	lea    0x10207737(%rip),%rax        # 106081d0 <test_rank_array>
  400a99:	8b 04 02             	mov    (%rdx,%rax,1),%eax
  400a9c:	2b 45 cc             	sub    -0x34(%rbp),%eax
  400a9f:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  400aa2:	74 09                	je     400aad <rank+0x3e3>
                            failed = 1;
  400aa4:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
                        else
                            passed_verification++;
                    }
                    break;
  400aab:	eb 11                	jmp    400abe <rank+0x3f4>
                            passed_verification++;
  400aad:	8b 05 31 77 20 10    	mov    0x10207731(%rip),%eax        # 106081e4 <passed_verification>
  400ab3:	83 c0 01             	add    $0x1,%eax
  400ab6:	89 05 28 77 20 10    	mov    %eax,0x10207728(%rip)        # 106081e4 <passed_verification>
                    break;
  400abc:	eb 00                	jmp    400abe <rank+0x3f4>
  400abe:	90                   	nop
                        else
                            passed_verification++;
                    }
                    break;
            }
            if( failed == 1 )
  400abf:	83 7d f8 01          	cmpl   $0x1,-0x8(%rbp)
  400ac3:	75 19                	jne    400ade <rank+0x414>
                printf( "Failed partial verification: "
  400ac5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  400ac8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  400acb:	89 c6                	mov    %eax,%esi
  400acd:	48 8d 3d 3c 4f 00 00 	lea    0x4f3c(%rip),%rdi        # 405a10 <_fini+0x4d>
  400ad4:	b8 00 00 00 00       	mov    $0x0,%eax
  400ad9:	e8 a2 0b 00 00       	callq  401680 <printf>
    for( i=0; i<TEST_ARRAY_SIZE; i++ )
  400ade:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400ae2:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  400ae6:	0f 8e fb fe ff ff    	jle    4009e7 <rank+0x31d>

/*  Make copies of rank info for use by full_verify: these variables
    in rank are local; making them global slows down the code, probably
    since they cannot be made register by compiler                        */

    if( iteration == MAX_ITERATIONS ) 
  400aec:	83 7d cc 0a          	cmpl   $0xa,-0x34(%rbp)
  400af0:	75 0b                	jne    400afd <rank+0x433>
        key_buff_ptr_global = key_buff_ptr;
  400af2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400af6:	48 89 05 c3 76 20 10 	mov    %rax,0x102076c3(%rip)        # 106081c0 <key_buff_ptr_global>

}      
  400afd:	90                   	nop
  400afe:	c9                   	leaveq 
  400aff:	c3                   	retq   

0000000000400b00 <main>:
/*****************************************************************/
/*************             M  A  I  N             ****************/
/*****************************************************************/

int main( int argc, char **argv )
{
  400b00:	55                   	push   %rbp
  400b01:	48 89 e5             	mov    %rsp,%rbp
  400b04:	48 83 ec 50          	sub    $0x50,%rsp
  400b08:	89 7d cc             	mov    %edi,-0x34(%rbp)
  400b0b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)

    FILE            *fp;


/*  Initialize timers  */
    timer_on = 0;            
  400b0f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    if ((fp = fopen("timer.flag", "r")) != NULL) {
  400b16:	48 8d 35 2b 4f 00 00 	lea    0x4f2b(%rip),%rsi        # 405a48 <_fini+0x85>
  400b1d:	48 8d 3d 26 4f 00 00 	lea    0x4f26(%rip),%rdi        # 405a4a <_fini+0x87>
  400b24:	e8 8d 0a 00 00       	callq  4015b6 <fopen>
  400b29:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  400b2d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  400b32:	74 13                	je     400b47 <main+0x47>
        fclose(fp);
  400b34:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400b38:	48 89 c7             	mov    %rax,%rdi
  400b3b:	e8 b4 08 00 00       	callq  4013f4 <fclose>
        timer_on = 1;
  400b40:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
    }
    timer_clear( 0 );
  400b47:	bf 00 00 00 00       	mov    $0x0,%edi
  400b4c:	e8 7b 06 00 00       	callq  4011cc <timer_clear>
    if (timer_on) {
  400b51:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  400b55:	74 1e                	je     400b75 <main+0x75>
        timer_clear( 1 );
  400b57:	bf 01 00 00 00       	mov    $0x1,%edi
  400b5c:	e8 6b 06 00 00       	callq  4011cc <timer_clear>
        timer_clear( 2 );
  400b61:	bf 02 00 00 00       	mov    $0x2,%edi
  400b66:	e8 61 06 00 00       	callq  4011cc <timer_clear>
        timer_clear( 3 );
  400b6b:	bf 03 00 00 00       	mov    $0x3,%edi
  400b70:	e8 57 06 00 00       	callq  4011cc <timer_clear>
    }

    if (timer_on) timer_start( 3 );
  400b75:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  400b79:	74 0a                	je     400b85 <main+0x85>
  400b7b:	bf 03 00 00 00       	mov    $0x3,%edi
  400b80:	e8 6e 06 00 00       	callq  4011f3 <timer_start>


/*  Initialize the verification arrays if a valid class */
    for( i=0; i<TEST_ARRAY_SIZE; i++ )
  400b85:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  400b8c:	eb 61                	jmp    400bef <main+0xef>
            case 'W':
                test_index_array[i] = W_test_index_array[i];
                test_rank_array[i]  = W_test_rank_array[i];
                break;
            case 'B':
                test_index_array[i] = B_test_index_array[i];
  400b8e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400b91:	48 98                	cltq   
  400b93:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400b9a:	00 
  400b9b:	48 8d 05 4e 65 20 00 	lea    0x20654e(%rip),%rax        # 6070f0 <B_test_index_array>
  400ba2:	8b 14 02             	mov    (%rdx,%rax,1),%edx
  400ba5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400ba8:	48 98                	cltq   
  400baa:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400bb1:	00 
  400bb2:	48 8d 05 47 96 a0 10 	lea    0x10a09647(%rip),%rax        # 10e0a200 <test_index_array>
  400bb9:	89 14 01             	mov    %edx,(%rcx,%rax,1)
                test_rank_array[i]  = B_test_rank_array[i];
  400bbc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400bbf:	48 98                	cltq   
  400bc1:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400bc8:	00 
  400bc9:	48 8d 05 40 65 20 00 	lea    0x206540(%rip),%rax        # 607110 <B_test_rank_array>
  400bd0:	8b 14 02             	mov    (%rdx,%rax,1),%edx
  400bd3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400bd6:	48 98                	cltq   
  400bd8:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400bdf:	00 
  400be0:	48 8d 05 e9 75 20 10 	lea    0x102075e9(%rip),%rax        # 106081d0 <test_rank_array>
  400be7:	89 14 01             	mov    %edx,(%rcx,%rax,1)
                break;
  400bea:	90                   	nop
    for( i=0; i<TEST_ARRAY_SIZE; i++ )
  400beb:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  400bef:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  400bf3:	7e 99                	jle    400b8e <main+0x8e>
        };

        

/*  Printout initial NPB info */
    printf
  400bf5:	48 8d 3d 5c 4e 00 00 	lea    0x4e5c(%rip),%rdi        # 405a58 <_fini+0x95>
  400bfc:	e8 20 0b 00 00       	callq  401721 <puts>
      ( "\n\n NAS Parallel Benchmarks (NPB3.3-SER) - IS Benchmark\n\n" );
    printf( " Size:  %ld  (class %c)\n", (long)TOTAL_KEYS, CLASS );
  400c01:	ba 42 00 00 00       	mov    $0x42,%edx
  400c06:	be 00 00 00 02       	mov    $0x2000000,%esi
  400c0b:	48 8d 3d 7e 4e 00 00 	lea    0x4e7e(%rip),%rdi        # 405a90 <_fini+0xcd>
  400c12:	b8 00 00 00 00       	mov    $0x0,%eax
  400c17:	e8 64 0a 00 00       	callq  401680 <printf>
    printf( " Iterations:   %d\n", MAX_ITERATIONS );
  400c1c:	be 0a 00 00 00       	mov    $0xa,%esi
  400c21:	48 8d 3d 81 4e 00 00 	lea    0x4e81(%rip),%rdi        # 405aa9 <_fini+0xe6>
  400c28:	b8 00 00 00 00       	mov    $0x0,%eax
  400c2d:	e8 4e 0a 00 00       	callq  401680 <printf>

    if (timer_on) timer_start( 1 );
  400c32:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  400c36:	74 0a                	je     400c42 <main+0x142>
  400c38:	bf 01 00 00 00       	mov    $0x1,%edi
  400c3d:	e8 b1 05 00 00       	callq  4011f3 <timer_start>

/*  Generate random number sequence and subsequent keys on all procs */
    create_seq( 314159265.00,                    /* Random number gen seed */
  400c42:	f2 0f 10 05 16 50 00 	movsd  0x5016(%rip),%xmm0        # 405c60 <_fini+0x29d>
  400c49:	00 
  400c4a:	48 8b 05 17 50 00 00 	mov    0x5017(%rip),%rax        # 405c68 <_fini+0x2a5>
  400c51:	66 0f 28 c8          	movapd %xmm0,%xmm1
  400c55:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  400c59:	f2 0f 10 45 b8       	movsd  -0x48(%rbp),%xmm0
  400c5e:	e8 77 f8 ff ff       	callq  4004da <create_seq>
                1220703125.00 );                 /* Random number gen mult */
    if (timer_on) timer_stop( 1 );
  400c63:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  400c67:	74 0a                	je     400c73 <main+0x173>
  400c69:	bf 01 00 00 00       	mov    $0x1,%edi
  400c6e:	e8 b0 05 00 00       	callq  401223 <timer_stop>


/*  Do one interation for free (i.e., untimed) to guarantee initialization of  
    all data and code pages and respective tables */
    rank( 1 );  
  400c73:	bf 01 00 00 00       	mov    $0x1,%edi
  400c78:	e8 4d fa ff ff       	callq  4006ca <rank>

/*  Start verification counter */
    passed_verification = 0;
  400c7d:	c7 05 5d 75 20 10 00 	movl   $0x0,0x1020755d(%rip)        # 106081e4 <passed_verification>
  400c84:	00 00 00 

    if( CLASS != 'S' ) printf( "\n   iteration\n" );
  400c87:	48 8d 3d 2e 4e 00 00 	lea    0x4e2e(%rip),%rdi        # 405abc <_fini+0xf9>
  400c8e:	e8 8e 0a 00 00       	callq  401721 <puts>

/*  Start timer  */             
    timer_start( 0 );
  400c93:	bf 00 00 00 00       	mov    $0x0,%edi
  400c98:	e8 56 05 00 00       	callq  4011f3 <timer_start>


/*  This is the main iteration */
    for( iteration=1; iteration<=MAX_ITERATIONS; iteration++ )
  400c9d:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
  400ca4:	eb 24                	jmp    400cca <main+0x1ca>
    {
        if( CLASS != 'S' ) printf( "        %d\n", iteration );
  400ca6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  400ca9:	89 c6                	mov    %eax,%esi
  400cab:	48 8d 3d 18 4e 00 00 	lea    0x4e18(%rip),%rdi        # 405aca <_fini+0x107>
  400cb2:	b8 00 00 00 00       	mov    $0x0,%eax
  400cb7:	e8 c4 09 00 00       	callq  401680 <printf>
        rank( iteration );
  400cbc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  400cbf:	89 c7                	mov    %eax,%edi
  400cc1:	e8 04 fa ff ff       	callq  4006ca <rank>
    for( iteration=1; iteration<=MAX_ITERATIONS; iteration++ )
  400cc6:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  400cca:	83 7d f8 0a          	cmpl   $0xa,-0x8(%rbp)
  400cce:	7e d6                	jle    400ca6 <main+0x1a6>
    }


/*  End of timing, obtain maximum time of all processors */
    timer_stop( 0 );
  400cd0:	bf 00 00 00 00       	mov    $0x0,%edi
  400cd5:	e8 49 05 00 00       	callq  401223 <timer_stop>
    timecounter = timer_read( 0 );
  400cda:	bf 00 00 00 00       	mov    $0x0,%edi
  400cdf:	e8 b9 05 00 00       	callq  40129d <timer_read>
  400ce4:	66 48 0f 7e c0       	movq   %xmm0,%rax
  400ce9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)


/*  This tests that keys are in sequence: sorting of last ranked key seq
    occurs here, but is an untimed operation                             */
    if (timer_on) timer_start( 2 );
  400ced:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  400cf1:	74 0a                	je     400cfd <main+0x1fd>
  400cf3:	bf 02 00 00 00       	mov    $0x2,%edi
  400cf8:	e8 f6 04 00 00       	callq  4011f3 <timer_start>
    full_verify();
  400cfd:	e8 c5 f8 ff ff       	callq  4005c7 <full_verify>
    if (timer_on) timer_stop( 2 );
  400d02:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  400d06:	74 0a                	je     400d12 <main+0x212>
  400d08:	bf 02 00 00 00       	mov    $0x2,%edi
  400d0d:	e8 11 05 00 00       	callq  401223 <timer_stop>

    if (timer_on) timer_stop( 3 );
  400d12:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  400d16:	74 0a                	je     400d22 <main+0x222>
  400d18:	bf 03 00 00 00       	mov    $0x3,%edi
  400d1d:	e8 01 05 00 00       	callq  401223 <timer_stop>


/*  The final printout  */
    if( passed_verification != 5*MAX_ITERATIONS + 1 )
  400d22:	8b 05 bc 74 20 10    	mov    0x102074bc(%rip),%eax        # 106081e4 <passed_verification>
  400d28:	83 f8 33             	cmp    $0x33,%eax
  400d2b:	74 0a                	je     400d37 <main+0x237>
        passed_verification = 0;
  400d2d:	c7 05 ad 74 20 10 00 	movl   $0x0,0x102074ad(%rip)        # 106081e4 <passed_verification>
  400d34:	00 00 00 
    c_print_results( "IS",
  400d37:	8b 15 a7 74 20 10    	mov    0x102074a7(%rip),%edx        # 106081e4 <passed_verification>
                     64,
                     0,
                     MAX_ITERATIONS,
                     timecounter,
                     ((double) (MAX_ITERATIONS*TOTAL_KEYS))
                                                  /timecounter/1000000.,
  400d3d:	f2 0f 10 05 2b 4f 00 	movsd  0x4f2b(%rip),%xmm0        # 405c70 <_fini+0x2ad>
  400d44:	00 
  400d45:	f2 0f 5e 45 d8       	divsd  -0x28(%rbp),%xmm0
    c_print_results( "IS",
  400d4a:	f2 0f 10 0d 26 4f 00 	movsd  0x4f26(%rip),%xmm1        # 405c78 <_fini+0x2b5>
  400d51:	00 
  400d52:	f2 0f 5e c1          	divsd  %xmm1,%xmm0
  400d56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400d5a:	48 8d 0d 78 4d 00 00 	lea    0x4d78(%rip),%rcx        # 405ad9 <_fini+0x116>
  400d61:	51                   	push   %rcx
  400d62:	48 8d 0d 84 4d 00 00 	lea    0x4d84(%rip),%rcx        # 405aed <_fini+0x12a>
  400d69:	51                   	push   %rcx
  400d6a:	48 8d 0d 9f 4d 00 00 	lea    0x4d9f(%rip),%rcx        # 405b10 <_fini+0x14d>
  400d71:	51                   	push   %rcx
  400d72:	48 8d 0d bf 4d 00 00 	lea    0x4dbf(%rip),%rcx        # 405b38 <_fini+0x175>
  400d79:	51                   	push   %rcx
  400d7a:	48 8d 0d db 4d 00 00 	lea    0x4ddb(%rip),%rcx        # 405b5c <_fini+0x199>
  400d81:	51                   	push   %rcx
  400d82:	48 8d 0d df 4d 00 00 	lea    0x4ddf(%rip),%rcx        # 405b68 <_fini+0x1a5>
  400d89:	51                   	push   %rcx
  400d8a:	48 8d 0d f6 4d 00 00 	lea    0x4df6(%rip),%rcx        # 405b87 <_fini+0x1c4>
  400d91:	51                   	push   %rcx
  400d92:	48 8d 0d fa 4d 00 00 	lea    0x4dfa(%rip),%rcx        # 405b93 <_fini+0x1d0>
  400d99:	51                   	push   %rcx
  400d9a:	52                   	push   %rdx
  400d9b:	48 8d 15 f7 4d 00 00 	lea    0x4df7(%rip),%rdx        # 405b99 <_fini+0x1d6>
  400da2:	52                   	push   %rdx
  400da3:	66 0f 28 c8          	movapd %xmm0,%xmm1
  400da7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  400dab:	f2 0f 10 45 b8       	movsd  -0x48(%rbp),%xmm0
  400db0:	41 b9 0a 00 00 00    	mov    $0xa,%r9d
  400db6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  400dbc:	b9 40 00 00 00       	mov    $0x40,%ecx
  400dc1:	ba 00 00 08 00       	mov    $0x80000,%edx
  400dc6:	be 42 00 00 00       	mov    $0x42,%esi
  400dcb:	48 8d 3d 04 4d 00 00 	lea    0x4d04(%rip),%rdi        # 405ad6 <_fini+0x113>
  400dd2:	e8 74 01 00 00       	callq  400f4b <c_print_results>
  400dd7:	48 83 c4 50          	add    $0x50,%rsp
                     CFLAGS,
                     CLINKFLAGS );


/*  Print additional timers  */
    if (timer_on) {
  400ddb:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  400ddf:	0f 84 5f 01 00 00    	je     400f44 <main+0x444>
       double t_total, t_percent;

       t_total = timer_read( 3 );
  400de5:	bf 03 00 00 00       	mov    $0x3,%edi
  400dea:	e8 ae 04 00 00       	callq  40129d <timer_read>
  400def:	66 48 0f 7e c0       	movq   %xmm0,%rax
  400df4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
       printf("\nAdditional timers -\n");
  400df8:	48 8d 3d a6 4d 00 00 	lea    0x4da6(%rip),%rdi        # 405ba5 <_fini+0x1e2>
  400dff:	e8 1d 09 00 00       	callq  401721 <puts>
       printf(" Total execution: %8.3f\n", t_total);
  400e04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400e08:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  400e0c:	f2 0f 10 45 b8       	movsd  -0x48(%rbp),%xmm0
  400e11:	48 8d 3d a2 4d 00 00 	lea    0x4da2(%rip),%rdi        # 405bba <_fini+0x1f7>
  400e18:	b8 01 00 00 00       	mov    $0x1,%eax
  400e1d:	e8 5e 08 00 00       	callq  401680 <printf>
       if (t_total == 0.0) t_total = 1.0;
  400e22:	66 0f ef c0          	pxor   %xmm0,%xmm0
  400e26:	66 0f 2e 45 e8       	ucomisd -0x18(%rbp),%xmm0
  400e2b:	7a 18                	jp     400e45 <main+0x345>
  400e2d:	66 0f ef c0          	pxor   %xmm0,%xmm0
  400e31:	66 0f 2e 45 e8       	ucomisd -0x18(%rbp),%xmm0
  400e36:	75 0d                	jne    400e45 <main+0x345>
  400e38:	f2 0f 10 05 10 4e 00 	movsd  0x4e10(%rip),%xmm0        # 405c50 <_fini+0x28d>
  400e3f:	00 
  400e40:	f2 0f 11 45 e8       	movsd  %xmm0,-0x18(%rbp)
       timecounter = timer_read(1);
  400e45:	bf 01 00 00 00       	mov    $0x1,%edi
  400e4a:	e8 4e 04 00 00       	callq  40129d <timer_read>
  400e4f:	66 48 0f 7e c0       	movq   %xmm0,%rax
  400e54:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
       t_percent = timecounter/t_total * 100.;
  400e58:	f2 0f 10 45 d8       	movsd  -0x28(%rbp),%xmm0
  400e5d:	f2 0f 5e 45 e8       	divsd  -0x18(%rbp),%xmm0
  400e62:	f2 0f 10 0d 16 4e 00 	movsd  0x4e16(%rip),%xmm1        # 405c80 <_fini+0x2bd>
  400e69:	00 
  400e6a:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  400e6e:	f2 0f 11 45 d0       	movsd  %xmm0,-0x30(%rbp)
       printf(" Initialization : %8.3f (%5.2f%%)\n", timecounter, t_percent);
  400e73:	f2 0f 10 45 d0       	movsd  -0x30(%rbp),%xmm0
  400e78:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400e7c:	66 0f 28 c8          	movapd %xmm0,%xmm1
  400e80:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  400e84:	f2 0f 10 45 b8       	movsd  -0x48(%rbp),%xmm0
  400e89:	48 8d 3d 48 4d 00 00 	lea    0x4d48(%rip),%rdi        # 405bd8 <_fini+0x215>
  400e90:	b8 02 00 00 00       	mov    $0x2,%eax
  400e95:	e8 e6 07 00 00       	callq  401680 <printf>
       timecounter = timer_read(0);
  400e9a:	bf 00 00 00 00       	mov    $0x0,%edi
  400e9f:	e8 f9 03 00 00       	callq  40129d <timer_read>
  400ea4:	66 48 0f 7e c0       	movq   %xmm0,%rax
  400ea9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
       t_percent = timecounter/t_total * 100.;
  400ead:	f2 0f 10 45 d8       	movsd  -0x28(%rbp),%xmm0
  400eb2:	f2 0f 5e 45 e8       	divsd  -0x18(%rbp),%xmm0
  400eb7:	f2 0f 10 0d c1 4d 00 	movsd  0x4dc1(%rip),%xmm1        # 405c80 <_fini+0x2bd>
  400ebe:	00 
  400ebf:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  400ec3:	f2 0f 11 45 d0       	movsd  %xmm0,-0x30(%rbp)
       printf(" Benchmarking   : %8.3f (%5.2f%%)\n", timecounter, t_percent);
  400ec8:	f2 0f 10 45 d0       	movsd  -0x30(%rbp),%xmm0
  400ecd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400ed1:	66 0f 28 c8          	movapd %xmm0,%xmm1
  400ed5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  400ed9:	f2 0f 10 45 b8       	movsd  -0x48(%rbp),%xmm0
  400ede:	48 8d 3d 1b 4d 00 00 	lea    0x4d1b(%rip),%rdi        # 405c00 <_fini+0x23d>
  400ee5:	b8 02 00 00 00       	mov    $0x2,%eax
  400eea:	e8 91 07 00 00       	callq  401680 <printf>
       timecounter = timer_read(2);
  400eef:	bf 02 00 00 00       	mov    $0x2,%edi
  400ef4:	e8 a4 03 00 00       	callq  40129d <timer_read>
  400ef9:	66 48 0f 7e c0       	movq   %xmm0,%rax
  400efe:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
       t_percent = timecounter/t_total * 100.;
  400f02:	f2 0f 10 45 d8       	movsd  -0x28(%rbp),%xmm0
  400f07:	f2 0f 5e 45 e8       	divsd  -0x18(%rbp),%xmm0
  400f0c:	f2 0f 10 0d 6c 4d 00 	movsd  0x4d6c(%rip),%xmm1        # 405c80 <_fini+0x2bd>
  400f13:	00 
  400f14:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  400f18:	f2 0f 11 45 d0       	movsd  %xmm0,-0x30(%rbp)
       printf(" Sorting        : %8.3f (%5.2f%%)\n", timecounter, t_percent);
  400f1d:	f2 0f 10 45 d0       	movsd  -0x30(%rbp),%xmm0
  400f22:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400f26:	66 0f 28 c8          	movapd %xmm0,%xmm1
  400f2a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  400f2e:	f2 0f 10 45 b8       	movsd  -0x48(%rbp),%xmm0
  400f33:	48 8d 3d ee 4c 00 00 	lea    0x4cee(%rip),%rdi        # 405c28 <_fini+0x265>
  400f3a:	b8 02 00 00 00       	mov    $0x2,%eax
  400f3f:	e8 3c 07 00 00       	callq  401680 <printf>
    }


    return 0;
  400f44:	b8 00 00 00 00       	mov    $0x0,%eax
         /**************************/
}        /*  E N D  P R O G R A M  */
  400f49:	c9                   	leaveq 
  400f4a:	c3                   	retq   

0000000000400f4b <c_print_results>:
                      char   *clink,
                      char   *c_lib,
                      char   *c_inc,
                      char   *cflags,
                      char   *clinkflags )
{
  400f4b:	55                   	push   %rbp
  400f4c:	48 89 e5             	mov    %rsp,%rbp
  400f4f:	48 83 ec 50          	sub    $0x50,%rsp
  400f53:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  400f57:	89 f0                	mov    %esi,%eax
  400f59:	89 55 e0             	mov    %edx,-0x20(%rbp)
  400f5c:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  400f5f:	44 89 45 d8          	mov    %r8d,-0x28(%rbp)
  400f63:	44 89 4d d4          	mov    %r9d,-0x2c(%rbp)
  400f67:	f2 0f 11 45 c8       	movsd  %xmm0,-0x38(%rbp)
  400f6c:	f2 0f 11 4d c0       	movsd  %xmm1,-0x40(%rbp)
  400f71:	88 45 e4             	mov    %al,-0x1c(%rbp)
    printf( "\n\n %s Benchmark Completed\n", name ); 
  400f74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400f78:	48 89 c6             	mov    %rax,%rsi
  400f7b:	48 8d 3d 06 4d 00 00 	lea    0x4d06(%rip),%rdi        # 405c88 <_fini+0x2c5>
  400f82:	b8 00 00 00 00       	mov    $0x0,%eax
  400f87:	e8 f4 06 00 00       	callq  401680 <printf>

    printf( " Class           =                        %c\n", class );
  400f8c:	0f be 45 e4          	movsbl -0x1c(%rbp),%eax
  400f90:	89 c6                	mov    %eax,%esi
  400f92:	48 8d 3d 0f 4d 00 00 	lea    0x4d0f(%rip),%rdi        # 405ca8 <_fini+0x2e5>
  400f99:	b8 00 00 00 00       	mov    $0x0,%eax
  400f9e:	e8 dd 06 00 00       	callq  401680 <printf>

    if( n3 == 0 ) {
  400fa3:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  400fa7:	75 3a                	jne    400fe3 <c_print_results+0x98>
        long nn = n1;
  400fa9:	8b 45 e0             	mov    -0x20(%rbp),%eax
  400fac:	48 98                	cltq   
  400fae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        if ( n2 != 0 ) nn *= n2;
  400fb2:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  400fb6:	74 11                	je     400fc9 <c_print_results+0x7e>
  400fb8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  400fbb:	48 98                	cltq   
  400fbd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  400fc1:	48 0f af c2          	imul   %rdx,%rax
  400fc5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        printf( " Size            =             %12ld\n", nn );   /* as in IS */
  400fc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  400fcd:	48 89 c6             	mov    %rax,%rsi
  400fd0:	48 8d 3d 01 4d 00 00 	lea    0x4d01(%rip),%rdi        # 405cd8 <_fini+0x315>
  400fd7:	b8 00 00 00 00       	mov    $0x0,%eax
  400fdc:	e8 9f 06 00 00       	callq  401680 <printf>
  400fe1:	eb 1c                	jmp    400fff <c_print_results+0xb4>
    }
    else
        printf( " Size            =             %4dx%4dx%4d\n", n1,n2,n3 );
  400fe3:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  400fe6:	8b 55 dc             	mov    -0x24(%rbp),%edx
  400fe9:	8b 45 e0             	mov    -0x20(%rbp),%eax
  400fec:	89 c6                	mov    %eax,%esi
  400fee:	48 8d 3d 0b 4d 00 00 	lea    0x4d0b(%rip),%rdi        # 405d00 <_fini+0x33d>
  400ff5:	b8 00 00 00 00       	mov    $0x0,%eax
  400ffa:	e8 81 06 00 00       	callq  401680 <printf>

    printf( " Iterations      =             %12d\n", niter );
  400fff:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  401002:	89 c6                	mov    %eax,%esi
  401004:	48 8d 3d 25 4d 00 00 	lea    0x4d25(%rip),%rdi        # 405d30 <_fini+0x36d>
  40100b:	b8 00 00 00 00       	mov    $0x0,%eax
  401010:	e8 6b 06 00 00       	callq  401680 <printf>
 
    printf( " Time in seconds =             %12.2f\n", t );
  401015:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  401019:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  40101d:	f2 0f 10 45 b8       	movsd  -0x48(%rbp),%xmm0
  401022:	48 8d 3d 2f 4d 00 00 	lea    0x4d2f(%rip),%rdi        # 405d58 <_fini+0x395>
  401029:	b8 01 00 00 00       	mov    $0x1,%eax
  40102e:	e8 4d 06 00 00       	callq  401680 <printf>

    printf( " Mop/s total     =             %12.2f\n", mops );
  401033:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  401037:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  40103b:	f2 0f 10 45 b8       	movsd  -0x48(%rbp),%xmm0
  401040:	48 8d 3d 39 4d 00 00 	lea    0x4d39(%rip),%rdi        # 405d80 <_fini+0x3bd>
  401047:	b8 01 00 00 00       	mov    $0x1,%eax
  40104c:	e8 2f 06 00 00       	callq  401680 <printf>

    printf( " Operation type  = %24s\n", optype);
  401051:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  401055:	48 8d 3d 4b 4d 00 00 	lea    0x4d4b(%rip),%rdi        # 405da7 <_fini+0x3e4>
  40105c:	b8 00 00 00 00       	mov    $0x0,%eax
  401061:	e8 1a 06 00 00       	callq  401680 <printf>

    if( passed_verification < 0 )
  401066:	83 7d 18 00          	cmpl   $0x0,0x18(%rbp)
  40106a:	79 0e                	jns    40107a <c_print_results+0x12f>
        printf( " Verification    =            NOT PERFORMED\n" );
  40106c:	48 8d 3d 4d 4d 00 00 	lea    0x4d4d(%rip),%rdi        # 405dc0 <_fini+0x3fd>
  401073:	e8 a9 06 00 00       	callq  401721 <puts>
  401078:	eb 20                	jmp    40109a <c_print_results+0x14f>
    else if( passed_verification )
  40107a:	83 7d 18 00          	cmpl   $0x0,0x18(%rbp)
  40107e:	74 0e                	je     40108e <c_print_results+0x143>
        printf( " Verification    =               SUCCESSFUL\n" );
  401080:	48 8d 3d 69 4d 00 00 	lea    0x4d69(%rip),%rdi        # 405df0 <_fini+0x42d>
  401087:	e8 95 06 00 00       	callq  401721 <puts>
  40108c:	eb 0c                	jmp    40109a <c_print_results+0x14f>
    else
        printf( " Verification    =             UNSUCCESSFUL\n" );
  40108e:	48 8d 3d 8b 4d 00 00 	lea    0x4d8b(%rip),%rdi        # 405e20 <_fini+0x45d>
  401095:	e8 87 06 00 00       	callq  401721 <puts>

    printf( " Version         =             %12s\n", npbversion );
  40109a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  40109e:	48 89 c6             	mov    %rax,%rsi
  4010a1:	48 8d 3d a8 4d 00 00 	lea    0x4da8(%rip),%rdi        # 405e50 <_fini+0x48d>
  4010a8:	b8 00 00 00 00       	mov    $0x0,%eax
  4010ad:	e8 ce 05 00 00       	callq  401680 <printf>

    printf( " Compile date    =             %12s\n", compiletime );
  4010b2:	48 8b 45 28          	mov    0x28(%rbp),%rax
  4010b6:	48 89 c6             	mov    %rax,%rsi
  4010b9:	48 8d 3d b8 4d 00 00 	lea    0x4db8(%rip),%rdi        # 405e78 <_fini+0x4b5>
  4010c0:	b8 00 00 00 00       	mov    $0x0,%eax
  4010c5:	e8 b6 05 00 00       	callq  401680 <printf>

    printf( "\n Compile options:\n" );
  4010ca:	48 8d 3d cc 4d 00 00 	lea    0x4dcc(%rip),%rdi        # 405e9d <_fini+0x4da>
  4010d1:	e8 4b 06 00 00       	callq  401721 <puts>

    printf( "    CC           = %s\n", cc );
  4010d6:	48 8b 45 30          	mov    0x30(%rbp),%rax
  4010da:	48 89 c6             	mov    %rax,%rsi
  4010dd:	48 8d 3d cc 4d 00 00 	lea    0x4dcc(%rip),%rdi        # 405eb0 <_fini+0x4ed>
  4010e4:	b8 00 00 00 00       	mov    $0x0,%eax
  4010e9:	e8 92 05 00 00       	callq  401680 <printf>

    printf( "    CLINK        = %s\n", clink );
  4010ee:	48 8b 45 38          	mov    0x38(%rbp),%rax
  4010f2:	48 89 c6             	mov    %rax,%rsi
  4010f5:	48 8d 3d cb 4d 00 00 	lea    0x4dcb(%rip),%rdi        # 405ec7 <_fini+0x504>
  4010fc:	b8 00 00 00 00       	mov    $0x0,%eax
  401101:	e8 7a 05 00 00       	callq  401680 <printf>

    printf( "    C_LIB        = %s\n", c_lib );
  401106:	48 8b 45 40          	mov    0x40(%rbp),%rax
  40110a:	48 89 c6             	mov    %rax,%rsi
  40110d:	48 8d 3d ca 4d 00 00 	lea    0x4dca(%rip),%rdi        # 405ede <_fini+0x51b>
  401114:	b8 00 00 00 00       	mov    $0x0,%eax
  401119:	e8 62 05 00 00       	callq  401680 <printf>

    printf( "    C_INC        = %s\n", c_inc );
  40111e:	48 8b 45 48          	mov    0x48(%rbp),%rax
  401122:	48 89 c6             	mov    %rax,%rsi
  401125:	48 8d 3d c9 4d 00 00 	lea    0x4dc9(%rip),%rdi        # 405ef5 <_fini+0x532>
  40112c:	b8 00 00 00 00       	mov    $0x0,%eax
  401131:	e8 4a 05 00 00       	callq  401680 <printf>

    printf( "    CFLAGS       = %s\n", cflags );
  401136:	48 8b 45 50          	mov    0x50(%rbp),%rax
  40113a:	48 89 c6             	mov    %rax,%rsi
  40113d:	48 8d 3d c8 4d 00 00 	lea    0x4dc8(%rip),%rdi        # 405f0c <_fini+0x549>
  401144:	b8 00 00 00 00       	mov    $0x0,%eax
  401149:	e8 32 05 00 00       	callq  401680 <printf>

    printf( "    CLINKFLAGS   = %s\n", clinkflags );
  40114e:	48 8b 45 58          	mov    0x58(%rbp),%rax
  401152:	48 89 c6             	mov    %rax,%rsi
  401155:	48 8d 3d c7 4d 00 00 	lea    0x4dc7(%rip),%rdi        # 405f23 <_fini+0x560>
  40115c:	b8 00 00 00 00       	mov    $0x0,%eax
  401161:	e8 1a 05 00 00       	callq  401680 <printf>
#ifdef SMP
    evalue = getenv("MP_SET_NUMTHREADS");
    printf( "   MULTICPUS = %s\n", evalue );
#endif

    printf( "\n--------------------------------------\n");
  401166:	48 8d 3d d3 4d 00 00 	lea    0x4dd3(%rip),%rdi        # 405f40 <_fini+0x57d>
  40116d:	e8 af 05 00 00       	callq  401721 <puts>
    printf( " Please send all errors/feedbacks to:\n");
  401172:	48 8d 3d ef 4d 00 00 	lea    0x4def(%rip),%rdi        # 405f68 <_fini+0x5a5>
  401179:	e8 a3 05 00 00       	callq  401721 <puts>
    printf( " Center for Manycore Programming\n");
  40117e:	48 8d 3d 0b 4e 00 00 	lea    0x4e0b(%rip),%rdi        # 405f90 <_fini+0x5cd>
  401185:	e8 97 05 00 00       	callq  401721 <puts>
    printf( " cmp@aces.snu.ac.kr\n");
  40118a:	48 8d 3d 20 4e 00 00 	lea    0x4e20(%rip),%rdi        # 405fb1 <_fini+0x5ee>
  401191:	e8 8b 05 00 00       	callq  401721 <puts>
    printf( " http://aces.snu.ac.kr\n");
  401196:	48 8d 3d 28 4e 00 00 	lea    0x4e28(%rip),%rdi        # 405fc5 <_fini+0x602>
  40119d:	e8 7f 05 00 00       	callq  401721 <puts>
    printf( "--------------------------------------\n");
  4011a2:	48 8d 3d 37 4e 00 00 	lea    0x4e37(%rip),%rdi        # 405fe0 <_fini+0x61d>
  4011a9:	e8 73 05 00 00       	callq  401721 <puts>
}
  4011ae:	90                   	nop
  4011af:	c9                   	leaveq 
  4011b0:	c3                   	retq   

00000000004011b1 <elapsed_time>:

/*****************************************************************/
/******         E  L  A  P  S  E  D  _  T  I  M  E          ******/
/*****************************************************************/
static double elapsed_time( void )
{
  4011b1:	55                   	push   %rbp
  4011b2:	48 89 e5             	mov    %rsp,%rbp
  4011b5:	48 83 ec 10          	sub    $0x10,%rsp
    double t;

    wtime( &t );
  4011b9:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  4011bd:	48 89 c7             	mov    %rax,%rdi
  4011c0:	e8 fa 00 00 00       	callq  4012bf <wtime_>
    return( t );
  4011c5:	f2 0f 10 45 f8       	movsd  -0x8(%rbp),%xmm0
}
  4011ca:	c9                   	leaveq 
  4011cb:	c3                   	retq   

00000000004011cc <timer_clear>:

/*****************************************************************/
/******            T  I  M  E  R  _  C  L  E  A  R          ******/
/*****************************************************************/
void timer_clear( int n )
{
  4011cc:	55                   	push   %rbp
  4011cd:	48 89 e5             	mov    %rsp,%rbp
  4011d0:	89 7d fc             	mov    %edi,-0x4(%rbp)
    elapsed[n] = 0.0;
  4011d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4011d6:	48 98                	cltq   
  4011d8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  4011df:	00 
  4011e0:	48 8d 05 19 63 20 00 	lea    0x206319(%rip),%rax        # 607500 <elapsed>
  4011e7:	66 0f ef c0          	pxor   %xmm0,%xmm0
  4011eb:	f2 0f 11 04 02       	movsd  %xmm0,(%rdx,%rax,1)
}
  4011f0:	90                   	nop
  4011f1:	5d                   	pop    %rbp
  4011f2:	c3                   	retq   

00000000004011f3 <timer_start>:

/*****************************************************************/
/******            T  I  M  E  R  _  S  T  A  R  T          ******/
/*****************************************************************/
void timer_start( int n )
{
  4011f3:	55                   	push   %rbp
  4011f4:	48 89 e5             	mov    %rsp,%rbp
  4011f7:	48 83 ec 10          	sub    $0x10,%rsp
  4011fb:	89 7d fc             	mov    %edi,-0x4(%rbp)
    start[n] = elapsed_time();
  4011fe:	e8 ae ff ff ff       	callq  4011b1 <elapsed_time>
  401203:	66 48 0f 7e c2       	movq   %xmm0,%rdx
  401208:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40120b:	48 98                	cltq   
  40120d:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
  401214:	00 
  401215:	48 8d 05 e4 60 20 00 	lea    0x2060e4(%rip),%rax        # 607300 <start>
  40121c:	48 89 14 01          	mov    %rdx,(%rcx,%rax,1)
}
  401220:	90                   	nop
  401221:	c9                   	leaveq 
  401222:	c3                   	retq   

0000000000401223 <timer_stop>:

/*****************************************************************/
/******            T  I  M  E  R  _  S  T  O  P             ******/
/*****************************************************************/
void timer_stop( int n )
{
  401223:	55                   	push   %rbp
  401224:	48 89 e5             	mov    %rsp,%rbp
  401227:	48 83 ec 20          	sub    $0x20,%rsp
  40122b:	89 7d ec             	mov    %edi,-0x14(%rbp)
    double t, now;

    now = elapsed_time();
  40122e:	e8 7e ff ff ff       	callq  4011b1 <elapsed_time>
  401233:	66 48 0f 7e c0       	movq   %xmm0,%rax
  401238:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    t = now - start[n];
  40123c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  40123f:	48 98                	cltq   
  401241:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  401248:	00 
  401249:	48 8d 05 b0 60 20 00 	lea    0x2060b0(%rip),%rax        # 607300 <start>
  401250:	f2 0f 10 0c 02       	movsd  (%rdx,%rax,1),%xmm1
  401255:	f2 0f 10 45 f8       	movsd  -0x8(%rbp),%xmm0
  40125a:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
  40125e:	f2 0f 11 45 f0       	movsd  %xmm0,-0x10(%rbp)
    elapsed[n] += t;
  401263:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401266:	48 98                	cltq   
  401268:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  40126f:	00 
  401270:	48 8d 05 89 62 20 00 	lea    0x206289(%rip),%rax        # 607500 <elapsed>
  401277:	f2 0f 10 04 02       	movsd  (%rdx,%rax,1),%xmm0
  40127c:	f2 0f 58 45 f0       	addsd  -0x10(%rbp),%xmm0
  401281:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401284:	48 98                	cltq   
  401286:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  40128d:	00 
  40128e:	48 8d 05 6b 62 20 00 	lea    0x20626b(%rip),%rax        # 607500 <elapsed>
  401295:	f2 0f 11 04 02       	movsd  %xmm0,(%rdx,%rax,1)

}
  40129a:	90                   	nop
  40129b:	c9                   	leaveq 
  40129c:	c3                   	retq   

000000000040129d <timer_read>:

/*****************************************************************/
/******            T  I  M  E  R  _  R  E  A  D             ******/
/*****************************************************************/
double timer_read( int n )
{
  40129d:	55                   	push   %rbp
  40129e:	48 89 e5             	mov    %rsp,%rbp
  4012a1:	89 7d fc             	mov    %edi,-0x4(%rbp)
    return( elapsed[n] );
  4012a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4012a7:	48 98                	cltq   
  4012a9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  4012b0:	00 
  4012b1:	48 8d 05 48 62 20 00 	lea    0x206248(%rip),%rax        # 607500 <elapsed>
  4012b8:	f2 0f 10 04 02       	movsd  (%rdx,%rax,1),%xmm0
}
  4012bd:	5d                   	pop    %rbp
  4012be:	c3                   	retq   

00000000004012bf <wtime_>:
#ifndef DOS
#include <sys/time.h>
#endif

void wtime(double *t)
{
  4012bf:	55                   	push   %rbp
  4012c0:	48 89 e5             	mov    %rsp,%rbp
  4012c3:	48 83 ec 20          	sub    $0x20,%rsp
  4012c7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  static int sec = -1;
  struct timeval tv;
  gettimeofday(&tv, (void *)0);
  4012cb:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  4012cf:	be 00 00 00 00       	mov    $0x0,%esi
  4012d4:	48 89 c7             	mov    %rax,%rdi
  4012d7:	e8 99 21 00 00       	callq  403475 <gettimeofday>
  if (sec < 0) sec = tv.tv_sec;
  4012dc:	8b 05 c2 5e 20 00    	mov    0x205ec2(%rip),%eax        # 6071a4 <sec.1939>
  4012e2:	85 c0                	test   %eax,%eax
  4012e4:	79 0a                	jns    4012f0 <wtime_+0x31>
  4012e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4012ea:	89 05 b4 5e 20 00    	mov    %eax,0x205eb4(%rip)        # 6071a4 <sec.1939>
  *t = (tv.tv_sec - sec) + 1.0e-6*tv.tv_usec;
  4012f0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  4012f4:	8b 05 aa 5e 20 00    	mov    0x205eaa(%rip),%eax        # 6071a4 <sec.1939>
  4012fa:	48 98                	cltq   
  4012fc:	48 29 c2             	sub    %rax,%rdx
  4012ff:	48 89 d0             	mov    %rdx,%rax
  401302:	66 0f ef c9          	pxor   %xmm1,%xmm1
  401306:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
  40130b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40130f:	66 0f ef c0          	pxor   %xmm0,%xmm0
  401313:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  401318:	f2 0f 10 15 e8 4c 00 	movsd  0x4ce8(%rip),%xmm2        # 406008 <_fini+0x645>
  40131f:	00 
  401320:	f2 0f 59 c2          	mulsd  %xmm2,%xmm0
  401324:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  401328:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40132c:	f2 0f 11 00          	movsd  %xmm0,(%rax)
}
  401330:	90                   	nop
  401331:	c9                   	leaveq 
  401332:	c3                   	retq   

0000000000401333 <dummy>:
#include "atomic.h"
#include "libc.h"

void __init_tls(size_t *);

static void dummy(void) {}
  401333:	c3                   	retq   

0000000000401334 <__init_ssp>:
weak_alias(dummy, _init);

__attribute__((__weak__, __visibility__("hidden")))
extern void (*const __init_array_start)(void), (*const __init_array_end)(void);

static void dummy1(void *p) {}
  401334:	c3                   	retq   

0000000000401335 <__init_libc>:
#define AUX_CNT 38

void __init_libc(char **envp, char *pn)
{
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
	__environ = envp;
  401335:	48 c7 c0 48 7b 60 00 	mov    $0x607b48,%rax
//	__hwcap = aux[AT_HWCAP];
//	__sysinfo = aux[AT_SYSINFO];
//	libc.page_size = aux[AT_PAGESZ];

//	if (!pn) pn = (void*)aux[AT_EXECFN];
	if (!pn) pn = "";
  40133c:	48 85 f6             	test   %rsi,%rsi
	__progname = __progname_full = pn;
  40133f:	48 c7 c2 08 77 60 00 	mov    $0x607708,%rdx
	__environ = envp;
  401346:	48 89 38             	mov    %rdi,(%rax)
	if (!pn) pn = "";
  401349:	48 8d 05 41 4d 00 00 	lea    0x4d41(%rip),%rax        # 406091 <_fini+0x6ce>
  401350:	48 0f 44 f0          	cmove  %rax,%rsi
	__progname = __progname_full = pn;
  401354:	48 c7 c0 00 77 60 00 	mov    $0x607700,%rax
  40135b:	48 89 30             	mov    %rsi,(%rax)
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
  40135e:	48 89 32             	mov    %rsi,(%rdx)
  401361:	48 ff c6             	inc    %rsi
  401364:	8a 46 ff             	mov    -0x1(%rsi),%al
  401367:	84 c0                	test   %al,%al
  401369:	74 06                	je     401371 <__init_libc+0x3c>
  40136b:	3c 2f                	cmp    $0x2f,%al
  40136d:	75 f2                	jne    401361 <__init_libc+0x2c>
  40136f:	eb ed                	jmp    40135e <__init_libc+0x29>
#endif
	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
		if (__sys_open("/dev/null", O_RDWR)<0)
			a_crash();
	libc.secure = 1;
}
  401371:	c3                   	retq   

0000000000401372 <__libc_start_init>:

static void libc_start_init(void)
{
  401372:	53                   	push   %rbx
	_init();
  401373:	e8 a8 ed ff ff       	callq  400120 <_init>
	uintptr_t a = (uintptr_t)&__init_array_start;
  401378:	48 c7 c3 e0 6f 60 00 	mov    $0x606fe0,%rbx
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  40137f:	48 81 fb e8 6f 60 00 	cmp    $0x606fe8,%rbx
  401386:	73 08                	jae    401390 <__libc_start_init+0x1e>
		(*(void (**)(void))a)();
  401388:	ff 13                	callq  *(%rbx)
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
  40138a:	48 83 c3 08          	add    $0x8,%rbx
  40138e:	eb ef                	jmp    40137f <__libc_start_init+0xd>
}
  401390:	5b                   	pop    %rbx
  401391:	c3                   	retq   

0000000000401392 <__libc_start_main>:

weak_alias(libc_start_init, __libc_start_init);

int __libc_start_main(int (*main)(int,char **,char **), int argc, char **argv)
{
  401392:	41 55                	push   %r13
  401394:	41 54                	push   %r12
  401396:	48 63 c6             	movslq %esi,%rax
  401399:	55                   	push   %rbp
  40139a:	53                   	push   %rbx
	char **envp = argv+argc+1;
  40139b:	4c 8d 64 c2 08       	lea    0x8(%rdx,%rax,8),%r12
{
  4013a0:	48 89 c5             	mov    %rax,%rbp
  4013a3:	48 89 d3             	mov    %rdx,%rbx
  4013a6:	49 89 fd             	mov    %rdi,%r13
  4013a9:	48 83 ec 08          	sub    $0x8,%rsp

	__init_libc(envp, argv[0]);
  4013ad:	48 8b 32             	mov    (%rdx),%rsi
  4013b0:	4c 89 e7             	mov    %r12,%rdi
  4013b3:	e8 7d ff ff ff       	callq  401335 <__init_libc>
	__libc_start_init();
  4013b8:	e8 b5 ff ff ff       	callq  401372 <__libc_start_init>

	/* Pass control to the application */
	exit(main(argc, argv, envp));
  4013bd:	89 ef                	mov    %ebp,%edi
  4013bf:	4c 89 e2             	mov    %r12,%rdx
  4013c2:	48 89 de             	mov    %rbx,%rsi
  4013c5:	41 ff d5             	callq  *%r13
  4013c8:	89 c7                	mov    %eax,%edi
  4013ca:	e8 61 ed ff ff       	callq  400130 <exit>

00000000004013cf <__funcs_on_exit>:
{
  4013cf:	c3                   	retq   

00000000004013d0 <__libc_exit_fini>:
{
  4013d0:	53                   	push   %rbx
	uintptr_t a = (uintptr_t)&__fini_array_end;
  4013d1:	48 c7 c3 f0 6f 60 00 	mov    $0x606ff0,%rbx
	for (; a>(uintptr_t)&__fini_array_start; a-=sizeof(void(*)()))
  4013d8:	48 81 fb e8 6f 60 00 	cmp    $0x606fe8,%rbx
  4013df:	76 0a                	jbe    4013eb <__libc_exit_fini+0x1b>
		(*(void (**)())(a-sizeof(void(*)())))();
  4013e1:	48 83 eb 08          	sub    $0x8,%rbx
  4013e5:	31 c0                	xor    %eax,%eax
  4013e7:	ff 13                	callq  *(%rbx)
  4013e9:	eb ed                	jmp    4013d8 <__libc_exit_fini+0x8>
}
  4013eb:	5b                   	pop    %rbx
	_fini();
  4013ec:	31 c0                	xor    %eax,%eax
  4013ee:	e9 d0 45 00 00       	jmpq   4059c3 <_fini>

00000000004013f3 <__unlist_locked_file>:
#include "stdio_impl.h"
#include "libc.h"

static void dummy(FILE *f) { }
  4013f3:	c3                   	retq   

00000000004013f4 <fclose>:
weak_alias(dummy, __unlist_locked_file);

int fclose(FILE *f)
{
  4013f4:	41 55                	push   %r13
  4013f6:	41 54                	push   %r12
  4013f8:	45 31 ed             	xor    %r13d,%r13d
  4013fb:	55                   	push   %rbp
  4013fc:	53                   	push   %rbx
  4013fd:	48 89 fb             	mov    %rdi,%rbx
  401400:	48 83 ec 08          	sub    $0x8,%rsp
	int r;
	int perm;
	
	FLOCK(f);
  401404:	8b 87 8c 00 00 00    	mov    0x8c(%rdi),%eax
  40140a:	85 c0                	test   %eax,%eax
  40140c:	78 08                	js     401416 <fclose+0x22>
  40140e:	e8 c4 38 00 00       	callq  404cd7 <__lockfile>
  401413:	41 89 c5             	mov    %eax,%r13d

	__unlist_locked_file(f);
  401416:	48 89 df             	mov    %rbx,%rdi
  401419:	e8 d5 ff ff ff       	callq  4013f3 <__unlist_locked_file>

	if (!(perm = f->flags & F_PERM)) {
  40141e:	8b 2b                	mov    (%rbx),%ebp
  401420:	83 e5 01             	and    $0x1,%ebp
  401423:	75 30                	jne    401455 <fclose+0x61>
		FILE **head = __ofl_lock();
  401425:	e8 31 02 00 00       	callq  40165b <__ofl_lock>
		if (f->prev) f->prev->next = f->next;
  40142a:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
  40142e:	48 85 c9             	test   %rcx,%rcx
  401431:	74 08                	je     40143b <fclose+0x47>
  401433:	48 8b 53 70          	mov    0x70(%rbx),%rdx
  401437:	48 89 51 70          	mov    %rdx,0x70(%rcx)
		if (f->next) f->next->prev = f->prev;
  40143b:	48 8b 53 70          	mov    0x70(%rbx),%rdx
  40143f:	48 85 d2             	test   %rdx,%rdx
  401442:	74 04                	je     401448 <fclose+0x54>
  401444:	48 89 4a 68          	mov    %rcx,0x68(%rdx)
		if (*head == f) *head = f->next;
  401448:	48 3b 18             	cmp    (%rax),%rbx
  40144b:	75 03                	jne    401450 <fclose+0x5c>
  40144d:	48 89 10             	mov    %rdx,(%rax)
		__ofl_unlock();
  401450:	e8 1f 02 00 00       	callq  401674 <__ofl_unlock>
	}

	r = fflush(f);
  401455:	48 89 df             	mov    %rbx,%rdi
  401458:	e8 43 00 00 00       	callq  4014a0 <fflush>
	r |= f->close(f);
  40145d:	48 89 df             	mov    %rbx,%rdi
	r = fflush(f);
  401460:	41 89 c4             	mov    %eax,%r12d
	r |= f->close(f);
  401463:	ff 53 18             	callq  *0x18(%rbx)

	if (f->getln_buf) free(f->getln_buf);
  401466:	48 8b bb a8 00 00 00 	mov    0xa8(%rbx),%rdi
	r |= f->close(f);
  40146d:	41 09 c4             	or     %eax,%r12d
	if (f->getln_buf) free(f->getln_buf);
  401470:	48 85 ff             	test   %rdi,%rdi
  401473:	74 05                	je     40147a <fclose+0x86>
  401475:	e8 a6 26 00 00       	callq  403b20 <free>
	if (!perm) free(f);
  40147a:	85 ed                	test   %ebp,%ebp
  40147c:	75 0a                	jne    401488 <fclose+0x94>
  40147e:	48 89 df             	mov    %rbx,%rdi
  401481:	e8 9a 26 00 00       	callq  403b20 <free>
  401486:	eb 0d                	jmp    401495 <fclose+0xa1>
	else FUNLOCK(f);
  401488:	45 85 ed             	test   %r13d,%r13d
  40148b:	74 08                	je     401495 <fclose+0xa1>
  40148d:	48 89 df             	mov    %rbx,%rdi
  401490:	e8 96 38 00 00       	callq  404d2b <__unlockfile>

	return r;
}
  401495:	5a                   	pop    %rdx
  401496:	44 89 e0             	mov    %r12d,%eax
  401499:	5b                   	pop    %rbx
  40149a:	5d                   	pop    %rbp
  40149b:	41 5c                	pop    %r12
  40149d:	41 5d                	pop    %r13
  40149f:	c3                   	retq   

00000000004014a0 <fflush>:
static FILE *volatile dummy = 0;
weak_alias(dummy, __stdout_used);

int fflush(FILE *f)
{
	if (!f) {
  4014a0:	48 85 ff             	test   %rdi,%rdi
{
  4014a3:	41 54                	push   %r12
  4014a5:	55                   	push   %rbp
  4014a6:	53                   	push   %rbx
	if (!f) {
  4014a7:	75 71                	jne    40151a <fflush+0x7a>
		int r = __stdout_used ? fflush(__stdout_used) : 0;
  4014a9:	48 c7 c0 a8 71 60 00 	mov    $0x6071a8,%rax
  4014b0:	31 ed                	xor    %ebp,%ebp
  4014b2:	48 8b 10             	mov    (%rax),%rdx
  4014b5:	48 85 d2             	test   %rdx,%rdx
  4014b8:	74 0a                	je     4014c4 <fflush+0x24>
  4014ba:	48 8b 38             	mov    (%rax),%rdi
  4014bd:	e8 de ff ff ff       	callq  4014a0 <fflush>
  4014c2:	89 c5                	mov    %eax,%ebp

		for (f=*__ofl_lock(); f; f=f->next) {
  4014c4:	e8 92 01 00 00       	callq  40165b <__ofl_lock>
  4014c9:	48 8b 18             	mov    (%rax),%rbx
  4014cc:	48 85 db             	test   %rbx,%rbx
  4014cf:	74 3f                	je     401510 <fflush+0x70>
			FLOCK(f);
  4014d1:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
  4014d7:	45 31 e4             	xor    %r12d,%r12d
  4014da:	85 c0                	test   %eax,%eax
  4014dc:	78 0b                	js     4014e9 <fflush+0x49>
  4014de:	48 89 df             	mov    %rbx,%rdi
  4014e1:	e8 f1 37 00 00       	callq  404cd7 <__lockfile>
  4014e6:	41 89 c4             	mov    %eax,%r12d
			if (f->wpos > f->wbase) r |= fflush(f);
  4014e9:	48 8b 43 38          	mov    0x38(%rbx),%rax
  4014ed:	48 39 43 28          	cmp    %rax,0x28(%rbx)
  4014f1:	76 0a                	jbe    4014fd <fflush+0x5d>
  4014f3:	48 89 df             	mov    %rbx,%rdi
  4014f6:	e8 a5 ff ff ff       	callq  4014a0 <fflush>
  4014fb:	09 c5                	or     %eax,%ebp
			FUNLOCK(f);
  4014fd:	45 85 e4             	test   %r12d,%r12d
  401500:	74 08                	je     40150a <fflush+0x6a>
  401502:	48 89 df             	mov    %rbx,%rdi
  401505:	e8 21 38 00 00       	callq  404d2b <__unlockfile>
		for (f=*__ofl_lock(); f; f=f->next) {
  40150a:	48 8b 5b 70          	mov    0x70(%rbx),%rbx
  40150e:	eb bc                	jmp    4014cc <fflush+0x2c>
		}
		__ofl_unlock();
  401510:	e8 5f 01 00 00       	callq  401674 <__ofl_unlock>

		return r;
  401515:	e9 95 00 00 00       	jmpq   4015af <fflush+0x10f>
	}

	FLOCK(f);
  40151a:	8b 87 8c 00 00 00    	mov    0x8c(%rdi),%eax
  401520:	31 ed                	xor    %ebp,%ebp
  401522:	48 89 fb             	mov    %rdi,%rbx
  401525:	85 c0                	test   %eax,%eax
  401527:	78 07                	js     401530 <fflush+0x90>
  401529:	e8 a9 37 00 00       	callq  404cd7 <__lockfile>
  40152e:	89 c5                	mov    %eax,%ebp

	/* If writing, flush output */
	if (f->wpos > f->wbase) {
  401530:	48 8b 43 38          	mov    0x38(%rbx),%rax
  401534:	48 39 43 28          	cmp    %rax,0x28(%rbx)
  401538:	76 1f                	jbe    401559 <fflush+0xb9>
		f->write(f, 0, 0);
  40153a:	31 d2                	xor    %edx,%edx
  40153c:	31 f6                	xor    %esi,%esi
  40153e:	48 89 df             	mov    %rbx,%rdi
  401541:	ff 53 48             	callq  *0x48(%rbx)
		if (!f->wpos) {
  401544:	48 83 7b 28 00       	cmpq   $0x0,0x28(%rbx)
  401549:	75 0e                	jne    401559 <fflush+0xb9>
			FUNLOCK(f);
  40154b:	85 ed                	test   %ebp,%ebp
  40154d:	74 5d                	je     4015ac <fflush+0x10c>
  40154f:	48 89 df             	mov    %rbx,%rdi
  401552:	e8 d4 37 00 00       	callq  404d2b <__unlockfile>
  401557:	eb 53                	jmp    4015ac <fflush+0x10c>
			return EOF;
		}
	}

	/* If reading, sync position, per POSIX */
	if (f->rpos < f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  401559:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  40155d:	48 8b 43 10          	mov    0x10(%rbx),%rax
  401561:	48 39 c6             	cmp    %rax,%rsi
  401564:	73 0e                	jae    401574 <fflush+0xd4>
  401566:	48 29 c6             	sub    %rax,%rsi
  401569:	ba 01 00 00 00       	mov    $0x1,%edx
  40156e:	48 89 df             	mov    %rbx,%rdi
  401571:	ff 53 50             	callq  *0x50(%rbx)

	/* Clear read and write modes */
	f->wpos = f->wbase = f->wend = 0;
	f->rpos = f->rend = 0;

	FUNLOCK(f);
  401574:	85 ed                	test   %ebp,%ebp
	f->wpos = f->wbase = f->wend = 0;
  401576:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
  40157d:	00 
  40157e:	48 c7 43 38 00 00 00 	movq   $0x0,0x38(%rbx)
  401585:	00 
  401586:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
  40158d:	00 
	f->rpos = f->rend = 0;
  40158e:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  401595:	00 
  401596:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  40159d:	00 
	FUNLOCK(f);
  40159e:	74 0f                	je     4015af <fflush+0x10f>
  4015a0:	48 89 df             	mov    %rbx,%rdi
	return 0;
  4015a3:	31 ed                	xor    %ebp,%ebp
	FUNLOCK(f);
  4015a5:	e8 81 37 00 00       	callq  404d2b <__unlockfile>
  4015aa:	eb 03                	jmp    4015af <fflush+0x10f>
			return EOF;
  4015ac:	83 cd ff             	or     $0xffffffff,%ebp
}
  4015af:	89 e8                	mov    %ebp,%eax
  4015b1:	5b                   	pop    %rbx
  4015b2:	5d                   	pop    %rbp
  4015b3:	41 5c                	pop    %r12
  4015b5:	c3                   	retq   

00000000004015b6 <fopen>:
#include <fcntl.h>
#include <string.h>
#include <errno.h>

FILE *fopen(const char *restrict filename, const char *restrict mode)
{
  4015b6:	41 55                	push   %r13
  4015b8:	41 54                	push   %r12
  4015ba:	55                   	push   %rbp
  4015bb:	53                   	push   %rbx
  4015bc:	48 89 f5             	mov    %rsi,%rbp
  4015bf:	48 89 fb             	mov    %rdi,%rbx
	FILE *f;
	int fd;
	int flags;

	/* Check for valid initial mode character */
	if (!strchr("rwa", *mode)) {
  4015c2:	48 8d 3d 47 4a 00 00 	lea    0x4a47(%rip),%rdi        # 406010 <_fini+0x64d>
{
  4015c9:	48 83 ec 08          	sub    $0x8,%rsp
	if (!strchr("rwa", *mode)) {
  4015cd:	0f be 36             	movsbl (%rsi),%esi
  4015d0:	e8 0b 1b 00 00       	callq  4030e0 <strchr>
  4015d5:	48 85 c0             	test   %rax,%rax
  4015d8:	75 0f                	jne    4015e9 <fopen+0x33>
		errno = EINVAL;
  4015da:	e8 d1 1e 00 00       	callq  4034b0 <__errno_location>
  4015df:	31 f6                	xor    %esi,%esi
  4015e1:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
  4015e7:	eb 67                	jmp    401650 <fopen+0x9a>
		return 0;
	}

	/* Compute the flags to pass to open() */
	flags = __fmodeflags(mode);
  4015e9:	48 89 ef             	mov    %rbp,%rdi
}

static __inline long __syscall3(long n, long a1, long a2, long a3)
{
	unsigned long ret;
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  4015ec:	41 bc 02 00 00 00    	mov    $0x2,%r12d
  4015f2:	e8 5e 36 00 00       	callq  404c55 <__fmodeflags>
  4015f7:	48 63 f0             	movslq %eax,%rsi
  4015fa:	ba b6 01 00 00       	mov    $0x1b6,%edx
  4015ff:	4c 89 e0             	mov    %r12,%rax
  401602:	49 89 f5             	mov    %rsi,%r13
  401605:	48 89 df             	mov    %rbx,%rdi
  401608:	0f 05                	syscall 
  40160a:	48 89 c7             	mov    %rax,%rdi

	fd = sys_open(filename, flags, 0666);
  40160d:	e8 1e 1f 00 00       	callq  403530 <__syscall_ret>
	if (fd < 0) return 0;
  401612:	31 f6                	xor    %esi,%esi
  401614:	85 c0                	test   %eax,%eax
	fd = sys_open(filename, flags, 0666);
  401616:	48 89 c3             	mov    %rax,%rbx
	if (fd < 0) return 0;
  401619:	78 35                	js     401650 <fopen+0x9a>
	if (flags & O_CLOEXEC)
  40161b:	41 0f ba e5 13       	bt     $0x13,%r13d
  401620:	73 12                	jae    401634 <fopen+0x7e>
		__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
  401622:	48 63 f8             	movslq %eax,%rdi
  401625:	ba 01 00 00 00       	mov    $0x1,%edx
  40162a:	b8 48 00 00 00       	mov    $0x48,%eax
  40162f:	4c 89 e6             	mov    %r12,%rsi
  401632:	0f 05                	syscall 

	f = __fdopen(fd, mode);
  401634:	48 89 ee             	mov    %rbp,%rsi
  401637:	89 df                	mov    %ebx,%edi
  401639:	e8 a6 34 00 00       	callq  404ae4 <__fdopen>
	if (f) return f;
  40163e:	48 85 c0             	test   %rax,%rax
	f = __fdopen(fd, mode);
  401641:	48 89 c6             	mov    %rax,%rsi
	if (f) return f;
  401644:	75 0a                	jne    401650 <fopen+0x9a>

	__syscall(SYS_close, fd);
  401646:	48 63 fb             	movslq %ebx,%rdi
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
  401649:	b8 03 00 00 00       	mov    $0x3,%eax
  40164e:	0f 05                	syscall 
	return 0;
}
  401650:	5a                   	pop    %rdx
  401651:	48 89 f0             	mov    %rsi,%rax
  401654:	5b                   	pop    %rbx
  401655:	5d                   	pop    %rbp
  401656:	41 5c                	pop    %r12
  401658:	41 5d                	pop    %r13
  40165a:	c3                   	retq   

000000000040165b <__ofl_lock>:
static FILE *ofl_head;
static volatile int ofl_lock[2];

FILE **__ofl_lock()
{
	LOCK(ofl_lock);
  40165b:	48 8d 3d b6 60 20 00 	lea    0x2060b6(%rip),%rdi        # 607718 <ofl_lock>
{
  401662:	48 83 ec 08          	sub    $0x8,%rsp
	LOCK(ofl_lock);
  401666:	e8 16 1d 00 00       	callq  403381 <__lock>
	return &ofl_head;
}
  40166b:	48 8d 05 ae 60 20 00 	lea    0x2060ae(%rip),%rax        # 607720 <ofl_head>
  401672:	5a                   	pop    %rdx
  401673:	c3                   	retq   

0000000000401674 <__ofl_unlock>:

void __ofl_unlock()
{
	UNLOCK(ofl_lock);
  401674:	48 8d 3d 9d 60 20 00 	lea    0x20609d(%rip),%rdi        # 607718 <ofl_lock>
  40167b:	e9 3f 1d 00 00       	jmpq   4033bf <__unlock>

0000000000401680 <printf>:
#include <stdio.h>
#include <stdarg.h>

int printf(const char *restrict fmt, ...)
{
  401680:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
  401687:	84 c0                	test   %al,%al
  401689:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  40168e:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
  401693:	48 89 4c 24 38       	mov    %rcx,0x38(%rsp)
  401698:	4c 89 44 24 40       	mov    %r8,0x40(%rsp)
  40169d:	4c 89 4c 24 48       	mov    %r9,0x48(%rsp)
  4016a2:	74 37                	je     4016db <printf+0x5b>
  4016a4:	0f 29 44 24 50       	movaps %xmm0,0x50(%rsp)
  4016a9:	0f 29 4c 24 60       	movaps %xmm1,0x60(%rsp)
  4016ae:	0f 29 54 24 70       	movaps %xmm2,0x70(%rsp)
  4016b3:	0f 29 9c 24 80 00 00 	movaps %xmm3,0x80(%rsp)
  4016ba:	00 
  4016bb:	0f 29 a4 24 90 00 00 	movaps %xmm4,0x90(%rsp)
  4016c2:	00 
  4016c3:	0f 29 ac 24 a0 00 00 	movaps %xmm5,0xa0(%rsp)
  4016ca:	00 
  4016cb:	0f 29 b4 24 b0 00 00 	movaps %xmm6,0xb0(%rsp)
  4016d2:	00 
  4016d3:	0f 29 bc 24 c0 00 00 	movaps %xmm7,0xc0(%rsp)
  4016da:	00 
	int ret;
	va_list ap;
	va_start(ap, fmt);
  4016db:	48 8d 84 24 e0 00 00 	lea    0xe0(%rsp),%rax
  4016e2:	00 
	ret = vfprintf(stdout, fmt, ap);
  4016e3:	48 89 fe             	mov    %rdi,%rsi
  4016e6:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	va_start(ap, fmt);
  4016eb:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  4016f0:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  4016f5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%rsp)
  4016fc:	00 
  4016fd:	c7 44 24 0c 30 00 00 	movl   $0x30,0xc(%rsp)
  401704:	00 
  401705:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
	ret = vfprintf(stdout, fmt, ap);
  40170a:	48 c7 c0 f8 6f 60 00 	mov    $0x606ff8,%rax
  401711:	48 8b 38             	mov    (%rax),%rdi
  401714:	e8 4f 18 00 00       	callq  402f68 <vfprintf>
	va_end(ap);
	return ret;
}
  401719:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
  401720:	c3                   	retq   

0000000000401721 <puts>:
#include "stdio_impl.h"

int puts(const char *s)
{
	int r;
	FLOCK(stdout);
  401721:	48 c7 c0 f8 6f 60 00 	mov    $0x606ff8,%rax
{
  401728:	41 54                	push   %r12
  40172a:	49 89 fc             	mov    %rdi,%r12
  40172d:	55                   	push   %rbp
  40172e:	53                   	push   %rbx
  40172f:	31 ed                	xor    %ebp,%ebp
	FLOCK(stdout);
  401731:	48 8b 18             	mov    (%rax),%rbx
  401734:	8b 83 8c 00 00 00    	mov    0x8c(%rbx),%eax
  40173a:	85 c0                	test   %eax,%eax
  40173c:	78 0a                	js     401748 <puts+0x27>
  40173e:	48 89 df             	mov    %rbx,%rdi
  401741:	e8 91 35 00 00       	callq  404cd7 <__lockfile>
  401746:	89 c5                	mov    %eax,%ebp
	r = -(fputs(s, stdout) < 0 || putc_unlocked('\n', stdout) < 0);
  401748:	48 89 de             	mov    %rbx,%rsi
  40174b:	4c 89 e7             	mov    %r12,%rdi
  40174e:	e8 e4 38 00 00       	callq  405037 <fputs>
  401753:	85 c0                	test   %eax,%eax
  401755:	ba 01 00 00 00       	mov    $0x1,%edx
  40175a:	78 34                	js     401790 <puts+0x6f>
  40175c:	80 bb 8b 00 00 00 0a 	cmpb   $0xa,0x8b(%rbx)
  401763:	74 19                	je     40177e <puts+0x5d>
  401765:	48 8b 43 28          	mov    0x28(%rbx),%rax
  401769:	48 3b 43 20          	cmp    0x20(%rbx),%rax
  40176d:	73 0f                	jae    40177e <puts+0x5d>
  40176f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  401773:	48 89 53 28          	mov    %rdx,0x28(%rbx)
  401777:	c6 00 0a             	movb   $0xa,(%rax)
  40177a:	31 d2                	xor    %edx,%edx
  40177c:	eb 12                	jmp    401790 <puts+0x6f>
  40177e:	be 0a 00 00 00       	mov    $0xa,%esi
  401783:	48 89 df             	mov    %rbx,%rdi
  401786:	e8 e5 35 00 00       	callq  404d70 <__overflow>
  40178b:	c1 e8 1f             	shr    $0x1f,%eax
  40178e:	89 c2                	mov    %eax,%edx
  401790:	f7 da                	neg    %edx
	FUNLOCK(stdout);
  401792:	85 ed                	test   %ebp,%ebp
	r = -(fputs(s, stdout) < 0 || putc_unlocked('\n', stdout) < 0);
  401794:	41 89 d4             	mov    %edx,%r12d
	FUNLOCK(stdout);
  401797:	74 08                	je     4017a1 <puts+0x80>
  401799:	48 89 df             	mov    %rbx,%rdi
  40179c:	e8 8a 35 00 00       	callq  404d2b <__unlockfile>
	return r;
}
  4017a1:	44 89 e0             	mov    %r12d,%eax
  4017a4:	5b                   	pop    %rbx
  4017a5:	5d                   	pop    %rbp
  4017a6:	41 5c                	pop    %r12
  4017a8:	c3                   	retq   

00000000004017a9 <pop_arg>:
	void *p;
};

static void pop_arg(union arg *arg, int type, va_list *ap)
{
	switch (type) {
  4017a9:	83 ee 09             	sub    $0x9,%esi
  4017ac:	83 fe 11             	cmp    $0x11,%esi
  4017af:	0f 87 61 01 00 00    	ja     401916 <pop_arg+0x16d>
  4017b5:	48 8d 0d 58 48 00 00 	lea    0x4858(%rip),%rcx        # 406014 <_fini+0x651>
  4017bc:	48 63 04 b1          	movslq (%rcx,%rsi,4),%rax
  4017c0:	48 01 c8             	add    %rcx,%rax
  4017c3:	ff e0                	jmpq   *%rax
	       case PTR:	arg->p = va_arg(*ap, void *);
	break; case INT:	arg->i = va_arg(*ap, int);
  4017c5:	8b 0a                	mov    (%rdx),%ecx
  4017c7:	83 f9 2f             	cmp    $0x2f,%ecx
  4017ca:	77 0d                	ja     4017d9 <pop_arg+0x30>
  4017cc:	89 c8                	mov    %ecx,%eax
  4017ce:	83 c1 08             	add    $0x8,%ecx
  4017d1:	48 03 42 10          	add    0x10(%rdx),%rax
  4017d5:	89 0a                	mov    %ecx,(%rdx)
  4017d7:	eb 0c                	jmp    4017e5 <pop_arg+0x3c>
  4017d9:	48 8b 42 08          	mov    0x8(%rdx),%rax
  4017dd:	48 8d 48 08          	lea    0x8(%rax),%rcx
  4017e1:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  4017e5:	48 63 00             	movslq (%rax),%rax
  4017e8:	e9 e3 00 00 00       	jmpq   4018d0 <pop_arg+0x127>
	break; case UINT:	arg->i = va_arg(*ap, unsigned int);
  4017ed:	8b 0a                	mov    (%rdx),%ecx
  4017ef:	83 f9 2f             	cmp    $0x2f,%ecx
  4017f2:	77 0d                	ja     401801 <pop_arg+0x58>
  4017f4:	89 c8                	mov    %ecx,%eax
  4017f6:	83 c1 08             	add    $0x8,%ecx
  4017f9:	48 03 42 10          	add    0x10(%rdx),%rax
  4017fd:	89 0a                	mov    %ecx,(%rdx)
  4017ff:	eb 0c                	jmp    40180d <pop_arg+0x64>
  401801:	48 8b 42 08          	mov    0x8(%rdx),%rax
  401805:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401809:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  40180d:	8b 00                	mov    (%rax),%eax
  40180f:	e9 bc 00 00 00       	jmpq   4018d0 <pop_arg+0x127>
	break; case LONG:	arg->i = va_arg(*ap, long);
	break; case ULONG:	arg->i = va_arg(*ap, unsigned long);
	break; case ULLONG:	arg->i = va_arg(*ap, unsigned long long);
	break; case SHORT:	arg->i = (short)va_arg(*ap, int);
  401814:	8b 0a                	mov    (%rdx),%ecx
  401816:	83 f9 2f             	cmp    $0x2f,%ecx
  401819:	77 0d                	ja     401828 <pop_arg+0x7f>
  40181b:	89 c8                	mov    %ecx,%eax
  40181d:	83 c1 08             	add    $0x8,%ecx
  401820:	48 03 42 10          	add    0x10(%rdx),%rax
  401824:	89 0a                	mov    %ecx,(%rdx)
  401826:	eb 0c                	jmp    401834 <pop_arg+0x8b>
  401828:	48 8b 42 08          	mov    0x8(%rdx),%rax
  40182c:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401830:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401834:	48 0f bf 00          	movswq (%rax),%rax
  401838:	e9 93 00 00 00       	jmpq   4018d0 <pop_arg+0x127>
	break; case USHORT:	arg->i = (unsigned short)va_arg(*ap, int);
  40183d:	8b 0a                	mov    (%rdx),%ecx
  40183f:	83 f9 2f             	cmp    $0x2f,%ecx
  401842:	77 0d                	ja     401851 <pop_arg+0xa8>
  401844:	89 c8                	mov    %ecx,%eax
  401846:	83 c1 08             	add    $0x8,%ecx
  401849:	48 03 42 10          	add    0x10(%rdx),%rax
  40184d:	89 0a                	mov    %ecx,(%rdx)
  40184f:	eb 0c                	jmp    40185d <pop_arg+0xb4>
  401851:	48 8b 42 08          	mov    0x8(%rdx),%rax
  401855:	48 8d 48 08          	lea    0x8(%rax),%rcx
  401859:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  40185d:	0f b7 00             	movzwl (%rax),%eax
  401860:	eb 6e                	jmp    4018d0 <pop_arg+0x127>
	break; case CHAR:	arg->i = (signed char)va_arg(*ap, int);
  401862:	8b 0a                	mov    (%rdx),%ecx
  401864:	83 f9 2f             	cmp    $0x2f,%ecx
  401867:	77 0d                	ja     401876 <pop_arg+0xcd>
  401869:	89 c8                	mov    %ecx,%eax
  40186b:	83 c1 08             	add    $0x8,%ecx
  40186e:	48 03 42 10          	add    0x10(%rdx),%rax
  401872:	89 0a                	mov    %ecx,(%rdx)
  401874:	eb 0c                	jmp    401882 <pop_arg+0xd9>
  401876:	48 8b 42 08          	mov    0x8(%rdx),%rax
  40187a:	48 8d 48 08          	lea    0x8(%rax),%rcx
  40187e:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401882:	48 0f be 00          	movsbq (%rax),%rax
  401886:	eb 48                	jmp    4018d0 <pop_arg+0x127>
	break; case UCHAR:	arg->i = (unsigned char)va_arg(*ap, int);
  401888:	8b 0a                	mov    (%rdx),%ecx
  40188a:	83 f9 2f             	cmp    $0x2f,%ecx
  40188d:	77 0d                	ja     40189c <pop_arg+0xf3>
  40188f:	89 c8                	mov    %ecx,%eax
  401891:	83 c1 08             	add    $0x8,%ecx
  401894:	48 03 42 10          	add    0x10(%rdx),%rax
  401898:	89 0a                	mov    %ecx,(%rdx)
  40189a:	eb 0c                	jmp    4018a8 <pop_arg+0xff>
  40189c:	48 8b 42 08          	mov    0x8(%rdx),%rax
  4018a0:	48 8d 48 08          	lea    0x8(%rax),%rcx
  4018a4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  4018a8:	0f b6 00             	movzbl (%rax),%eax
  4018ab:	eb 23                	jmp    4018d0 <pop_arg+0x127>
	break; case LLONG:	arg->i = va_arg(*ap, long long);
	break; case SIZET:	arg->i = va_arg(*ap, size_t);
	break; case IMAX:	arg->i = va_arg(*ap, intmax_t);
	break; case UMAX:	arg->i = va_arg(*ap, uintmax_t);
	break; case PDIFF:	arg->i = va_arg(*ap, ptrdiff_t);
	break; case UIPTR:	arg->i = (uintptr_t)va_arg(*ap, void *);
  4018ad:	8b 0a                	mov    (%rdx),%ecx
  4018af:	83 f9 2f             	cmp    $0x2f,%ecx
  4018b2:	77 0d                	ja     4018c1 <pop_arg+0x118>
  4018b4:	89 c8                	mov    %ecx,%eax
  4018b6:	83 c1 08             	add    $0x8,%ecx
  4018b9:	48 03 42 10          	add    0x10(%rdx),%rax
  4018bd:	89 0a                	mov    %ecx,(%rdx)
  4018bf:	eb 0c                	jmp    4018cd <pop_arg+0x124>
  4018c1:	48 8b 42 08          	mov    0x8(%rdx),%rax
  4018c5:	48 8d 48 08          	lea    0x8(%rax),%rcx
  4018c9:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  4018cd:	48 8b 00             	mov    (%rax),%rax
  4018d0:	48 89 07             	mov    %rax,(%rdi)
	break; case DBL:	arg->f = va_arg(*ap, double);
  4018d3:	c3                   	retq   
  4018d4:	8b 4a 04             	mov    0x4(%rdx),%ecx
  4018d7:	81 f9 af 00 00 00    	cmp    $0xaf,%ecx
  4018dd:	77 0e                	ja     4018ed <pop_arg+0x144>
  4018df:	89 c8                	mov    %ecx,%eax
  4018e1:	83 c1 10             	add    $0x10,%ecx
  4018e4:	48 03 42 10          	add    0x10(%rdx),%rax
  4018e8:	89 4a 04             	mov    %ecx,0x4(%rdx)
  4018eb:	eb 0c                	jmp    4018f9 <pop_arg+0x150>
  4018ed:	48 8b 42 08          	mov    0x8(%rdx),%rax
  4018f1:	48 8d 48 08          	lea    0x8(%rax),%rcx
  4018f5:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  4018f9:	dd 00                	fldl   (%rax)
  4018fb:	db 3f                	fstpt  (%rdi)
	break; case LDBL:	arg->f = va_arg(*ap, long double);
  4018fd:	c3                   	retq   
  4018fe:	48 8b 42 08          	mov    0x8(%rdx),%rax
  401902:	48 83 c0 0f          	add    $0xf,%rax
  401906:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
  40190a:	48 8d 48 10          	lea    0x10(%rax),%rcx
  40190e:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  401912:	db 28                	fldt   (%rax)
  401914:	db 3f                	fstpt  (%rdi)
  401916:	c3                   	retq   

0000000000401917 <fmt_u>:
	for (; x; x>>=3) *--s = '0' + (x&7);
	return s;
}

static char *fmt_u(uintmax_t x, char *s)
{
  401917:	48 89 f8             	mov    %rdi,%rax
	unsigned long y;
	for (   ; x>ULONG_MAX; x/=10) *--s = '0' + x%10;
	for (y=x;           y; y/=10) *--s = '0' + y%10;
  40191a:	b9 0a 00 00 00       	mov    $0xa,%ecx
  40191f:	48 85 c0             	test   %rax,%rax
  401922:	74 0f                	je     401933 <fmt_u+0x1c>
  401924:	31 d2                	xor    %edx,%edx
  401926:	48 ff ce             	dec    %rsi
  401929:	48 f7 f1             	div    %rcx
  40192c:	83 c2 30             	add    $0x30,%edx
  40192f:	88 16                	mov    %dl,(%rsi)
  401931:	eb ec                	jmp    40191f <fmt_u+0x8>
	return s;
}
  401933:	48 89 f0             	mov    %rsi,%rax
  401936:	c3                   	retq   

0000000000401937 <getint>:
	return MAX(w, pl+l);
}

static int getint(char **s) {
	int i;
	for (i=0; isdigit(**s); (*s)++) {
  401937:	31 c0                	xor    %eax,%eax
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  401939:	41 83 c8 ff          	or     $0xffffffff,%r8d
	for (i=0; isdigit(**s); (*s)++) {
  40193d:	48 8b 0f             	mov    (%rdi),%rcx
  401940:	0f be 11             	movsbl (%rcx),%edx
  401943:	83 ea 30             	sub    $0x30,%edx
  401946:	83 fa 09             	cmp    $0x9,%edx
  401949:	77 26                	ja     401971 <getint+0x3a>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  40194b:	3d cc cc cc 0c       	cmp    $0xccccccc,%eax
  401950:	77 14                	ja     401966 <getint+0x2f>
  401952:	6b f0 f6             	imul   $0xfffffff6,%eax,%esi
  401955:	81 c6 ff ff ff 7f    	add    $0x7fffffff,%esi
  40195b:	39 f2                	cmp    %esi,%edx
  40195d:	7f 07                	jg     401966 <getint+0x2f>
		else i = 10*i + (**s-'0');
  40195f:	6b c0 0a             	imul   $0xa,%eax,%eax
  401962:	01 d0                	add    %edx,%eax
  401964:	eb 03                	jmp    401969 <getint+0x32>
		if (i > INT_MAX/10U || **s-'0' > INT_MAX-10*i) i = -1;
  401966:	44 89 c0             	mov    %r8d,%eax
	for (i=0; isdigit(**s); (*s)++) {
  401969:	48 ff c1             	inc    %rcx
  40196c:	48 89 0f             	mov    %rcx,(%rdi)
  40196f:	eb cc                	jmp    40193d <getint+0x6>
	}
	return i;
}
  401971:	c3                   	retq   

0000000000401972 <out>:
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  401972:	f6 07 20             	testb  $0x20,(%rdi)
{
  401975:	48 89 f0             	mov    %rsi,%rax
  401978:	48 89 d6             	mov    %rdx,%rsi
	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
  40197b:	75 0b                	jne    401988 <out+0x16>
  40197d:	48 89 fa             	mov    %rdi,%rdx
  401980:	48 89 c7             	mov    %rax,%rdi
  401983:	e9 e4 36 00 00       	jmpq   40506c <__fwritex>
  401988:	c3                   	retq   

0000000000401989 <pad>:
	if (fl & (LEFT_ADJ | ZERO_PAD) || l >= w) return;
  401989:	41 81 e0 00 20 01 00 	and    $0x12000,%r8d
  401990:	75 75                	jne    401a07 <pad+0x7e>
  401992:	39 d1                	cmp    %edx,%ecx
  401994:	7d 71                	jge    401a07 <pad+0x7e>
{
  401996:	41 55                	push   %r13
  401998:	41 54                	push   %r12
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  40199a:	40 0f be f6          	movsbl %sil,%esi
{
  40199e:	55                   	push   %rbp
  40199f:	53                   	push   %rbx
	l = w - l;
  4019a0:	89 d3                	mov    %edx,%ebx
  4019a2:	29 cb                	sub    %ecx,%ebx
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4019a4:	ba 00 01 00 00       	mov    $0x100,%edx
  4019a9:	48 89 fd             	mov    %rdi,%rbp
{
  4019ac:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
	memset(pad, c, l>sizeof pad ? sizeof pad : l);
  4019b3:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
  4019b9:	41 89 dc             	mov    %ebx,%r12d
  4019bc:	48 0f 46 d3          	cmovbe %rbx,%rdx
  4019c0:	48 89 e7             	mov    %rsp,%rdi
  4019c3:	49 89 e5             	mov    %rsp,%r13
  4019c6:	e8 f2 18 00 00       	callq  4032bd <memset>
	for (; l >= sizeof pad; l -= sizeof pad)
  4019cb:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  4019d1:	76 18                	jbe    4019eb <pad+0x62>
		out(f, pad, sizeof pad);
  4019d3:	ba 00 01 00 00       	mov    $0x100,%edx
  4019d8:	4c 89 ee             	mov    %r13,%rsi
  4019db:	48 89 ef             	mov    %rbp,%rdi
  4019de:	e8 8f ff ff ff       	callq  401972 <out>
	for (; l >= sizeof pad; l -= sizeof pad)
  4019e3:	81 eb 00 01 00 00    	sub    $0x100,%ebx
  4019e9:	eb e0                	jmp    4019cb <pad+0x42>
	out(f, pad, l);
  4019eb:	41 0f b6 d4          	movzbl %r12b,%edx
  4019ef:	4c 89 ee             	mov    %r13,%rsi
  4019f2:	48 89 ef             	mov    %rbp,%rdi
  4019f5:	e8 78 ff ff ff       	callq  401972 <out>
}
  4019fa:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  401a01:	5b                   	pop    %rbx
  401a02:	5d                   	pop    %rbp
  401a03:	41 5c                	pop    %r12
  401a05:	41 5d                	pop    %r13
  401a07:	c3                   	retq   

0000000000401a08 <fmt_fp>:
{
  401a08:	41 57                	push   %r15
  401a0a:	41 56                	push   %r14
  401a0c:	45 89 c7             	mov    %r8d,%r15d
  401a0f:	41 55                	push   %r13
  401a11:	41 54                	push   %r12
  401a13:	49 89 fc             	mov    %rdi,%r12
  401a16:	55                   	push   %rbp
  401a17:	53                   	push   %rbx
  401a18:	89 d3                	mov    %edx,%ebx
  401a1a:	48 81 ec 58 1d 00 00 	sub    $0x1d58,%rsp
  401a21:	db ac 24 90 1d 00 00 	fldt   0x1d90(%rsp)
  401a28:	89 74 24 58          	mov    %esi,0x58(%rsp)
  401a2c:	89 4c 24 1c          	mov    %ecx,0x1c(%rsp)
	int e2=0, e, i, j, l;
  401a30:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%rsp)
  401a37:	00 
	if (signbit(y)) {
  401a38:	d9 c0                	fld    %st(0)
  401a3a:	db 3c 24             	fstpt  (%rsp)
  401a3d:	db 7c 24 20          	fstpt  0x20(%rsp)
  401a41:	e8 73 2e 00 00       	callq  4048b9 <__signbitl>
  401a46:	85 c0                	test   %eax,%eax
  401a48:	5f                   	pop    %rdi
  401a49:	41 58                	pop    %r8
  401a4b:	db 6c 24 10          	fldt   0x10(%rsp)
  401a4f:	74 11                	je     401a62 <fmt_fp+0x5a>
	pl=1;
  401a51:	41 bd 01 00 00 00    	mov    $0x1,%r13d
	const char *prefix="-0X+0X 0X-0x+0x 0x";
  401a57:	48 8d 05 fe 45 00 00 	lea    0x45fe(%rip),%rax        # 40605c <_fini+0x699>
		y=-y;
  401a5e:	d9 e0                	fchs   
  401a60:	eb 38                	jmp    401a9a <fmt_fp+0x92>
		prefix+=3;
  401a62:	48 8d 05 f6 45 00 00 	lea    0x45f6(%rip),%rax        # 40605f <_fini+0x69c>
	pl=1;
  401a69:	41 bd 01 00 00 00    	mov    $0x1,%r13d
		prefix+=3;
  401a6f:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
	} else if (fl & MARK_POS) {
  401a74:	8b 44 24 0c          	mov    0xc(%rsp),%eax
  401a78:	0f ba e0 0b          	bt     $0xb,%eax
  401a7c:	72 21                	jb     401a9f <fmt_fp+0x97>
	pl=1;
  401a7e:	45 31 ed             	xor    %r13d,%r13d
  401a81:	48 8d 15 d5 45 00 00 	lea    0x45d5(%rip),%rdx        # 40605d <_fini+0x69a>
  401a88:	83 e0 01             	and    $0x1,%eax
  401a8b:	48 8d 05 d0 45 00 00 	lea    0x45d0(%rip),%rax        # 406062 <_fini+0x69f>
  401a92:	41 0f 95 c5          	setne  %r13b
  401a96:	48 0f 44 c2          	cmove  %rdx,%rax
  401a9a:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
	if (!isfinite(y)) {
  401a9f:	48 83 ec 10          	sub    $0x10,%rsp
  401aa3:	d9 c0                	fld    %st(0)
  401aa5:	db 3c 24             	fstpt  (%rsp)
  401aa8:	db 7c 24 20          	fstpt  0x20(%rsp)
  401aac:	e8 bc 2d 00 00       	callq  40486d <__fpclassifyl>
  401ab1:	ff c8                	dec    %eax
  401ab3:	59                   	pop    %rcx
  401ab4:	5e                   	pop    %rsi
  401ab5:	db 6c 24 10          	fldt   0x10(%rsp)
  401ab9:	0f 8f a5 00 00 00    	jg     401b64 <fmt_fp+0x15c>
		char *s = (t&32)?"inf":"INF";
  401abf:	48 8d 05 a9 45 00 00 	lea    0x45a9(%rip),%rax        # 40606f <_fini+0x6ac>
  401ac6:	48 8d 1d a6 45 00 00 	lea    0x45a6(%rip),%rbx        # 406073 <_fini+0x6b0>
  401acd:	41 83 e7 20          	and    $0x20,%r15d
  401ad1:	48 0f 45 d8          	cmovne %rax,%rbx
		if (y!=y) s=(t&32)?"nan":"NAN";
  401ad5:	df e8                	fucomip %st(0),%st
  401ad7:	7b 15                	jnp    401aee <fmt_fp+0xe6>
  401ad9:	48 8d 05 9b 45 00 00 	lea    0x459b(%rip),%rax        # 40607b <_fini+0x6b8>
  401ae0:	48 8d 1d 90 45 00 00 	lea    0x4590(%rip),%rbx        # 406077 <_fini+0x6b4>
  401ae7:	45 85 ff             	test   %r15d,%r15d
  401aea:	48 0f 45 d8          	cmovne %rax,%rbx
		pad(f, ' ', w, 3+pl, fl&~ZERO_PAD);
  401aee:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
  401af3:	45 8d 7d 03          	lea    0x3(%r13),%r15d
  401af7:	8b 54 24 48          	mov    0x48(%rsp),%edx
  401afb:	be 20 00 00 00       	mov    $0x20,%esi
  401b00:	4c 89 e7             	mov    %r12,%rdi
  401b03:	44 89 f9             	mov    %r15d,%ecx
  401b06:	41 81 e0 ff ff fe ff 	and    $0xfffeffff,%r8d
  401b0d:	e8 77 fe ff ff       	callq  401989 <pad>
		out(f, prefix, pl);
  401b12:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  401b17:	49 63 d5             	movslq %r13d,%rdx
  401b1a:	4c 89 e7             	mov    %r12,%rdi
  401b1d:	e8 50 fe ff ff       	callq  401972 <out>
		out(f, s, 3);
  401b22:	ba 03 00 00 00       	mov    $0x3,%edx
  401b27:	48 89 de             	mov    %rbx,%rsi
  401b2a:	4c 89 e7             	mov    %r12,%rdi
  401b2d:	e8 40 fe ff ff       	callq  401972 <out>
		pad(f, ' ', w, 3+pl, fl^LEFT_ADJ);
  401b32:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
  401b37:	8b 54 24 48          	mov    0x48(%rsp),%edx
  401b3b:	44 89 f9             	mov    %r15d,%ecx
  401b3e:	be 20 00 00 00       	mov    $0x20,%esi
  401b43:	4c 89 e7             	mov    %r12,%rdi
  401b46:	41 81 f0 00 20 00 00 	xor    $0x2000,%r8d
  401b4d:	e8 37 fe ff ff       	callq  401989 <pad>
		return MAX(w, 3+pl);
  401b52:	44 3b 7c 24 48       	cmp    0x48(%rsp),%r15d
  401b57:	8b 44 24 48          	mov    0x48(%rsp),%eax
  401b5b:	41 0f 4d c7          	cmovge %r15d,%eax
  401b5f:	e9 0e 0a 00 00       	jmpq   402572 <fmt_fp+0xb6a>
	y = frexpl(y, &e2) * 2;
  401b64:	48 8d 7c 24 68       	lea    0x68(%rsp),%rdi
  401b69:	48 83 ec 10          	sub    $0x10,%rsp
  401b6d:	db 3c 24             	fstpt  (%rsp)
  401b70:	e8 58 2d 00 00       	callq  4048cd <frexpl>
  401b75:	d8 c0                	fadd   %st(0),%st
	if (y) e2--;
  401b77:	58                   	pop    %rax
  401b78:	5a                   	pop    %rdx
  401b79:	d9 ee                	fldz   
  401b7b:	d9 c9                	fxch   %st(1)
  401b7d:	db e9                	fucomi %st(1),%st
  401b7f:	7a 02                	jp     401b83 <fmt_fp+0x17b>
  401b81:	74 04                	je     401b87 <fmt_fp+0x17f>
  401b83:	ff 4c 24 68          	decl   0x68(%rsp)
	if ((t|32)=='a') {
  401b87:	45 89 f9             	mov    %r15d,%r9d
  401b8a:	41 83 c9 20          	or     $0x20,%r9d
  401b8e:	41 83 f9 61          	cmp    $0x61,%r9d
  401b92:	0f 85 65 02 00 00    	jne    401dfd <fmt_fp+0x3f5>
		if (t&32) prefix += 9;
  401b98:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  401b9d:	d9 05 fd 47 00 00    	flds   0x47fd(%rip)        # 4063a0 <states+0x1e0>
  401ba3:	48 83 c0 09          	add    $0x9,%rax
  401ba7:	41 f6 c7 20          	test   $0x20,%r15b
  401bab:	48 0f 44 44 24 40    	cmove  0x40(%rsp),%rax
		pl += 2;
  401bb1:	41 83 c5 02          	add    $0x2,%r13d
		if (p<0 || p>=LDBL_MANT_DIG/4-1) re=0;
  401bb5:	83 fb 0e             	cmp    $0xe,%ebx
		if (t&32) prefix += 9;
  401bb8:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
		if (p<0 || p>=LDBL_MANT_DIG/4-1) re=0;
  401bbd:	77 36                	ja     401bf5 <fmt_fp+0x1ed>
		else re=LDBL_MANT_DIG/4-1-p;
  401bbf:	b8 0f 00 00 00       	mov    $0xf,%eax
  401bc4:	d9 05 c6 47 00 00    	flds   0x47c6(%rip)        # 406390 <states+0x1d0>
  401bca:	29 d8                	sub    %ebx,%eax
			while (re--) round*=16;
  401bcc:	ff c8                	dec    %eax
  401bce:	83 f8 ff             	cmp    $0xffffffff,%eax
  401bd1:	74 04                	je     401bd7 <fmt_fp+0x1cf>
  401bd3:	d8 c9                	fmul   %st(1),%st
  401bd5:	eb f5                	jmp    401bcc <fmt_fp+0x1c4>
			if (*prefix=='-') {
  401bd7:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  401bdc:	80 38 2d             	cmpb   $0x2d,(%rax)
  401bdf:	75 10                	jne    401bf1 <fmt_fp+0x1e9>
  401be1:	d9 ca                	fxch   %st(2)
				y=-y;
  401be3:	d9 e0                	fchs   
				y-=round;
  401be5:	d8 e2                	fsub   %st(2),%st
				y+=round;
  401be7:	de c2                	faddp  %st,%st(2)
  401be9:	d9 c9                	fxch   %st(1)
				y=-y;
  401beb:	d9 e0                	fchs   
  401bed:	d9 c9                	fxch   %st(1)
  401bef:	eb 04                	jmp    401bf5 <fmt_fp+0x1ed>
				y+=round;
  401bf1:	dc c2                	fadd   %st,%st(2)
				y-=round;
  401bf3:	de ea                	fsubrp %st,%st(2)
  401bf5:	db 7c 24 30          	fstpt  0x30(%rsp)
  401bf9:	d9 c9                	fxch   %st(1)
		estr=fmt_u(e2<0 ? -e2 : e2, ebuf);
  401bfb:	8b 44 24 68          	mov    0x68(%rsp),%eax
  401bff:	8b 7c 24 68          	mov    0x68(%rsp),%edi
  401c03:	48 8d 6c 24 6f       	lea    0x6f(%rsp),%rbp
  401c08:	4c 8d 45 0c          	lea    0xc(%rbp),%r8
  401c0c:	c1 f8 1f             	sar    $0x1f,%eax
  401c0f:	31 c7                	xor    %eax,%edi
  401c11:	4c 89 c6             	mov    %r8,%rsi
  401c14:	29 c7                	sub    %eax,%edi
  401c16:	48 63 ff             	movslq %edi,%rdi
  401c19:	db 7c 24 20          	fstpt  0x20(%rsp)
  401c1d:	db 7c 24 10          	fstpt  0x10(%rsp)
  401c21:	e8 f1 fc ff ff       	callq  401917 <fmt_u>
		if (estr==ebuf) *--estr='0';
  401c26:	4c 39 c0             	cmp    %r8,%rax
  401c29:	db 6c 24 10          	fldt   0x10(%rsp)
  401c2d:	db 6c 24 20          	fldt   0x20(%rsp)
  401c31:	db 6c 24 30          	fldt   0x30(%rsp)
  401c35:	75 09                	jne    401c40 <fmt_fp+0x238>
  401c37:	48 8d 45 0b          	lea    0xb(%rbp),%rax
  401c3b:	c6 44 24 7a 30       	movb   $0x30,0x7a(%rsp)
  401c40:	d9 ca                	fxch   %st(2)
		*--estr = (e2<0 ? '-' : '+');
  401c42:	8b 54 24 68          	mov    0x68(%rsp),%edx
		*--estr = t+('p'-'a');
  401c46:	4c 8d 70 fe          	lea    -0x2(%rax),%r14
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  401c4a:	44 8b 5c 24 0c       	mov    0xc(%rsp),%r11d
			*s++=xdigits[x]|(t&32);
  401c4f:	45 88 f8             	mov    %r15b,%r8b
  401c52:	48 8d 35 47 45 00 00 	lea    0x4547(%rip),%rsi        # 4061a0 <xdigits>
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  401c59:	40 b7 01             	mov    $0x1,%dil
			*s++=xdigits[x]|(t&32);
  401c5c:	41 83 e0 20          	and    $0x20,%r8d
		*--estr = (e2<0 ? '-' : '+');
  401c60:	c1 fa 1f             	sar    $0x1f,%edx
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  401c63:	41 83 e3 08          	and    $0x8,%r11d
		*--estr = (e2<0 ? '-' : '+');
  401c67:	83 e2 02             	and    $0x2,%edx
  401c6a:	83 c2 2b             	add    $0x2b,%edx
  401c6d:	88 50 ff             	mov    %dl,-0x1(%rax)
		*--estr = t+('p'-'a');
  401c70:	41 8d 57 0f          	lea    0xf(%r15),%edx
  401c74:	88 50 fe             	mov    %dl,-0x2(%rax)
  401c77:	d9 7c 24 5e          	fnstcw 0x5e(%rsp)
  401c7b:	66 8b 44 24 5e       	mov    0x5e(%rsp),%ax
		s=buf;
  401c80:	48 8d 54 24 7b       	lea    0x7b(%rsp),%rdx
  401c85:	80 cc 0c             	or     $0xc,%ah
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  401c88:	49 89 d2             	mov    %rdx,%r10
  401c8b:	66 89 44 24 5c       	mov    %ax,0x5c(%rsp)
			int x=y;
  401c90:	d9 c0                	fld    %st(0)
  401c92:	d9 6c 24 5c          	fldcw  0x5c(%rsp)
  401c96:	db 5c 24 10          	fistpl 0x10(%rsp)
  401c9a:	d9 6c 24 5e          	fldcw  0x5e(%rsp)
			*s++=xdigits[x]|(t&32);
  401c9e:	44 88 c1             	mov    %r8b,%cl
  401ca1:	48 63 44 24 10       	movslq 0x10(%rsp),%rax
			y=16*(y-x);
  401ca6:	da 64 24 10          	fisubl 0x10(%rsp)
			*s++=xdigits[x]|(t&32);
  401caa:	0a 0c 06             	or     (%rsi,%rax,1),%cl
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  401cad:	4c 39 d2             	cmp    %r10,%rdx
  401cb0:	48 8d 42 01          	lea    0x1(%rdx),%rax
			*s++=xdigits[x]|(t&32);
  401cb4:	88 0a                	mov    %cl,(%rdx)
			y=16*(y-x);
  401cb6:	d8 ca                	fmul   %st(2),%st
			if (s-buf==1 && (y||p>0||(fl&ALT_FORM))) *s++='.';
  401cb8:	75 1d                	jne    401cd7 <fmt_fp+0x2cf>
  401cba:	db e9                	fucomi %st(1),%st
  401cbc:	0f 9a c1             	setp   %cl
  401cbf:	0f 45 cf             	cmovne %edi,%ecx
  401cc2:	84 c9                	test   %cl,%cl
  401cc4:	75 09                	jne    401ccf <fmt_fp+0x2c7>
  401cc6:	85 db                	test   %ebx,%ebx
  401cc8:	7f 05                	jg     401ccf <fmt_fp+0x2c7>
  401cca:	45 85 db             	test   %r11d,%r11d
  401ccd:	74 08                	je     401cd7 <fmt_fp+0x2cf>
  401ccf:	48 8d 42 02          	lea    0x2(%rdx),%rax
  401cd3:	c6 42 01 2e          	movb   $0x2e,0x1(%rdx)
		} while (y);
  401cd7:	db e9                	fucomi %st(1),%st
  401cd9:	7b 05                	jnp    401ce0 <fmt_fp+0x2d8>
  401cdb:	48 89 c2             	mov    %rax,%rdx
  401cde:	eb b0                	jmp    401c90 <fmt_fp+0x288>
  401ce0:	75 f9                	jne    401cdb <fmt_fp+0x2d3>
  401ce2:	dd d8                	fstp   %st(0)
  401ce4:	dd d8                	fstp   %st(0)
  401ce6:	dd d8                	fstp   %st(0)
		if (p > INT_MAX-2-(ebuf-estr)-pl)
  401ce8:	48 83 c5 0c          	add    $0xc,%rbp
  401cec:	ba fd ff ff 7f       	mov    $0x7ffffffd,%edx
  401cf1:	49 63 f5             	movslq %r13d,%rsi
  401cf4:	4c 29 f5             	sub    %r14,%rbp
  401cf7:	48 63 cb             	movslq %ebx,%rcx
  401cfa:	48 29 ea             	sub    %rbp,%rdx
  401cfd:	48 29 f2             	sub    %rsi,%rdx
  401d00:	48 39 d1             	cmp    %rdx,%rcx
  401d03:	7e 08                	jle    401d0d <fmt_fp+0x305>
			return -1;
  401d05:	83 c8 ff             	or     $0xffffffff,%eax
  401d08:	e9 65 08 00 00       	jmpq   402572 <fmt_fp+0xb6a>
		if (p && s-buf-2 < p)
  401d0d:	85 db                	test   %ebx,%ebx
  401d0f:	74 12                	je     401d23 <fmt_fp+0x31b>
  401d11:	48 89 c2             	mov    %rax,%rdx
			l = (p+2) + (ebuf-estr);
  401d14:	8d 5c 2b 02          	lea    0x2(%rbx,%rbp,1),%ebx
		if (p && s-buf-2 < p)
  401d18:	4c 29 d2             	sub    %r10,%rdx
  401d1b:	48 ff ca             	dec    %rdx
  401d1e:	48 39 d1             	cmp    %rdx,%rcx
  401d21:	7d 0a                	jge    401d2d <fmt_fp+0x325>
			l = (s-buf) + (ebuf-estr);
  401d23:	49 89 c3             	mov    %rax,%r11
  401d26:	4d 29 d3             	sub    %r10,%r11
  401d29:	41 8d 1c 2b          	lea    (%r11,%rbp,1),%ebx
		pad(f, ' ', w, pl+l, fl);
  401d2d:	46 8d 3c 2b          	lea    (%rbx,%r13,1),%r15d
  401d31:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
  401d36:	8b 54 24 48          	mov    0x48(%rsp),%edx
  401d3a:	be 20 00 00 00       	mov    $0x20,%esi
  401d3f:	4c 89 e7             	mov    %r12,%rdi
  401d42:	4c 89 54 24 20       	mov    %r10,0x20(%rsp)
  401d47:	44 89 f9             	mov    %r15d,%ecx
  401d4a:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
  401d4f:	29 eb                	sub    %ebp,%ebx
		pad(f, ' ', w, pl+l, fl);
  401d51:	e8 33 fc ff ff       	callq  401989 <pad>
		out(f, prefix, pl);
  401d56:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  401d5b:	49 63 d5             	movslq %r13d,%rdx
  401d5e:	4c 89 e7             	mov    %r12,%rdi
  401d61:	e8 0c fc ff ff       	callq  401972 <out>
		pad(f, '0', w, pl+l, fl^ZERO_PAD);
  401d66:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
  401d6b:	8b 54 24 48          	mov    0x48(%rsp),%edx
  401d6f:	44 89 f9             	mov    %r15d,%ecx
  401d72:	be 30 00 00 00       	mov    $0x30,%esi
  401d77:	4c 89 e7             	mov    %r12,%rdi
  401d7a:	41 81 f0 00 00 01 00 	xor    $0x10000,%r8d
  401d81:	e8 03 fc ff ff       	callq  401989 <pad>
		out(f, buf, s-buf);
  401d86:	4c 8b 54 24 20       	mov    0x20(%rsp),%r10
  401d8b:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  401d90:	48 8d 74 24 7b       	lea    0x7b(%rsp),%rsi
  401d95:	4c 89 e7             	mov    %r12,%rdi
  401d98:	4c 29 d0             	sub    %r10,%rax
  401d9b:	48 89 c2             	mov    %rax,%rdx
  401d9e:	49 89 c5             	mov    %rax,%r13
  401da1:	e8 cc fb ff ff       	callq  401972 <out>
		pad(f, '0', l-(ebuf-estr)-(s-buf), 0, 0);
  401da6:	89 da                	mov    %ebx,%edx
  401da8:	45 31 c0             	xor    %r8d,%r8d
  401dab:	31 c9                	xor    %ecx,%ecx
  401dad:	44 29 ea             	sub    %r13d,%edx
  401db0:	be 30 00 00 00       	mov    $0x30,%esi
  401db5:	4c 89 e7             	mov    %r12,%rdi
  401db8:	e8 cc fb ff ff       	callq  401989 <pad>
		out(f, estr, ebuf-estr);
  401dbd:	48 89 ea             	mov    %rbp,%rdx
  401dc0:	4c 89 f6             	mov    %r14,%rsi
  401dc3:	4c 89 e7             	mov    %r12,%rdi
  401dc6:	e8 a7 fb ff ff       	callq  401972 <out>
		pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  401dcb:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
  401dd0:	8b 54 24 48          	mov    0x48(%rsp),%edx
  401dd4:	44 89 f9             	mov    %r15d,%ecx
  401dd7:	be 20 00 00 00       	mov    $0x20,%esi
  401ddc:	4c 89 e7             	mov    %r12,%rdi
  401ddf:	41 81 f0 00 20 00 00 	xor    $0x2000,%r8d
  401de6:	e8 9e fb ff ff       	callq  401989 <pad>
		return MAX(w, pl+l);
  401deb:	44 39 7c 24 48       	cmp    %r15d,0x48(%rsp)
  401df0:	8b 44 24 48          	mov    0x48(%rsp),%eax
  401df4:	41 0f 4c c7          	cmovl  %r15d,%eax
  401df8:	e9 75 07 00 00       	jmpq   402572 <fmt_fp+0xb6a>
	if (p<0) p=6;
  401dfd:	85 db                	test   %ebx,%ebx
  401dff:	b8 06 00 00 00       	mov    $0x6,%eax
  401e04:	0f 48 d8             	cmovs  %eax,%ebx
	if (y) y *= 0x1p28, e2-=28;
  401e07:	db e9                	fucomi %st(1),%st
  401e09:	7a 02                	jp     401e0d <fmt_fp+0x405>
  401e0b:	74 0b                	je     401e18 <fmt_fp+0x410>
  401e0d:	d8 0d 91 45 00 00    	fmuls  0x4591(%rip)        # 4063a4 <states+0x1e4>
  401e13:	83 6c 24 68 1c       	subl   $0x1c,0x68(%rsp)
	if (e2<0) a=r=z=big;
  401e18:	8b 74 24 68          	mov    0x68(%rsp),%esi
  401e1c:	48 8d 84 24 94 00 00 	lea    0x94(%rsp),%rax
  401e23:	00 
	else a=r=z=big+sizeof(big)/sizeof(*big) - LDBL_MANT_DIG - 1;
  401e24:	48 8d 94 24 3c 1c 00 	lea    0x1c3c(%rsp),%rdx
  401e2b:	00 
  401e2c:	d9 7c 24 5e          	fnstcw 0x5e(%rsp)
		y = 1000000000*(y-*z++);
  401e30:	d9 05 72 45 00 00    	flds   0x4572(%rip)        # 4063a8 <states+0x1e8>
  401e36:	d9 c9                	fxch   %st(1)
	else a=r=z=big+sizeof(big)/sizeof(*big) - LDBL_MANT_DIG - 1;
  401e38:	85 f6                	test   %esi,%esi
  401e3a:	48 0f 49 c2          	cmovns %rdx,%rax
  401e3e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  401e43:	49 89 c6             	mov    %rax,%r14
  401e46:	66 8b 44 24 5e       	mov    0x5e(%rsp),%ax
  401e4b:	80 cc 0c             	or     $0xc,%ah
  401e4e:	66 89 44 24 5c       	mov    %ax,0x5c(%rsp)
		*z = y;
  401e53:	d9 c0                	fld    %st(0)
  401e55:	d9 6c 24 5c          	fldcw  0x5c(%rsp)
  401e59:	df 7c 24 50          	fistpll 0x50(%rsp)
  401e5d:	d9 6c 24 5e          	fldcw  0x5e(%rsp)
		y = 1000000000*(y-*z++);
  401e61:	49 83 c6 04          	add    $0x4,%r14
		*z = y;
  401e65:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  401e6a:	41 89 46 fc          	mov    %eax,-0x4(%r14)
		y = 1000000000*(y-*z++);
  401e6e:	89 c0                	mov    %eax,%eax
  401e70:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  401e75:	df 6c 24 20          	fildll 0x20(%rsp)
  401e79:	de e9                	fsubrp %st,%st(1)
  401e7b:	d8 c9                	fmul   %st(1),%st
	} while (y);
  401e7d:	db ea                	fucomi %st(2),%st
  401e7f:	7a d2                	jp     401e53 <fmt_fp+0x44b>
  401e81:	75 d0                	jne    401e53 <fmt_fp+0x44b>
  401e83:	dd d8                	fstp   %st(0)
  401e85:	dd d8                	fstp   %st(0)
  401e87:	dd d8                	fstp   %st(0)
  401e89:	48 8b 6c 24 10       	mov    0x10(%rsp),%rbp
  401e8e:	31 c0                	xor    %eax,%eax
		int sh=MIN(29,e2);
  401e90:	41 b8 1d 00 00 00    	mov    $0x1d,%r8d
			*d = x % 1000000000;
  401e96:	41 bb 00 ca 9a 3b    	mov    $0x3b9aca00,%r11d
	while (e2>0) {
  401e9c:	85 f6                	test   %esi,%esi
  401e9e:	7e 4f                	jle    401eef <fmt_fp+0x4e7>
		int sh=MIN(29,e2);
  401ea0:	83 fe 1d             	cmp    $0x1d,%esi
  401ea3:	44 89 c1             	mov    %r8d,%ecx
		for (d=z-1; d>=a; d--) {
  401ea6:	49 8d 7e fc          	lea    -0x4(%r14),%rdi
		int sh=MIN(29,e2);
  401eaa:	0f 4e ce             	cmovle %esi,%ecx
		uint32_t carry=0;
  401ead:	31 c0                	xor    %eax,%eax
		for (d=z-1; d>=a; d--) {
  401eaf:	48 39 fd             	cmp    %rdi,%rbp
  401eb2:	77 18                	ja     401ecc <fmt_fp+0x4c4>
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  401eb4:	8b 17                	mov    (%rdi),%edx
  401eb6:	89 c0                	mov    %eax,%eax
		for (d=z-1; d>=a; d--) {
  401eb8:	48 83 ef 04          	sub    $0x4,%rdi
			uint64_t x = ((uint64_t)*d<<sh)+carry;
  401ebc:	48 d3 e2             	shl    %cl,%rdx
  401ebf:	48 01 d0             	add    %rdx,%rax
			*d = x % 1000000000;
  401ec2:	31 d2                	xor    %edx,%edx
  401ec4:	49 f7 f3             	div    %r11
  401ec7:	89 57 04             	mov    %edx,0x4(%rdi)
  401eca:	eb e3                	jmp    401eaf <fmt_fp+0x4a7>
		if (carry) *--a = carry;
  401ecc:	85 c0                	test   %eax,%eax
  401ece:	74 14                	je     401ee4 <fmt_fp+0x4dc>
  401ed0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  401ed3:	48 83 ed 04          	sub    $0x4,%rbp
  401ed7:	eb 0b                	jmp    401ee4 <fmt_fp+0x4dc>
		while (z>a && !z[-1]) z--;
  401ed9:	41 83 7e fc 00       	cmpl   $0x0,-0x4(%r14)
  401ede:	75 09                	jne    401ee9 <fmt_fp+0x4e1>
  401ee0:	49 83 ee 04          	sub    $0x4,%r14
  401ee4:	49 39 ee             	cmp    %rbp,%r14
  401ee7:	77 f0                	ja     401ed9 <fmt_fp+0x4d1>
		e2-=sh;
  401ee9:	29 ce                	sub    %ecx,%esi
  401eeb:	b0 01                	mov    $0x1,%al
  401eed:	eb ad                	jmp    401e9c <fmt_fp+0x494>
  401eef:	84 c0                	test   %al,%al
  401ef1:	74 04                	je     401ef7 <fmt_fp+0x4ef>
  401ef3:	89 74 24 68          	mov    %esi,0x68(%rsp)
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  401ef7:	8d 43 1d             	lea    0x1d(%rbx),%eax
  401efa:	b9 09 00 00 00       	mov    $0x9,%ecx
  401eff:	31 d2                	xor    %edx,%edx
  401f01:	f7 f1                	div    %ecx
		if (z-b > need) z = b+need;
  401f03:	31 d2                	xor    %edx,%edx
  401f05:	44 8d 58 01          	lea    0x1(%rax),%r11d
  401f09:	8b 44 24 68          	mov    0x68(%rsp),%eax
  401f0d:	4e 8d 14 9d 00 00 00 	lea    0x0(,%r11,4),%r10
  401f14:	00 
	while (e2<0) {
  401f15:	85 c0                	test   %eax,%eax
  401f17:	0f 89 95 00 00 00    	jns    401fb2 <fmt_fp+0x5aa>
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  401f1d:	89 c1                	mov    %eax,%ecx
  401f1f:	bf 09 00 00 00       	mov    $0x9,%edi
			uint32_t rm = *d & (1<<sh)-1;
  401f24:	41 b8 01 00 00 00    	mov    $0x1,%r8d
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  401f2a:	f7 d9                	neg    %ecx
  401f2c:	83 f8 f7             	cmp    $0xfffffff7,%eax
		for (d=a; d<z; d++) {
  401f2f:	48 89 ea             	mov    %rbp,%rdx
		int sh=MIN(9,-e2), need=1+(p+LDBL_MANT_DIG/3U+8)/9;
  401f32:	0f 4c cf             	cmovl  %edi,%ecx
			uint32_t rm = *d & (1<<sh)-1;
  401f35:	41 d3 e0             	shl    %cl,%r8d
  401f38:	41 8d 70 ff          	lea    -0x1(%r8),%esi
  401f3c:	89 74 24 4c          	mov    %esi,0x4c(%rsp)
			carry = (1000000000>>sh) * rm;
  401f40:	be 00 ca 9a 3b       	mov    $0x3b9aca00,%esi
  401f45:	d3 fe                	sar    %cl,%esi
  401f47:	89 74 24 20          	mov    %esi,0x20(%rsp)
		uint32_t carry=0, *b;
  401f4b:	31 f6                	xor    %esi,%esi
		for (d=a; d<z; d++) {
  401f4d:	4c 39 f2             	cmp    %r14,%rdx
  401f50:	73 1f                	jae    401f71 <fmt_fp+0x569>
			uint32_t rm = *d & (1<<sh)-1;
  401f52:	8b 3a                	mov    (%rdx),%edi
		for (d=a; d<z; d++) {
  401f54:	48 83 c2 04          	add    $0x4,%rdx
			*d = (*d>>sh) + carry;
  401f58:	41 89 f8             	mov    %edi,%r8d
  401f5b:	41 d3 e8             	shr    %cl,%r8d
  401f5e:	44 01 c6             	add    %r8d,%esi
  401f61:	89 72 fc             	mov    %esi,-0x4(%rdx)
			uint32_t rm = *d & (1<<sh)-1;
  401f64:	8b 74 24 4c          	mov    0x4c(%rsp),%esi
  401f68:	21 fe                	and    %edi,%esi
			carry = (1000000000>>sh) * rm;
  401f6a:	0f af 74 24 20       	imul   0x20(%rsp),%esi
  401f6f:	eb dc                	jmp    401f4d <fmt_fp+0x545>
		if (!*a) a++;
  401f71:	83 7d 00 00          	cmpl   $0x0,0x0(%rbp)
  401f75:	48 8d 55 04          	lea    0x4(%rbp),%rdx
  401f79:	48 0f 44 ea          	cmove  %rdx,%rbp
		if (carry) *z++ = carry;
  401f7d:	85 f6                	test   %esi,%esi
  401f7f:	74 07                	je     401f88 <fmt_fp+0x580>
  401f81:	41 89 36             	mov    %esi,(%r14)
  401f84:	49 83 c6 04          	add    $0x4,%r14
		b = (t|32)=='f' ? r : a;
  401f88:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  401f8d:	41 83 f9 66          	cmp    $0x66,%r9d
		if (z-b > need) z = b+need;
  401f91:	4c 89 f6             	mov    %r14,%rsi
		b = (t|32)=='f' ? r : a;
  401f94:	48 0f 45 d5          	cmovne %rbp,%rdx
		if (z-b > need) z = b+need;
  401f98:	48 29 d6             	sub    %rdx,%rsi
  401f9b:	4c 01 d2             	add    %r10,%rdx
  401f9e:	48 c1 fe 02          	sar    $0x2,%rsi
  401fa2:	4c 39 de             	cmp    %r11,%rsi
  401fa5:	4c 0f 4f f2          	cmovg  %rdx,%r14
		e2+=sh;
  401fa9:	01 c8                	add    %ecx,%eax
  401fab:	b2 01                	mov    $0x1,%dl
  401fad:	e9 63 ff ff ff       	jmpq   401f15 <fmt_fp+0x50d>
  401fb2:	84 d2                	test   %dl,%dl
  401fb4:	74 04                	je     401fba <fmt_fp+0x5b2>
  401fb6:	89 44 24 68          	mov    %eax,0x68(%rsp)
	else e=0;
  401fba:	45 31 c0             	xor    %r8d,%r8d
	if (a<z) for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  401fbd:	4c 39 f5             	cmp    %r14,%rbp
  401fc0:	73 24                	jae    401fe6 <fmt_fp+0x5de>
  401fc2:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
  401fc7:	8b 55 00             	mov    0x0(%rbp),%edx
  401fca:	b8 0a 00 00 00       	mov    $0xa,%eax
  401fcf:	49 29 e8             	sub    %rbp,%r8
  401fd2:	49 c1 f8 02          	sar    $0x2,%r8
  401fd6:	47 8d 04 c0          	lea    (%r8,%r8,8),%r8d
  401fda:	39 c2                	cmp    %eax,%edx
  401fdc:	72 08                	jb     401fe6 <fmt_fp+0x5de>
  401fde:	6b c0 0a             	imul   $0xa,%eax,%eax
  401fe1:	41 ff c0             	inc    %r8d
  401fe4:	eb f4                	jmp    401fda <fmt_fp+0x5d2>
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  401fe6:	31 c0                	xor    %eax,%eax
  401fe8:	41 83 f9 66          	cmp    $0x66,%r9d
  401fec:	89 df                	mov    %ebx,%edi
  401fee:	0f 95 c0             	setne  %al
  401ff1:	41 0f af c0          	imul   %r8d,%eax
  401ff5:	29 c7                	sub    %eax,%edi
  401ff7:	41 83 f9 67          	cmp    $0x67,%r9d
  401ffb:	0f 94 c2             	sete   %dl
  401ffe:	31 c9                	xor    %ecx,%ecx
  402000:	85 db                	test   %ebx,%ebx
  402002:	0f 95 c1             	setne  %cl
  402005:	89 f8                	mov    %edi,%eax
  402007:	21 d1                	and    %edx,%ecx
	if (j < 9*(z-r-1)) {
  402009:	4c 89 f2             	mov    %r14,%rdx
  40200c:	48 2b 54 24 10       	sub    0x10(%rsp),%rdx
	j = p - ((t|32)!='f')*e - ((t|32)=='g' && p);
  402011:	29 c8                	sub    %ecx,%eax
	if (j < 9*(z-r-1)) {
  402013:	48 63 c8             	movslq %eax,%rcx
  402016:	48 c1 fa 02          	sar    $0x2,%rdx
  40201a:	48 ff ca             	dec    %rdx
  40201d:	48 8d 14 d2          	lea    (%rdx,%rdx,8),%rdx
  402021:	48 39 d1             	cmp    %rdx,%rcx
  402024:	0f 8d 30 01 00 00    	jge    40215a <fmt_fp+0x752>
		d = r + 1 + ((j+9*LDBL_MAX_EXP)/9 - LDBL_MAX_EXP);
  40202a:	05 00 40 02 00       	add    $0x24000,%eax
  40202f:	b9 09 00 00 00       	mov    $0x9,%ecx
  402034:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  402039:	99                   	cltd   
  40203a:	f7 f9                	idiv   %ecx
  40203c:	48 98                	cltq   
  40203e:	48 8d 8c 86 04 00 ff 	lea    -0xfffc(%rsi,%rax,4),%rcx
  402045:	ff 
		for (i=10, j++; j<9; i*=10, j++);
  402046:	8d 42 01             	lea    0x1(%rdx),%eax
  402049:	be 0a 00 00 00       	mov    $0xa,%esi
  40204e:	83 f8 09             	cmp    $0x9,%eax
  402051:	74 07                	je     40205a <fmt_fp+0x652>
  402053:	6b f6 0a             	imul   $0xa,%esi,%esi
  402056:	ff c0                	inc    %eax
  402058:	eb f4                	jmp    40204e <fmt_fp+0x646>
		x = *d % i;
  40205a:	8b 39                	mov    (%rcx),%edi
  40205c:	31 d2                	xor    %edx,%edx
  40205e:	89 f8                	mov    %edi,%eax
  402060:	f7 f6                	div    %esi
		if (x || d+1!=z) {
  402062:	85 d2                	test   %edx,%edx
		x = *d % i;
  402064:	41 89 d3             	mov    %edx,%r11d
		if (x || d+1!=z) {
  402067:	75 0d                	jne    402076 <fmt_fp+0x66e>
  402069:	48 8d 41 04          	lea    0x4(%rcx),%rax
  40206d:	49 39 c6             	cmp    %rax,%r14
  402070:	0f 84 cc 00 00 00    	je     402142 <fmt_fp+0x73a>
			if ((*d/i & 1) || (i==1000000000 && d>a && (d[-1]&1)))
  402076:	31 d2                	xor    %edx,%edx
  402078:	89 f8                	mov    %edi,%eax
  40207a:	f7 f6                	div    %esi
  40207c:	a8 01                	test   $0x1,%al
  40207e:	75 13                	jne    402093 <fmt_fp+0x68b>
  402080:	81 fe 00 ca 9a 3b    	cmp    $0x3b9aca00,%esi
  402086:	75 13                	jne    40209b <fmt_fp+0x693>
  402088:	48 39 cd             	cmp    %rcx,%rbp
  40208b:	73 0e                	jae    40209b <fmt_fp+0x693>
  40208d:	f6 41 fc 01          	testb  $0x1,-0x4(%rcx)
  402091:	74 08                	je     40209b <fmt_fp+0x693>
				round += 2;
  402093:	db 2d 17 43 00 00    	fldt   0x4317(%rip)        # 4063b0 <states+0x1f0>
  402099:	eb 06                	jmp    4020a1 <fmt_fp+0x699>
			long double round = 2/LDBL_EPSILON;
  40209b:	d9 05 f3 42 00 00    	flds   0x42f3(%rip)        # 406394 <states+0x1d4>
			if (x<i/2) small=0x0.8p0;
  4020a1:	89 f0                	mov    %esi,%eax
  4020a3:	d1 f8                	sar    %eax
  4020a5:	41 39 c3             	cmp    %eax,%r11d
  4020a8:	72 0f                	jb     4020b9 <fmt_fp+0x6b1>
			else if (x==i/2 && d+1==z) small=0x1.0p0;
  4020aa:	75 17                	jne    4020c3 <fmt_fp+0x6bb>
  4020ac:	48 8d 41 04          	lea    0x4(%rcx),%rax
  4020b0:	d9 e8                	fld1   
  4020b2:	49 39 c6             	cmp    %rax,%r14
  4020b5:	75 0a                	jne    4020c1 <fmt_fp+0x6b9>
  4020b7:	eb 10                	jmp    4020c9 <fmt_fp+0x6c1>
			if (x<i/2) small=0x0.8p0;
  4020b9:	d9 05 d9 42 00 00    	flds   0x42d9(%rip)        # 406398 <states+0x1d8>
  4020bf:	eb 08                	jmp    4020c9 <fmt_fp+0x6c1>
  4020c1:	dd d8                	fstp   %st(0)
			else small=0x1.8p0;
  4020c3:	d9 05 d3 42 00 00    	flds   0x42d3(%rip)        # 40639c <states+0x1dc>
			if (pl && *prefix=='-') round*=-1, small*=-1;
  4020c9:	45 85 ed             	test   %r13d,%r13d
  4020cc:	74 12                	je     4020e0 <fmt_fp+0x6d8>
  4020ce:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  4020d3:	80 38 2d             	cmpb   $0x2d,(%rax)
  4020d6:	75 08                	jne    4020e0 <fmt_fp+0x6d8>
  4020d8:	d9 c9                	fxch   %st(1)
  4020da:	d9 e0                	fchs   
  4020dc:	d9 c9                	fxch   %st(1)
  4020de:	d9 e0                	fchs   
			if (round+small != round) {
  4020e0:	d8 c1                	fadd   %st(1),%st
  4020e2:	d9 c9                	fxch   %st(1)
			*d -= x;
  4020e4:	44 29 df             	sub    %r11d,%edi
			if (round+small != round) {
  4020e7:	df e9                	fucomip %st(1),%st
  4020e9:	dd d8                	fstp   %st(0)
  4020eb:	7a 06                	jp     4020f3 <fmt_fp+0x6eb>
  4020ed:	75 04                	jne    4020f3 <fmt_fp+0x6eb>
			*d -= x;
  4020ef:	89 39                	mov    %edi,(%rcx)
  4020f1:	eb 4f                	jmp    402142 <fmt_fp+0x73a>
				*d = *d + i;
  4020f3:	01 fe                	add    %edi,%esi
  4020f5:	89 31                	mov    %esi,(%rcx)
				while (*d > 999999999) {
  4020f7:	81 39 ff c9 9a 3b    	cmpl   $0x3b9ac9ff,(%rcx)
  4020fd:	76 1f                	jbe    40211e <fmt_fp+0x716>
					*d--=0;
  4020ff:	48 83 e9 04          	sub    $0x4,%rcx
  402103:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%rcx)
					if (d<a) *--a=0;
  40210a:	48 39 cd             	cmp    %rcx,%rbp
  40210d:	76 0b                	jbe    40211a <fmt_fp+0x712>
  40210f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  402116:	48 83 ed 04          	sub    $0x4,%rbp
					(*d)++;
  40211a:	ff 01                	incl   (%rcx)
  40211c:	eb d9                	jmp    4020f7 <fmt_fp+0x6ef>
				for (i=10, e=9*(r-a); *a>=i; i*=10, e++);
  40211e:	4c 8b 44 24 10       	mov    0x10(%rsp),%r8
  402123:	8b 55 00             	mov    0x0(%rbp),%edx
  402126:	b8 0a 00 00 00       	mov    $0xa,%eax
  40212b:	49 29 e8             	sub    %rbp,%r8
  40212e:	49 c1 f8 02          	sar    $0x2,%r8
  402132:	47 8d 04 c0          	lea    (%r8,%r8,8),%r8d
  402136:	39 c2                	cmp    %eax,%edx
  402138:	72 08                	jb     402142 <fmt_fp+0x73a>
  40213a:	6b c0 0a             	imul   $0xa,%eax,%eax
  40213d:	41 ff c0             	inc    %r8d
  402140:	eb f4                	jmp    402136 <fmt_fp+0x72e>
		if (z>d+1) z=d+1;
  402142:	48 83 c1 04          	add    $0x4,%rcx
  402146:	49 39 ce             	cmp    %rcx,%r14
  402149:	4c 0f 47 f1          	cmova  %rcx,%r14
  40214d:	eb 0b                	jmp    40215a <fmt_fp+0x752>
	for (; z>a && !z[-1]; z--);
  40214f:	41 83 7e fc 00       	cmpl   $0x0,-0x4(%r14)
  402154:	75 09                	jne    40215f <fmt_fp+0x757>
  402156:	49 83 ee 04          	sub    $0x4,%r14
  40215a:	49 39 ee             	cmp    %rbp,%r14
  40215d:	77 f0                	ja     40214f <fmt_fp+0x747>
	if ((t|32)=='g') {
  40215f:	41 83 f9 67          	cmp    $0x67,%r9d
  402163:	0f 85 c3 00 00 00    	jne    40222c <fmt_fp+0x824>
		if (!p) p++;
  402169:	85 db                	test   %ebx,%ebx
  40216b:	b8 01 00 00 00       	mov    $0x1,%eax
  402170:	0f 44 d8             	cmove  %eax,%ebx
		if (p>e && e>=-4) {
  402173:	44 39 c3             	cmp    %r8d,%ebx
  402176:	7e 11                	jle    402189 <fmt_fp+0x781>
  402178:	41 83 f8 fc          	cmp    $0xfffffffc,%r8d
  40217c:	7c 0b                	jl     402189 <fmt_fp+0x781>
			p-=e+1;
  40217e:	41 8d 40 01          	lea    0x1(%r8),%eax
			t--;
  402182:	41 ff cf             	dec    %r15d
			p-=e+1;
  402185:	29 c3                	sub    %eax,%ebx
  402187:	eb 06                	jmp    40218f <fmt_fp+0x787>
			t-=2;
  402189:	41 83 ef 02          	sub    $0x2,%r15d
			p--;
  40218d:	ff cb                	dec    %ebx
		if (!(fl&ALT_FORM)) {
  40218f:	f6 44 24 0c 08       	testb  $0x8,0xc(%rsp)
  402194:	0f 85 92 00 00 00    	jne    40222c <fmt_fp+0x824>
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  40219a:	49 39 ee             	cmp    %rbp,%r14
			else j=9;
  40219d:	b9 09 00 00 00       	mov    $0x9,%ecx
			if (z>a && z[-1]) for (i=10, j=0; z[-1]%i==0; i*=10, j++);
  4021a2:	76 20                	jbe    4021c4 <fmt_fp+0x7bc>
  4021a4:	41 8b 7e fc          	mov    -0x4(%r14),%edi
  4021a8:	85 ff                	test   %edi,%edi
  4021aa:	74 18                	je     4021c4 <fmt_fp+0x7bc>
  4021ac:	31 c9                	xor    %ecx,%ecx
  4021ae:	be 0a 00 00 00       	mov    $0xa,%esi
  4021b3:	31 d2                	xor    %edx,%edx
  4021b5:	89 f8                	mov    %edi,%eax
  4021b7:	f7 f6                	div    %esi
  4021b9:	85 d2                	test   %edx,%edx
  4021bb:	75 07                	jne    4021c4 <fmt_fp+0x7bc>
  4021bd:	6b f6 0a             	imul   $0xa,%esi,%esi
  4021c0:	ff c1                	inc    %ecx
  4021c2:	eb ef                	jmp    4021b3 <fmt_fp+0x7ab>
			if ((t|32)=='f')
  4021c4:	44 89 f8             	mov    %r15d,%eax
  4021c7:	48 63 d3             	movslq %ebx,%rdx
  4021ca:	48 63 c9             	movslq %ecx,%rcx
  4021cd:	83 c8 20             	or     $0x20,%eax
  4021d0:	83 f8 66             	cmp    $0x66,%eax
  4021d3:	75 28                	jne    4021fd <fmt_fp+0x7f5>
				p = MIN(p,MAX(0,9*(z-r-1)-j));
  4021d5:	4c 89 f3             	mov    %r14,%rbx
  4021d8:	48 2b 5c 24 10       	sub    0x10(%rsp),%rbx
  4021dd:	b8 00 00 00 00       	mov    $0x0,%eax
  4021e2:	48 c1 fb 02          	sar    $0x2,%rbx
  4021e6:	48 ff cb             	dec    %rbx
  4021e9:	48 8d 1c db          	lea    (%rbx,%rbx,8),%rbx
  4021ed:	48 29 cb             	sub    %rcx,%rbx
  4021f0:	48 0f 48 d8          	cmovs  %rax,%rbx
  4021f4:	48 39 d3             	cmp    %rdx,%rbx
  4021f7:	48 0f 4f da          	cmovg  %rdx,%rbx
  4021fb:	eb 2f                	jmp    40222c <fmt_fp+0x824>
				p = MIN(p,MAX(0,9*(z-r-1)+e-j));
  4021fd:	4c 89 f0             	mov    %r14,%rax
  402200:	48 2b 44 24 10       	sub    0x10(%rsp),%rax
  402205:	49 63 d8             	movslq %r8d,%rbx
  402208:	48 c1 f8 02          	sar    $0x2,%rax
  40220c:	48 ff c8             	dec    %rax
  40220f:	48 8d 04 c0          	lea    (%rax,%rax,8),%rax
  402213:	48 01 d8             	add    %rbx,%rax
  402216:	48 29 c8             	sub    %rcx,%rax
  402219:	b9 00 00 00 00       	mov    $0x0,%ecx
  40221e:	48 0f 48 c1          	cmovs  %rcx,%rax
  402222:	48 39 d0             	cmp    %rdx,%rax
  402225:	48 0f 4e d0          	cmovle %rax,%rdx
  402229:	48 89 d3             	mov    %rdx,%rbx
	if (p > INT_MAX-1-(p || (fl&ALT_FORM)))
  40222c:	85 db                	test   %ebx,%ebx
  40222e:	b0 01                	mov    $0x1,%al
  402230:	75 0a                	jne    40223c <fmt_fp+0x834>
  402232:	8b 44 24 0c          	mov    0xc(%rsp),%eax
  402236:	c1 e8 03             	shr    $0x3,%eax
  402239:	83 e0 01             	and    $0x1,%eax
  40223c:	0f b6 c0             	movzbl %al,%eax
  40223f:	ba fe ff ff 7f       	mov    $0x7ffffffe,%edx
  402244:	29 c2                	sub    %eax,%edx
  402246:	39 d3                	cmp    %edx,%ebx
  402248:	0f 8f b7 fa ff ff    	jg     401d05 <fmt_fp+0x2fd>
	l = 1 + p + (p || (fl&ALT_FORM));
  40224e:	44 8d 4c 18 01       	lea    0x1(%rax,%rbx,1),%r9d
	if ((t|32)=='f') {
  402253:	44 89 f8             	mov    %r15d,%eax
  402256:	83 c8 20             	or     $0x20,%eax
  402259:	83 f8 66             	cmp    $0x66,%eax
  40225c:	89 44 24 4c          	mov    %eax,0x4c(%rsp)
  402260:	75 1e                	jne    402280 <fmt_fp+0x878>
		if (e > INT_MAX-l) return -1;
  402262:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  402267:	44 29 c8             	sub    %r9d,%eax
  40226a:	41 39 c0             	cmp    %eax,%r8d
  40226d:	0f 8f 92 fa ff ff    	jg     401d05 <fmt_fp+0x2fd>
		if (e>0) l+=e;
  402273:	43 8d 04 01          	lea    (%r9,%r8,1),%eax
  402277:	45 85 c0             	test   %r8d,%r8d
  40227a:	44 0f 4f c8          	cmovg  %eax,%r9d
  40227e:	eb 66                	jmp    4022e6 <fmt_fp+0x8de>
		estr=fmt_u(e<0 ? -e : e, ebuf);
  402280:	44 89 c0             	mov    %r8d,%eax
  402283:	4c 8d 5c 24 7b       	lea    0x7b(%rsp),%r11
  402288:	c1 f8 1f             	sar    $0x1f,%eax
  40228b:	89 c7                	mov    %eax,%edi
  40228d:	4c 89 de             	mov    %r11,%rsi
  402290:	44 31 c7             	xor    %r8d,%edi
  402293:	29 c7                	sub    %eax,%edi
  402295:	48 63 ff             	movslq %edi,%rdi
  402298:	e8 7a f6 ff ff       	callq  401917 <fmt_u>
		while(ebuf-estr<2) *--estr='0';
  40229d:	4c 89 da             	mov    %r11,%rdx
  4022a0:	48 29 c2             	sub    %rax,%rdx
  4022a3:	48 ff ca             	dec    %rdx
  4022a6:	7f 08                	jg     4022b0 <fmt_fp+0x8a8>
  4022a8:	48 ff c8             	dec    %rax
  4022ab:	c6 00 30             	movb   $0x30,(%rax)
  4022ae:	eb ed                	jmp    40229d <fmt_fp+0x895>
		*--estr = (e<0 ? '-' : '+');
  4022b0:	41 c1 f8 1f          	sar    $0x1f,%r8d
		*--estr = t;
  4022b4:	48 8d 78 fe          	lea    -0x2(%rax),%rdi
  4022b8:	44 88 78 fe          	mov    %r15b,-0x2(%rax)
		*--estr = (e<0 ? '-' : '+');
  4022bc:	41 83 e0 02          	and    $0x2,%r8d
  4022c0:	41 83 c0 2b          	add    $0x2b,%r8d
		if (ebuf-estr > INT_MAX-l) return -1;
  4022c4:	49 29 fb             	sub    %rdi,%r11
		*--estr = t;
  4022c7:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
		*--estr = (e<0 ? '-' : '+');
  4022cc:	44 88 40 ff          	mov    %r8b,-0x1(%rax)
		if (ebuf-estr > INT_MAX-l) return -1;
  4022d0:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  4022d5:	44 29 c8             	sub    %r9d,%eax
  4022d8:	48 98                	cltq   
  4022da:	49 39 c3             	cmp    %rax,%r11
  4022dd:	0f 8f 22 fa ff ff    	jg     401d05 <fmt_fp+0x2fd>
		l += ebuf-estr;
  4022e3:	45 01 d9             	add    %r11d,%r9d
	if (l > INT_MAX-pl) return -1;
  4022e6:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  4022eb:	44 29 e8             	sub    %r13d,%eax
  4022ee:	41 39 c1             	cmp    %eax,%r9d
  4022f1:	0f 8f 0e fa ff ff    	jg     401d05 <fmt_fp+0x2fd>
	pad(f, ' ', w, pl+l, fl);
  4022f7:	43 8d 04 29          	lea    (%r9,%r13,1),%eax
  4022fb:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
  402300:	8b 54 24 48          	mov    0x48(%rsp),%edx
  402304:	be 20 00 00 00       	mov    $0x20,%esi
  402309:	4c 89 e7             	mov    %r12,%rdi
  40230c:	89 c1                	mov    %eax,%ecx
  40230e:	89 44 24 20          	mov    %eax,0x20(%rsp)
  402312:	e8 72 f6 ff ff       	callq  401989 <pad>
	out(f, prefix, pl);
  402317:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  40231c:	49 63 d5             	movslq %r13d,%rdx
  40231f:	4c 89 e7             	mov    %r12,%rdi
  402322:	e8 4b f6 ff ff       	callq  401972 <out>
	pad(f, '0', w, pl+l, fl^ZERO_PAD);
  402327:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
  40232c:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
  402330:	be 30 00 00 00       	mov    $0x30,%esi
  402335:	8b 54 24 48          	mov    0x48(%rsp),%edx
  402339:	4c 89 e7             	mov    %r12,%rdi
  40233c:	41 81 f0 00 00 01 00 	xor    $0x10000,%r8d
  402343:	e8 41 f6 ff ff       	callq  401989 <pad>
	if ((t|32)=='f') {
  402348:	83 7c 24 4c 66       	cmpl   $0x66,0x4c(%rsp)
  40234d:	0f 85 eb 00 00 00    	jne    40243e <fmt_fp+0xa36>
  402353:	48 3b 6c 24 10       	cmp    0x10(%rsp),%rbp
			char *s = fmt_u(*d, buf+9);
  402358:	4c 8d 7c 24 7b       	lea    0x7b(%rsp),%r15
  40235d:	48 0f 47 6c 24 10    	cmova  0x10(%rsp),%rbp
		for (d=a; d<=r; d++) {
  402363:	49 89 ed             	mov    %rbp,%r13
  402366:	4c 3b 6c 24 10       	cmp    0x10(%rsp),%r13
  40236b:	77 4b                	ja     4023b8 <fmt_fp+0x9b0>
			char *s = fmt_u(*d, buf+9);
  40236d:	41 8b 7d 00          	mov    0x0(%r13),%edi
  402371:	4d 8d 47 09          	lea    0x9(%r15),%r8
  402375:	4c 89 c6             	mov    %r8,%rsi
  402378:	e8 9a f5 ff ff       	callq  401917 <fmt_u>
			if (d!=a) while (s>buf) *--s='0';
  40237d:	49 39 ed             	cmp    %rbp,%r13
  402380:	74 0d                	je     40238f <fmt_fp+0x987>
  402382:	4c 39 f8             	cmp    %r15,%rax
  402385:	76 19                	jbe    4023a0 <fmt_fp+0x998>
  402387:	48 ff c8             	dec    %rax
  40238a:	c6 00 30             	movb   $0x30,(%rax)
  40238d:	eb f3                	jmp    402382 <fmt_fp+0x97a>
			else if (s==buf+9) *--s='0';
  40238f:	4c 39 c0             	cmp    %r8,%rax
  402392:	75 0c                	jne    4023a0 <fmt_fp+0x998>
  402394:	49 8d 47 08          	lea    0x8(%r15),%rax
  402398:	c6 84 24 83 00 00 00 	movb   $0x30,0x83(%rsp)
  40239f:	30 
			out(f, s, buf+9-s);
  4023a0:	49 8d 57 09          	lea    0x9(%r15),%rdx
  4023a4:	48 89 c6             	mov    %rax,%rsi
  4023a7:	4c 89 e7             	mov    %r12,%rdi
		for (d=a; d<=r; d++) {
  4023aa:	49 83 c5 04          	add    $0x4,%r13
			out(f, s, buf+9-s);
  4023ae:	48 29 c2             	sub    %rax,%rdx
  4023b1:	e8 bc f5 ff ff       	callq  401972 <out>
  4023b6:	eb ae                	jmp    402366 <fmt_fp+0x95e>
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  4023b8:	85 db                	test   %ebx,%ebx
  4023ba:	75 07                	jne    4023c3 <fmt_fp+0x9bb>
  4023bc:	f6 44 24 0c 08       	testb  $0x8,0xc(%rsp)
  4023c1:	74 5e                	je     402421 <fmt_fp+0xa19>
  4023c3:	48 8d 35 b5 3c 00 00 	lea    0x3cb5(%rip),%rsi        # 40607f <_fini+0x6bc>
			char *s = fmt_u(*d, buf+9);
  4023ca:	48 8d 6c 24 7b       	lea    0x7b(%rsp),%rbp
		if (p || (fl&ALT_FORM)) out(f, ".", 1);
  4023cf:	ba 01 00 00 00       	mov    $0x1,%edx
  4023d4:	4c 89 e7             	mov    %r12,%rdi
  4023d7:	e8 96 f5 ff ff       	callq  401972 <out>
		for (; d<z && p>0; d++, p-=9) {
  4023dc:	4d 39 f5             	cmp    %r14,%r13
  4023df:	73 40                	jae    402421 <fmt_fp+0xa19>
  4023e1:	85 db                	test   %ebx,%ebx
  4023e3:	7e 3c                	jle    402421 <fmt_fp+0xa19>
			char *s = fmt_u(*d, buf+9);
  4023e5:	41 8b 7d 00          	mov    0x0(%r13),%edi
  4023e9:	48 8d 75 09          	lea    0x9(%rbp),%rsi
  4023ed:	e8 25 f5 ff ff       	callq  401917 <fmt_u>
			while (s>buf) *--s='0';
  4023f2:	48 39 e8             	cmp    %rbp,%rax
  4023f5:	76 08                	jbe    4023ff <fmt_fp+0x9f7>
  4023f7:	48 ff c8             	dec    %rax
  4023fa:	c6 00 30             	movb   $0x30,(%rax)
  4023fd:	eb f3                	jmp    4023f2 <fmt_fp+0x9ea>
			out(f, s, MIN(9,p));
  4023ff:	83 fb 09             	cmp    $0x9,%ebx
  402402:	ba 09 00 00 00       	mov    $0x9,%edx
  402407:	48 89 c6             	mov    %rax,%rsi
  40240a:	0f 4e d3             	cmovle %ebx,%edx
  40240d:	4c 89 e7             	mov    %r12,%rdi
		for (; d<z && p>0; d++, p-=9) {
  402410:	49 83 c5 04          	add    $0x4,%r13
			out(f, s, MIN(9,p));
  402414:	48 63 d2             	movslq %edx,%rdx
		for (; d<z && p>0; d++, p-=9) {
  402417:	83 eb 09             	sub    $0x9,%ebx
			out(f, s, MIN(9,p));
  40241a:	e8 53 f5 ff ff       	callq  401972 <out>
  40241f:	eb bb                	jmp    4023dc <fmt_fp+0x9d4>
		pad(f, '0', p+9, 9, 0);
  402421:	8d 53 09             	lea    0x9(%rbx),%edx
  402424:	45 31 c0             	xor    %r8d,%r8d
  402427:	b9 09 00 00 00       	mov    $0x9,%ecx
  40242c:	be 30 00 00 00       	mov    $0x30,%esi
  402431:	4c 89 e7             	mov    %r12,%rdi
  402434:	e8 50 f5 ff ff       	callq  401989 <pad>
  402439:	e9 04 01 00 00       	jmpq   402542 <fmt_fp+0xb3a>
		if (z<=a) z=a+1;
  40243e:	48 8d 45 04          	lea    0x4(%rbp),%rax
  402442:	49 39 ee             	cmp    %rbp,%r14
			char *s = fmt_u(*d, buf+9);
  402445:	4c 8d 7c 24 7b       	lea    0x7b(%rsp),%r15
		for (d=a; d<z && p>=0; d++) {
  40244a:	49 89 ed             	mov    %rbp,%r13
		if (z<=a) z=a+1;
  40244d:	4c 0f 46 f0          	cmovbe %rax,%r14
		for (d=a; d<z && p>=0; d++) {
  402451:	4d 39 f5             	cmp    %r14,%r13
  402454:	0f 83 b9 00 00 00    	jae    402513 <fmt_fp+0xb0b>
  40245a:	89 d8                	mov    %ebx,%eax
  40245c:	83 e8 00             	sub    $0x0,%eax
  40245f:	0f 88 ae 00 00 00    	js     402513 <fmt_fp+0xb0b>
			char *s = fmt_u(*d, buf+9);
  402465:	41 8b 7d 00          	mov    0x0(%r13),%edi
  402469:	4d 8d 47 09          	lea    0x9(%r15),%r8
  40246d:	4c 89 c6             	mov    %r8,%rsi
  402470:	e8 a2 f4 ff ff       	callq  401917 <fmt_u>
			if (s==buf+9) *--s='0';
  402475:	4c 39 c0             	cmp    %r8,%rax
  402478:	75 0c                	jne    402486 <fmt_fp+0xa7e>
  40247a:	49 8d 47 08          	lea    0x8(%r15),%rax
  40247e:	c6 84 24 83 00 00 00 	movb   $0x30,0x83(%rsp)
  402485:	30 
			if (d!=a) while (s>buf) *--s='0';
  402486:	49 39 ed             	cmp    %rbp,%r13
  402489:	48 89 c1             	mov    %rax,%rcx
  40248c:	74 0d                	je     40249b <fmt_fp+0xa93>
  40248e:	4c 39 f9             	cmp    %r15,%rcx
  402491:	76 4f                	jbe    4024e2 <fmt_fp+0xada>
  402493:	48 ff c9             	dec    %rcx
  402496:	c6 01 30             	movb   $0x30,(%rcx)
  402499:	eb f3                	jmp    40248e <fmt_fp+0xa86>
				out(f, s++, 1);
  40249b:	48 8d 48 01          	lea    0x1(%rax),%rcx
  40249f:	ba 01 00 00 00       	mov    $0x1,%edx
  4024a4:	48 89 c6             	mov    %rax,%rsi
  4024a7:	4c 89 e7             	mov    %r12,%rdi
  4024aa:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  4024af:	e8 be f4 ff ff       	callq  401972 <out>
				if (p>0||(fl&ALT_FORM)) out(f, ".", 1);
  4024b4:	85 db                	test   %ebx,%ebx
  4024b6:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
  4024bb:	75 07                	jne    4024c4 <fmt_fp+0xabc>
  4024bd:	f6 44 24 0c 08       	testb  $0x8,0xc(%rsp)
  4024c2:	74 1e                	je     4024e2 <fmt_fp+0xada>
  4024c4:	48 8d 35 b4 3b 00 00 	lea    0x3bb4(%rip),%rsi        # 40607f <_fini+0x6bc>
  4024cb:	ba 01 00 00 00       	mov    $0x1,%edx
  4024d0:	4c 89 e7             	mov    %r12,%rdi
  4024d3:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  4024d8:	e8 95 f4 ff ff       	callq  401972 <out>
  4024dd:	48 8b 4c 24 10       	mov    0x10(%rsp),%rcx
			out(f, s, MIN(buf+9-s, p));
  4024e2:	49 8d 47 09          	lea    0x9(%r15),%rax
  4024e6:	48 63 d3             	movslq %ebx,%rdx
  4024e9:	48 89 ce             	mov    %rcx,%rsi
  4024ec:	4c 89 e7             	mov    %r12,%rdi
  4024ef:	48 29 c8             	sub    %rcx,%rax
  4024f2:	48 39 c2             	cmp    %rax,%rdx
  4024f5:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  4024fa:	48 0f 4f d0          	cmovg  %rax,%rdx
		for (d=a; d<z && p>=0; d++) {
  4024fe:	49 83 c5 04          	add    $0x4,%r13
			out(f, s, MIN(buf+9-s, p));
  402502:	e8 6b f4 ff ff       	callq  401972 <out>
			p -= buf+9-s;
  402507:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40250c:	29 c3                	sub    %eax,%ebx
  40250e:	e9 3e ff ff ff       	jmpq   402451 <fmt_fp+0xa49>
		pad(f, '0', p+18, 18, 0);
  402513:	8d 53 12             	lea    0x12(%rbx),%edx
  402516:	be 30 00 00 00       	mov    $0x30,%esi
  40251b:	4c 89 e7             	mov    %r12,%rdi
  40251e:	45 31 c0             	xor    %r8d,%r8d
  402521:	b9 12 00 00 00       	mov    $0x12,%ecx
  402526:	e8 5e f4 ff ff       	callq  401989 <pad>
		out(f, estr, ebuf-estr);
  40252b:	48 8d 54 24 7b       	lea    0x7b(%rsp),%rdx
  402530:	48 2b 54 24 30       	sub    0x30(%rsp),%rdx
  402535:	48 8b 74 24 30       	mov    0x30(%rsp),%rsi
  40253a:	4c 89 e7             	mov    %r12,%rdi
  40253d:	e8 30 f4 ff ff       	callq  401972 <out>
	pad(f, ' ', w, pl+l, fl^LEFT_ADJ);
  402542:	44 8b 44 24 0c       	mov    0xc(%rsp),%r8d
  402547:	8b 4c 24 20          	mov    0x20(%rsp),%ecx
  40254b:	be 20 00 00 00       	mov    $0x20,%esi
  402550:	8b 54 24 48          	mov    0x48(%rsp),%edx
  402554:	4c 89 e7             	mov    %r12,%rdi
  402557:	41 81 f0 00 20 00 00 	xor    $0x2000,%r8d
  40255e:	e8 26 f4 ff ff       	callq  401989 <pad>
	return MAX(w, pl+l);
  402563:	8b 5c 24 20          	mov    0x20(%rsp),%ebx
  402567:	39 5c 24 48          	cmp    %ebx,0x48(%rsp)
  40256b:	89 d8                	mov    %ebx,%eax
  40256d:	0f 4d 44 24 48       	cmovge 0x48(%rsp),%eax
}
  402572:	48 81 c4 48 1d 00 00 	add    $0x1d48,%rsp
  402579:	5b                   	pop    %rbx
  40257a:	5d                   	pop    %rbp
  40257b:	41 5c                	pop    %r12
  40257d:	41 5d                	pop    %r13
  40257f:	41 5e                	pop    %r14
  402581:	41 5f                	pop    %r15
  402583:	c3                   	retq   

0000000000402584 <printf_core>:

static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg, int *nl_type)
{
  402584:	41 57                	push   %r15
  402586:	41 56                	push   %r14
	unsigned l10n=0, fl;
	int w, p, xp;
	union arg arg;
	int argpos;
	unsigned st, ps;
	int cnt=0, l=0;
  402588:	45 31 ff             	xor    %r15d,%r15d
{
  40258b:	41 55                	push   %r13
  40258d:	41 54                	push   %r12
  40258f:	55                   	push   %rbp
  402590:	53                   	push   %rbx
	int cnt=0, l=0;
  402591:	31 db                	xor    %ebx,%ebx
{
  402593:	48 81 ec c8 00 00 00 	sub    $0xc8,%rsp
			wc[1] = 0;
			arg.p = wc;
			p = -1;
		case 'S':
			ws = arg.p;
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  40259a:	48 8d 44 24 6c       	lea    0x6c(%rsp),%rax
{
  40259f:	48 89 3c 24          	mov    %rdi,(%rsp)
  4025a3:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  4025a8:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  4025ad:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  4025b2:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
			arg.p = wc;
  4025b7:	48 8d 44 24 78       	lea    0x78(%rsp),%rax
	char *a, *z, *s=(char *)fmt;
  4025bc:	48 89 74 24 70       	mov    %rsi,0x70(%rsp)
	unsigned l10n=0, fl;
  4025c1:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%rsp)
  4025c8:	00 
			arg.p = wc;
  4025c9:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
		z = buf + sizeof(buf);
  4025ce:	48 8d 84 24 95 00 00 	lea    0x95(%rsp),%rax
  4025d5:	00 
  4025d6:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
			else if (f) pop_arg(&arg, st, ap);
  4025db:	48 8d 84 24 80 00 00 	lea    0x80(%rsp),%rax
  4025e2:	00 
  4025e3:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
		if (l > INT_MAX - cnt) goto overflow;
  4025e8:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  4025ed:	44 29 f8             	sub    %r15d,%eax
  4025f0:	39 c3                	cmp    %eax,%ebx
  4025f2:	0f 8f b2 08 00 00    	jg     402eaa <printf_core+0x926>
		if (!*s) break;
  4025f8:	4c 8b 74 24 70       	mov    0x70(%rsp),%r14
		cnt += l;
  4025fd:	41 01 df             	add    %ebx,%r15d
		if (!*s) break;
  402600:	41 80 3e 00          	cmpb   $0x0,(%r14)
  402604:	0f 84 2f 08 00 00    	je     402e39 <printf_core+0x8b5>
		for (a=s; *s && *s!='%'; s++);
  40260a:	4c 8b 6c 24 70       	mov    0x70(%rsp),%r13
  40260f:	41 8a 45 00          	mov    0x0(%r13),%al
  402613:	84 c0                	test   %al,%al
  402615:	74 20                	je     402637 <printf_core+0xb3>
  402617:	3c 25                	cmp    $0x25,%al
  402619:	74 1c                	je     402637 <printf_core+0xb3>
  40261b:	49 ff c5             	inc    %r13
  40261e:	4c 89 6c 24 70       	mov    %r13,0x70(%rsp)
  402623:	eb e5                	jmp    40260a <printf_core+0x86>
		for (z=s; s[0]=='%' && s[1]=='%'; z++, s+=2);
  402625:	80 78 01 25          	cmpb   $0x25,0x1(%rax)
  402629:	75 16                	jne    402641 <printf_core+0xbd>
  40262b:	48 83 c0 02          	add    $0x2,%rax
  40262f:	49 ff c5             	inc    %r13
  402632:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  402637:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  40263c:	80 38 25             	cmpb   $0x25,(%rax)
  40263f:	74 e4                	je     402625 <printf_core+0xa1>
		if (z-a > INT_MAX-cnt) goto overflow;
  402641:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
  402646:	4d 29 f5             	sub    %r14,%r13
  402649:	44 29 f8             	sub    %r15d,%eax
  40264c:	89 44 24 34          	mov    %eax,0x34(%rsp)
  402650:	48 98                	cltq   
  402652:	49 39 c5             	cmp    %rax,%r13
  402655:	0f 8f 4f 08 00 00    	jg     402eaa <printf_core+0x926>
		if (f) out(f, a, l);
  40265b:	48 83 3c 24 00       	cmpq   $0x0,(%rsp)
		l = z-a;
  402660:	44 89 eb             	mov    %r13d,%ebx
		if (f) out(f, a, l);
  402663:	74 0f                	je     402674 <printf_core+0xf0>
  402665:	48 8b 3c 24          	mov    (%rsp),%rdi
  402669:	49 63 d5             	movslq %r13d,%rdx
  40266c:	4c 89 f6             	mov    %r14,%rsi
  40266f:	e8 fe f2 ff ff       	callq  401972 <out>
		if (l) continue;
  402674:	45 85 ed             	test   %r13d,%r13d
  402677:	0f 85 6b ff ff ff    	jne    4025e8 <printf_core+0x64>
		if (isdigit(s[1]) && s[2]=='$') {
  40267d:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  402682:	44 0f be 58 01       	movsbl 0x1(%rax),%r11d
  402687:	41 83 eb 30          	sub    $0x30,%r11d
  40268b:	41 83 fb 09          	cmp    $0x9,%r11d
  40268f:	77 19                	ja     4026aa <printf_core+0x126>
  402691:	80 78 02 24          	cmpb   $0x24,0x2(%rax)
  402695:	75 13                	jne    4026aa <printf_core+0x126>
			s+=3;
  402697:	48 83 c0 03          	add    $0x3,%rax
			l10n=1;
  40269b:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%rsp)
  4026a2:	00 
			s+=3;
  4026a3:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  4026a8:	eb 0c                	jmp    4026b6 <printf_core+0x132>
			s++;
  4026aa:	48 ff c0             	inc    %rax
			argpos = -1;
  4026ad:	41 83 cb ff          	or     $0xffffffff,%r11d
			s++;
  4026b1:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  4026b6:	31 ed                	xor    %ebp,%ebp
  4026b8:	be 89 28 01 00       	mov    $0x12889,%esi
			fl |= 1U<<*s-' ';
  4026bd:	bf 01 00 00 00       	mov    $0x1,%edi
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  4026c2:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  4026c7:	0f be 08             	movsbl (%rax),%ecx
  4026ca:	89 ca                	mov    %ecx,%edx
  4026cc:	83 e9 20             	sub    $0x20,%ecx
  4026cf:	83 f9 1f             	cmp    $0x1f,%ecx
  4026d2:	76 0b                	jbe    4026df <printf_core+0x15b>
		if (*s=='*') {
  4026d4:	80 fa 2a             	cmp    $0x2a,%dl
  4026d7:	0f 85 cc 00 00 00    	jne    4027a9 <printf_core+0x225>
  4026dd:	eb 15                	jmp    4026f4 <printf_core+0x170>
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  4026df:	0f a3 ce             	bt     %ecx,%esi
  4026e2:	73 f0                	jae    4026d4 <printf_core+0x150>
			fl |= 1U<<*s-' ';
  4026e4:	89 fa                	mov    %edi,%edx
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  4026e6:	48 ff c0             	inc    %rax
			fl |= 1U<<*s-' ';
  4026e9:	d3 e2                	shl    %cl,%edx
		for (fl=0; (unsigned)*s-' '<32 && (FLAGMASK&(1U<<*s-' ')); s++)
  4026eb:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
			fl |= 1U<<*s-' ';
  4026f0:	09 d5                	or     %edx,%ebp
  4026f2:	eb ce                	jmp    4026c2 <printf_core+0x13e>
			if (isdigit(s[1]) && s[2]=='$') {
  4026f4:	48 0f be 48 01       	movsbq 0x1(%rax),%rcx
  4026f9:	48 89 ca             	mov    %rcx,%rdx
  4026fc:	83 e9 30             	sub    $0x30,%ecx
  4026ff:	83 f9 09             	cmp    $0x9,%ecx
  402702:	77 3f                	ja     402743 <printf_core+0x1bf>
  402704:	80 78 02 24          	cmpb   $0x24,0x2(%rax)
  402708:	75 39                	jne    402743 <printf_core+0x1bf>
				nl_type[s[1]-'0'] = INT;
  40270a:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
				s+=3;
  40270f:	48 83 c0 03          	add    $0x3,%rax
				l10n=1;
  402713:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%rsp)
  40271a:	00 
				nl_type[s[1]-'0'] = INT;
  40271b:	c7 84 97 40 ff ff ff 	movl   $0xa,-0xc0(%rdi,%rdx,4)
  402722:	0a 00 00 00 
				w = nl_arg[s[1]-'0'].i;
  402726:	48 0f be 50 fe       	movsbq -0x2(%rax),%rdx
  40272b:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
				s+=3;
  402730:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
				w = nl_arg[s[1]-'0'].i;
  402735:	48 c1 e2 04          	shl    $0x4,%rdx
  402739:	44 8b a4 17 00 fd ff 	mov    -0x300(%rdi,%rdx,1),%r12d
  402740:	ff 
				s+=3;
  402741:	eb 56                	jmp    402799 <printf_core+0x215>
			} else if (!l10n) {
  402743:	83 7c 24 14 00       	cmpl   $0x0,0x14(%rsp)
  402748:	74 10                	je     40275a <printf_core+0x1d6>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
	if (i<=NL_ARGMAX) goto inval;
	return 1;

inval:
	errno = EINVAL;
  40274a:	e8 61 0d 00 00       	callq  4034b0 <__errno_location>
  40274f:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
  402755:	e9 5b 07 00 00       	jmpq   402eb5 <printf_core+0x931>
				w = f ? va_arg(*ap, int) : 0;
  40275a:	48 83 3c 24 00       	cmpq   $0x0,(%rsp)
  40275f:	45 89 ec             	mov    %r13d,%r12d
  402762:	74 2d                	je     402791 <printf_core+0x20d>
  402764:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  402769:	8b 0f                	mov    (%rdi),%ecx
  40276b:	83 f9 2f             	cmp    $0x2f,%ecx
  40276e:	77 0d                	ja     40277d <printf_core+0x1f9>
  402770:	89 ca                	mov    %ecx,%edx
  402772:	83 c1 08             	add    $0x8,%ecx
  402775:	48 03 57 10          	add    0x10(%rdi),%rdx
  402779:	89 0f                	mov    %ecx,(%rdi)
  40277b:	eb 11                	jmp    40278e <printf_core+0x20a>
  40277d:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  402782:	48 8b 56 08          	mov    0x8(%rsi),%rdx
  402786:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  40278a:	48 89 4e 08          	mov    %rcx,0x8(%rsi)
  40278e:	44 8b 22             	mov    (%rdx),%r12d
				s++;
  402791:	48 ff c0             	inc    %rax
  402794:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
			if (w<0) fl|=LEFT_ADJ, w=-w;
  402799:	45 85 e4             	test   %r12d,%r12d
  40279c:	79 20                	jns    4027be <printf_core+0x23a>
  40279e:	81 cd 00 20 00 00    	or     $0x2000,%ebp
  4027a4:	41 f7 dc             	neg    %r12d
  4027a7:	eb 15                	jmp    4027be <printf_core+0x23a>
		} else if ((w=getint(&s))<0) goto overflow;
  4027a9:	48 8d 7c 24 70       	lea    0x70(%rsp),%rdi
  4027ae:	e8 84 f1 ff ff       	callq  401937 <getint>
  4027b3:	85 c0                	test   %eax,%eax
  4027b5:	41 89 c4             	mov    %eax,%r12d
  4027b8:	0f 88 ec 06 00 00    	js     402eaa <printf_core+0x926>
		if (*s=='.' && s[1]=='*') {
  4027be:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
			p = -1;
  4027c3:	49 83 c9 ff          	or     $0xffffffffffffffff,%r9
			xp = 0;
  4027c7:	45 89 ea             	mov    %r13d,%r10d
		if (*s=='.' && s[1]=='*') {
  4027ca:	80 38 2e             	cmpb   $0x2e,(%rax)
  4027cd:	0f 85 bf 00 00 00    	jne    402892 <printf_core+0x30e>
  4027d3:	80 78 01 2a          	cmpb   $0x2a,0x1(%rax)
  4027d7:	0f 85 9a 00 00 00    	jne    402877 <printf_core+0x2f3>
			if (isdigit(s[2]) && s[3]=='$') {
  4027dd:	48 0f be 48 02       	movsbq 0x2(%rax),%rcx
  4027e2:	48 89 ca             	mov    %rcx,%rdx
  4027e5:	83 e9 30             	sub    $0x30,%ecx
  4027e8:	83 f9 09             	cmp    $0x9,%ecx
  4027eb:	77 32                	ja     40281f <printf_core+0x29b>
  4027ed:	80 78 03 24          	cmpb   $0x24,0x3(%rax)
  4027f1:	75 2c                	jne    40281f <printf_core+0x29b>
				nl_type[s[2]-'0'] = INT;
  4027f3:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
				p = nl_arg[s[2]-'0'].i;
  4027f8:	48 8b 7c 24 20       	mov    0x20(%rsp),%rdi
				s+=4;
  4027fd:	48 83 c0 04          	add    $0x4,%rax
				nl_type[s[2]-'0'] = INT;
  402801:	c7 84 96 40 ff ff ff 	movl   $0xa,-0xc0(%rsi,%rdx,4)
  402808:	0a 00 00 00 
				p = nl_arg[s[2]-'0'].i;
  40280c:	48 0f be 50 fe       	movsbq -0x2(%rax),%rdx
  402811:	48 c1 e2 04          	shl    $0x4,%rdx
  402815:	4c 63 8c 17 00 fd ff 	movslq -0x300(%rdi,%rdx,1),%r9
  40281c:	ff 
  40281d:	eb 46                	jmp    402865 <printf_core+0x2e1>
			} else if (!l10n) {
  40281f:	83 7c 24 14 00       	cmpl   $0x0,0x14(%rsp)
  402824:	0f 85 20 ff ff ff    	jne    40274a <printf_core+0x1c6>
				p = f ? va_arg(*ap, int) : 0;
  40282a:	48 83 3c 24 00       	cmpq   $0x0,(%rsp)
  40282f:	4d 63 cd             	movslq %r13d,%r9
  402832:	74 2d                	je     402861 <printf_core+0x2dd>
  402834:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  402839:	8b 0e                	mov    (%rsi),%ecx
  40283b:	83 f9 2f             	cmp    $0x2f,%ecx
  40283e:	77 0d                	ja     40284d <printf_core+0x2c9>
  402840:	89 ca                	mov    %ecx,%edx
  402842:	83 c1 08             	add    $0x8,%ecx
  402845:	48 03 56 10          	add    0x10(%rsi),%rdx
  402849:	89 0e                	mov    %ecx,(%rsi)
  40284b:	eb 11                	jmp    40285e <printf_core+0x2da>
  40284d:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  402852:	48 8b 57 08          	mov    0x8(%rdi),%rdx
  402856:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  40285a:	48 89 4f 08          	mov    %rcx,0x8(%rdi)
  40285e:	4c 63 0a             	movslq (%rdx),%r9
				s+=2;
  402861:	48 83 c0 02          	add    $0x2,%rax
  402865:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
			xp = (p>=0);
  40286a:	44 89 c8             	mov    %r9d,%eax
  40286d:	f7 d0                	not    %eax
  40286f:	c1 e8 1f             	shr    $0x1f,%eax
  402872:	41 89 c2             	mov    %eax,%r10d
  402875:	eb 1b                	jmp    402892 <printf_core+0x30e>
			p = getint(&s);
  402877:	48 8d 7c 24 70       	lea    0x70(%rsp),%rdi
			s++;
  40287c:	48 ff c0             	inc    %rax
  40287f:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
			p = getint(&s);
  402884:	e8 ae f0 ff ff       	callq  401937 <getint>
			xp = 1;
  402889:	41 ba 01 00 00 00    	mov    $0x1,%r10d
			p = getint(&s);
  40288f:	4c 63 c8             	movslq %eax,%r9
			st=states[st]S(*s++);
  402892:	48 8d 3d 27 39 00 00 	lea    0x3927(%rip),%rdi        # 4061c0 <states>
		st=0;
  402899:	31 c0                	xor    %eax,%eax
			if (OOB(*s)) goto inval;
  40289b:	48 8b 54 24 70       	mov    0x70(%rsp),%rdx
  4028a0:	0f be 0a             	movsbl (%rdx),%ecx
  4028a3:	83 e9 41             	sub    $0x41,%ecx
  4028a6:	83 f9 39             	cmp    $0x39,%ecx
  4028a9:	0f 87 9b fe ff ff    	ja     40274a <printf_core+0x1c6>
			st=states[st]S(*s++);
  4028af:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  4028b3:	48 89 4c 24 70       	mov    %rcx,0x70(%rsp)
  4028b8:	89 c1                	mov    %eax,%ecx
  4028ba:	0f be 12             	movsbl (%rdx),%edx
  4028bd:	48 6b c9 3a          	imul   $0x3a,%rcx,%rcx
  4028c1:	83 ea 41             	sub    $0x41,%edx
  4028c4:	48 63 d2             	movslq %edx,%rdx
  4028c7:	48 01 f9             	add    %rdi,%rcx
  4028ca:	0f b6 34 11          	movzbl (%rcx,%rdx,1),%esi
		} while (st-1<STOP);
  4028ce:	8d 56 ff             	lea    -0x1(%rsi),%edx
  4028d1:	83 fa 07             	cmp    $0x7,%edx
  4028d4:	77 04                	ja     4028da <printf_core+0x356>
  4028d6:	89 f0                	mov    %esi,%eax
  4028d8:	eb c1                	jmp    40289b <printf_core+0x317>
		if (!st) goto inval;
  4028da:	85 f6                	test   %esi,%esi
  4028dc:	0f 84 68 fe ff ff    	je     40274a <printf_core+0x1c6>
		if (st==NOARG) {
  4028e2:	83 fe 1b             	cmp    $0x1b,%esi
  4028e5:	75 0a                	jne    4028f1 <printf_core+0x36d>
			if (argpos>=0) goto inval;
  4028e7:	45 85 db             	test   %r11d,%r11d
  4028ea:	78 6a                	js     402956 <printf_core+0x3d2>
  4028ec:	e9 59 fe ff ff       	jmpq   40274a <printf_core+0x1c6>
			if (argpos>=0) nl_type[argpos]=st, arg=nl_arg[argpos];
  4028f1:	45 85 db             	test   %r11d,%r11d
  4028f4:	78 2e                	js     402924 <printf_core+0x3a0>
  4028f6:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  4028fb:	4d 63 db             	movslq %r11d,%r11
  4028fe:	42 89 34 9f          	mov    %esi,(%rdi,%r11,4)
  402902:	49 c1 e3 04          	shl    $0x4,%r11
  402906:	4c 03 5c 24 20       	add    0x20(%rsp),%r11
  40290b:	49 8b 13             	mov    (%r11),%rdx
  40290e:	48 89 94 24 80 00 00 	mov    %rdx,0x80(%rsp)
  402915:	00 
  402916:	49 8b 53 08          	mov    0x8(%r11),%rdx
  40291a:	48 89 94 24 88 00 00 	mov    %rdx,0x88(%rsp)
  402921:	00 
  402922:	eb 32                	jmp    402956 <printf_core+0x3d2>
			else if (f) pop_arg(&arg, st, ap);
  402924:	48 83 3c 24 00       	cmpq   $0x0,(%rsp)
  402929:	75 08                	jne    402933 <printf_core+0x3af>
			else return 0;
  40292b:	45 31 ff             	xor    %r15d,%r15d
  40292e:	e9 20 06 00 00       	jmpq   402f53 <printf_core+0x9cf>
			else if (f) pop_arg(&arg, st, ap);
  402933:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  402938:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  40293d:	89 44 24 50          	mov    %eax,0x50(%rsp)
  402941:	44 89 4c 24 30       	mov    %r9d,0x30(%rsp)
  402946:	e8 5e ee ff ff       	callq  4017a9 <pop_arg>
  40294b:	4c 63 4c 24 30       	movslq 0x30(%rsp),%r9
  402950:	8b 44 24 50          	mov    0x50(%rsp),%eax
  402954:	eb 0b                	jmp    402961 <printf_core+0x3dd>
		if (!f) continue;
  402956:	48 83 3c 24 00       	cmpq   $0x0,(%rsp)
  40295b:	0f 84 87 fc ff ff    	je     4025e8 <printf_core+0x64>
		t = s[-1];
  402961:	48 8b 54 24 70       	mov    0x70(%rsp),%rdx
		if (ps && (t&15)==3) t&=~32;
  402966:	85 c0                	test   %eax,%eax
		t = s[-1];
  402968:	44 0f be 42 ff       	movsbl -0x1(%rdx),%r8d
  40296d:	45 89 c3             	mov    %r8d,%r11d
		if (ps && (t&15)==3) t&=~32;
  402970:	74 13                	je     402985 <printf_core+0x401>
  402972:	44 88 c2             	mov    %r8b,%dl
  402975:	83 e2 0f             	and    $0xf,%edx
  402978:	80 fa 03             	cmp    $0x3,%dl
  40297b:	75 08                	jne    402985 <printf_core+0x401>
  40297d:	41 83 e3 df          	and    $0xffffffdf,%r11d
  402981:	45 0f be c3          	movsbl %r11b,%r8d
		if (fl & LEFT_ADJ) fl &= ~ZERO_PAD;
  402985:	89 ea                	mov    %ebp,%edx
  402987:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
  40298d:	f7 c5 00 20 00 00    	test   $0x2000,%ebp
  402993:	0f 45 ea             	cmovne %edx,%ebp
		switch(t) {
  402996:	41 8d 50 bf          	lea    -0x41(%r8),%edx
  40299a:	83 fa 37             	cmp    $0x37,%edx
  40299d:	0f 87 9b 03 00 00    	ja     402d3e <printf_core+0x7ba>
  4029a3:	48 8d 0d ea 36 00 00 	lea    0x36ea(%rip),%rcx        # 406094 <_fini+0x6d1>
  4029aa:	48 63 14 91          	movslq (%rcx,%rdx,4),%rdx
  4029ae:	48 01 ca             	add    %rcx,%rdx
  4029b1:	ff e2                	jmpq   *%rdx
			switch(ps) {
  4029b3:	83 f8 07             	cmp    $0x7,%eax
  4029b6:	0f 87 2c fc ff ff    	ja     4025e8 <printf_core+0x64>
  4029bc:	48 8d 15 b1 37 00 00 	lea    0x37b1(%rip),%rdx        # 406174 <_fini+0x7b1>
  4029c3:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
  4029c7:	48 01 d0             	add    %rdx,%rax
  4029ca:	ff e0                	jmpq   *%rax
			case BARE: *(int *)arg.p = cnt; break;
  4029cc:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  4029d3:	00 
  4029d4:	44 89 38             	mov    %r15d,(%rax)
  4029d7:	e9 0c fc ff ff       	jmpq   4025e8 <printf_core+0x64>
			case HPRE: *(unsigned short *)arg.p = cnt; break;
  4029dc:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  4029e3:	00 
  4029e4:	66 44 89 38          	mov    %r15w,(%rax)
  4029e8:	e9 fb fb ff ff       	jmpq   4025e8 <printf_core+0x64>
			case HHPRE: *(unsigned char *)arg.p = cnt; break;
  4029ed:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  4029f4:	00 
  4029f5:	44 88 38             	mov    %r15b,(%rax)
  4029f8:	e9 eb fb ff ff       	jmpq   4025e8 <printf_core+0x64>
			case JPRE: *(uintmax_t *)arg.p = cnt; break;
  4029fd:	48 8b 94 24 80 00 00 	mov    0x80(%rsp),%rdx
  402a04:	00 
  402a05:	49 63 c7             	movslq %r15d,%rax
  402a08:	48 89 02             	mov    %rax,(%rdx)
  402a0b:	e9 d8 fb ff ff       	jmpq   4025e8 <printf_core+0x64>
			p = MAX(p, 2*sizeof(void*));
  402a10:	41 83 f9 10          	cmp    $0x10,%r9d
  402a14:	b8 10 00 00 00       	mov    $0x10,%eax
			t = 'x';
  402a19:	41 b8 78 00 00 00    	mov    $0x78,%r8d
			p = MAX(p, 2*sizeof(void*));
  402a1f:	4c 0f 42 c8          	cmovb  %rax,%r9
			fl |= ALT_FORM;
  402a23:	83 cd 08             	or     $0x8,%ebp
			a = fmt_x(arg.i, z, t&32);
  402a26:	48 8b 94 24 80 00 00 	mov    0x80(%rsp),%rdx
  402a2d:	00 
  402a2e:	44 89 c1             	mov    %r8d,%ecx
  402a31:	4c 8d b4 24 c0 00 00 	lea    0xc0(%rsp),%r14
  402a38:	00 
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  402a39:	48 8d 35 60 37 00 00 	lea    0x3760(%rip),%rsi        # 4061a0 <xdigits>
			a = fmt_x(arg.i, z, t&32);
  402a40:	83 e1 20             	and    $0x20,%ecx
  402a43:	48 89 d0             	mov    %rdx,%rax
	for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;
  402a46:	48 85 c0             	test   %rax,%rax
  402a49:	74 17                	je     402a62 <printf_core+0x4de>
  402a4b:	48 89 c7             	mov    %rax,%rdi
  402a4e:	88 cb                	mov    %cl,%bl
  402a50:	49 ff ce             	dec    %r14
  402a53:	83 e7 0f             	and    $0xf,%edi
  402a56:	48 c1 e8 04          	shr    $0x4,%rax
  402a5a:	0a 1c 3e             	or     (%rsi,%rdi,1),%bl
  402a5d:	41 88 1e             	mov    %bl,(%r14)
  402a60:	eb e4                	jmp    402a46 <printf_core+0x4c2>
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  402a62:	48 85 d2             	test   %rdx,%rdx
		pl = 0;
  402a65:	44 89 eb             	mov    %r13d,%ebx
		prefix = "-+   0X0x";
  402a68:	4c 8d 1d 12 36 00 00 	lea    0x3612(%rip),%r11        # 406081 <_fini+0x6be>
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  402a6f:	0f 84 0c 01 00 00    	je     402b81 <printf_core+0x5fd>
  402a75:	40 f6 c5 08          	test   $0x8,%bpl
		pl = 0;
  402a79:	44 89 eb             	mov    %r13d,%ebx
			if (arg.i && (fl & ALT_FORM)) prefix+=(t>>4), pl=2;
  402a7c:	0f 84 ff 00 00 00    	je     402b81 <printf_core+0x5fd>
  402a82:	41 c1 f8 04          	sar    $0x4,%r8d
  402a86:	bb 02 00 00 00       	mov    $0x2,%ebx
  402a8b:	4d 63 c0             	movslq %r8d,%r8
  402a8e:	4d 01 c3             	add    %r8,%r11
  402a91:	e9 eb 00 00 00       	jmpq   402b81 <printf_core+0x5fd>
			a = fmt_o(arg.i, z);
  402a96:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  402a9d:	00 
  402a9e:	4c 8d b4 24 c0 00 00 	lea    0xc0(%rsp),%r14
  402aa5:	00 
	for (; x; x>>=3) *--s = '0' + (x&7);
  402aa6:	48 85 c0             	test   %rax,%rax
  402aa9:	74 14                	je     402abf <printf_core+0x53b>
  402aab:	88 c2                	mov    %al,%dl
  402aad:	49 ff ce             	dec    %r14
  402ab0:	48 c1 e8 03          	shr    $0x3,%rax
  402ab4:	83 e2 07             	and    $0x7,%edx
  402ab7:	83 c2 30             	add    $0x30,%edx
  402aba:	41 88 16             	mov    %dl,(%r14)
  402abd:	eb e7                	jmp    402aa6 <printf_core+0x522>
			if ((fl&ALT_FORM) && p<z-a+1) prefix+=5, pl=1;
  402abf:	40 f6 c5 08          	test   $0x8,%bpl
		pl = 0;
  402ac3:	44 89 eb             	mov    %r13d,%ebx
		prefix = "-+   0X0x";
  402ac6:	4c 8d 1d b4 35 00 00 	lea    0x35b4(%rip),%r11        # 406081 <_fini+0x6be>
			if ((fl&ALT_FORM) && p<z-a+1) prefix+=5, pl=1;
  402acd:	0f 84 ae 00 00 00    	je     402b81 <printf_core+0x5fd>
  402ad3:	48 8d 8c 24 c0 00 00 	lea    0xc0(%rsp),%rcx
  402ada:	00 
  402adb:	49 63 c1             	movslq %r9d,%rax
  402ade:	bb 01 00 00 00       	mov    $0x1,%ebx
  402ae3:	4c 29 f1             	sub    %r14,%rcx
  402ae6:	48 39 c1             	cmp    %rax,%rcx
  402ae9:	48 8d 05 96 35 00 00 	lea    0x3596(%rip),%rax        # 406086 <_fini+0x6c3>
  402af0:	41 0f 4c dd          	cmovl  %r13d,%ebx
  402af4:	4c 0f 4d d8          	cmovge %rax,%r11
  402af8:	e9 84 00 00 00       	jmpq   402b81 <printf_core+0x5fd>
			if (arg.i>INTMAX_MAX) {
  402afd:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  402b04:	00 
  402b05:	48 85 c0             	test   %rax,%rax
  402b08:	79 12                	jns    402b1c <printf_core+0x598>
				arg.i=-arg.i;
  402b0a:	48 f7 d8             	neg    %rax
			pl=1;
  402b0d:	bb 01 00 00 00       	mov    $0x1,%ebx
				arg.i=-arg.i;
  402b12:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
  402b19:	00 
  402b1a:	eb 32                	jmp    402b4e <printf_core+0x5ca>
			} else if (fl & MARK_POS) {
  402b1c:	0f ba e5 0b          	bt     $0xb,%ebp
			pl=1;
  402b20:	bb 01 00 00 00       	mov    $0x1,%ebx
				prefix++;
  402b25:	4c 8d 1d 56 35 00 00 	lea    0x3556(%rip),%r11        # 406082 <_fini+0x6bf>
			} else if (fl & MARK_POS) {
  402b2c:	72 27                	jb     402b55 <printf_core+0x5d1>
			} else pl=0;
  402b2e:	89 e8                	mov    %ebp,%eax
  402b30:	4c 8d 1d 4c 35 00 00 	lea    0x354c(%rip),%r11        # 406083 <_fini+0x6c0>
  402b37:	83 e0 01             	and    $0x1,%eax
  402b3a:	48 8d 05 40 35 00 00 	lea    0x3540(%rip),%rax        # 406081 <_fini+0x6be>
  402b41:	41 0f 44 dd          	cmove  %r13d,%ebx
  402b45:	4c 0f 44 d8          	cmove  %rax,%r11
  402b49:	eb 0a                	jmp    402b55 <printf_core+0x5d1>
		pl = 0;
  402b4b:	44 89 eb             	mov    %r13d,%ebx
		prefix = "-+   0X0x";
  402b4e:	4c 8d 1d 2c 35 00 00 	lea    0x352c(%rip),%r11        # 406081 <_fini+0x6be>
			a = fmt_u(arg.i, z);
  402b55:	48 8b bc 24 80 00 00 	mov    0x80(%rsp),%rdi
  402b5c:	00 
  402b5d:	48 8d b4 24 c0 00 00 	lea    0xc0(%rsp),%rsi
  402b64:	00 
  402b65:	4c 89 5c 24 50       	mov    %r11,0x50(%rsp)
  402b6a:	44 89 4c 24 30       	mov    %r9d,0x30(%rsp)
  402b6f:	e8 a3 ed ff ff       	callq  401917 <fmt_u>
  402b74:	4c 63 4c 24 30       	movslq 0x30(%rsp),%r9
  402b79:	4c 8b 5c 24 50       	mov    0x50(%rsp),%r11
  402b7e:	49 89 c6             	mov    %rax,%r14
			if (xp && p<0) goto overflow;
  402b81:	44 89 c8             	mov    %r9d,%eax
  402b84:	c1 e8 1f             	shr    $0x1f,%eax
  402b87:	74 0a                	je     402b93 <printf_core+0x60f>
  402b89:	41 80 e2 01          	and    $0x1,%r10b
  402b8d:	0f 85 17 03 00 00    	jne    402eaa <printf_core+0x926>
			if (p>=0) fl &= ~ZERO_PAD;
  402b93:	89 e8                	mov    %ebp,%eax
  402b95:	25 ff ff fe ff       	and    $0xfffeffff,%eax
  402b9a:	45 85 c9             	test   %r9d,%r9d
  402b9d:	0f 49 e8             	cmovns %eax,%ebp
			if (!arg.i && !p) {
  402ba0:	48 83 bc 24 80 00 00 	cmpq   $0x0,0x80(%rsp)
  402ba7:	00 00 
  402ba9:	0f 94 c2             	sete   %dl
  402bac:	45 85 c9             	test   %r9d,%r9d
  402baf:	75 08                	jne    402bb9 <printf_core+0x635>
  402bb1:	84 d2                	test   %dl,%dl
  402bb3:	0f 85 96 01 00 00    	jne    402d4f <printf_core+0x7cb>
			p = MAX(p, z-a + !arg.i);
  402bb9:	48 8d 84 24 c0 00 00 	lea    0xc0(%rsp),%rax
  402bc0:	00 
  402bc1:	0f b6 d2             	movzbl %dl,%edx
  402bc4:	4c 29 f0             	sub    %r14,%rax
  402bc7:	48 01 d0             	add    %rdx,%rax
  402bca:	4c 39 c8             	cmp    %r9,%rax
  402bcd:	4c 0f 4d c8          	cmovge %rax,%r9
  402bd1:	e9 6f 01 00 00       	jmpq   402d45 <printf_core+0x7c1>
			*(a=z-(p=1))=arg.i;
  402bd6:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  402bdd:	00 
			fl &= ~ZERO_PAD;
  402bde:	81 e5 ff ff fe ff    	and    $0xfffeffff,%ebp
		prefix = "-+   0X0x";
  402be4:	4c 8d 1d 96 34 00 00 	lea    0x3496(%rip),%r11        # 406081 <_fini+0x6be>
			*(a=z-(p=1))=arg.i;
  402beb:	41 b9 01 00 00 00    	mov    $0x1,%r9d
		z = buf + sizeof(buf);
  402bf1:	4c 8d ac 24 c0 00 00 	lea    0xc0(%rsp),%r13
  402bf8:	00 
			*(a=z-(p=1))=arg.i;
  402bf9:	88 84 24 bf 00 00 00 	mov    %al,0xbf(%rsp)
  402c00:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  402c05:	4c 8d 70 2a          	lea    0x2a(%rax),%r14
			break;
  402c09:	e9 4f 01 00 00       	jmpq   402d5d <printf_core+0x7d9>
  402c0e:	44 89 4c 24 30       	mov    %r9d,0x30(%rsp)
			if (1) a = strerror(errno); else
  402c13:	e8 98 08 00 00       	callq  4034b0 <__errno_location>
  402c18:	8b 38                	mov    (%rax),%edi
  402c1a:	e8 db 08 00 00       	callq  4034fa <strerror>
  402c1f:	4c 63 4c 24 30       	movslq 0x30(%rsp),%r9
  402c24:	49 89 c6             	mov    %rax,%r14
  402c27:	eb 19                	jmp    402c42 <printf_core+0x6be>
			a = arg.p ? arg.p : "(null)";
  402c29:	4c 8b 94 24 80 00 00 	mov    0x80(%rsp),%r10
  402c30:	00 
  402c31:	48 8d 05 53 34 00 00 	lea    0x3453(%rip),%rax        # 40608b <_fini+0x6c8>
  402c38:	4d 85 d2             	test   %r10,%r10
  402c3b:	49 0f 45 c2          	cmovne %r10,%rax
  402c3f:	49 89 c6             	mov    %rax,%r14
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  402c42:	45 85 c9             	test   %r9d,%r9d
  402c45:	be ff ff ff 7f       	mov    $0x7fffffff,%esi
  402c4a:	4c 89 f7             	mov    %r14,%rdi
  402c4d:	49 0f 49 f1          	cmovns %r9,%rsi
  402c51:	44 89 4c 24 30       	mov    %r9d,0x30(%rsp)
  402c56:	e8 35 06 00 00       	callq  403290 <strnlen>
			if (p<0 && *z) goto overflow;
  402c5b:	44 8b 4c 24 30       	mov    0x30(%rsp),%r9d
			z = a + strnlen(a, p<0 ? INT_MAX : p);
  402c60:	4d 8d 2c 06          	lea    (%r14,%rax,1),%r13
			if (p<0 && *z) goto overflow;
  402c64:	45 85 c9             	test   %r9d,%r9d
  402c67:	79 0b                	jns    402c74 <printf_core+0x6f0>
  402c69:	41 80 7d 00 00       	cmpb   $0x0,0x0(%r13)
  402c6e:	0f 85 36 02 00 00    	jne    402eaa <printf_core+0x926>
			p = z-a;
  402c74:	41 89 c1             	mov    %eax,%r9d
			fl &= ~ZERO_PAD;
  402c77:	81 e5 ff ff fe ff    	and    $0xfffeffff,%ebp
		prefix = "-+   0X0x";
  402c7d:	4c 8d 1d fd 33 00 00 	lea    0x33fd(%rip),%r11        # 406081 <_fini+0x6be>
			break;
  402c84:	e9 d4 00 00 00       	jmpq   402d5d <printf_core+0x7d9>
			wc[0] = arg.i;
  402c89:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
  402c90:	00 
			wc[1] = 0;
  402c91:	c7 44 24 7c 00 00 00 	movl   $0x0,0x7c(%rsp)
  402c98:	00 
			p = -1;
  402c99:	41 83 c9 ff          	or     $0xffffffff,%r9d
			wc[0] = arg.i;
  402c9d:	89 44 24 78          	mov    %eax,0x78(%rsp)
			arg.p = wc;
  402ca1:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  402ca6:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
  402cad:	00 
			ws = arg.p;
  402cae:	48 8b 9c 24 80 00 00 	mov    0x80(%rsp),%rbx
  402cb5:	00 
			for (i=l=0; i<p && *ws && (l=wctomb(mb, *ws++))>=0 && l<=p-i; i+=l);
  402cb6:	45 31 ed             	xor    %r13d,%r13d
  402cb9:	4d 63 f1             	movslq %r9d,%r14
  402cbc:	4d 39 f5             	cmp    %r14,%r13
  402cbf:	0f 83 f9 01 00 00    	jae    402ebe <printf_core+0x93a>
  402cc5:	8b 33                	mov    (%rbx),%esi
  402cc7:	85 f6                	test   %esi,%esi
  402cc9:	0f 84 ef 01 00 00    	je     402ebe <printf_core+0x93a>
  402ccf:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  402cd4:	48 83 c3 04          	add    $0x4,%rbx
  402cd8:	e8 f2 1d 00 00       	callq  404acf <wctomb>
  402cdd:	85 c0                	test   %eax,%eax
  402cdf:	0f 88 d0 01 00 00    	js     402eb5 <printf_core+0x931>
  402ce5:	4c 89 f2             	mov    %r14,%rdx
  402ce8:	48 98                	cltq   
  402cea:	4c 29 ea             	sub    %r13,%rdx
  402ced:	48 39 d0             	cmp    %rdx,%rax
  402cf0:	0f 87 c8 01 00 00    	ja     402ebe <printf_core+0x93a>
  402cf6:	49 01 c5             	add    %rax,%r13
  402cf9:	eb c1                	jmp    402cbc <printf_core+0x738>
			if (xp && p<0) goto overflow;
  402cfb:	44 89 c8             	mov    %r9d,%eax
  402cfe:	c1 e8 1f             	shr    $0x1f,%eax
  402d01:	74 0a                	je     402d0d <printf_core+0x789>
  402d03:	41 80 e2 01          	and    $0x1,%r10b
  402d07:	0f 85 9d 01 00 00    	jne    402eaa <printf_core+0x926>
			l = fmt_fp(f, arg.f, w, p, fl, t);
  402d0d:	ff b4 24 88 00 00 00 	pushq  0x88(%rsp)
  402d14:	ff b4 24 88 00 00 00 	pushq  0x88(%rsp)
  402d1b:	44 89 ca             	mov    %r9d,%edx
  402d1e:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  402d23:	89 e9                	mov    %ebp,%ecx
  402d25:	44 89 e6             	mov    %r12d,%esi
  402d28:	e8 db ec ff ff       	callq  401a08 <fmt_fp>
  402d2d:	89 c3                	mov    %eax,%ebx
			if (l<0) goto overflow;
  402d2f:	85 db                	test   %ebx,%ebx
  402d31:	58                   	pop    %rax
  402d32:	5a                   	pop    %rdx
  402d33:	0f 89 af f8 ff ff    	jns    4025e8 <printf_core+0x64>
  402d39:	e9 6c 01 00 00       	jmpq   402eaa <printf_core+0x926>
		prefix = "-+   0X0x";
  402d3e:	4c 8d 1d 3c 33 00 00 	lea    0x333c(%rip),%r11        # 406081 <_fini+0x6be>
		z = buf + sizeof(buf);
  402d45:	4c 8d ac 24 c0 00 00 	lea    0xc0(%rsp),%r13
  402d4c:	00 
  402d4d:	eb 0e                	jmp    402d5d <printf_core+0x7d9>
  402d4f:	45 89 e9             	mov    %r13d,%r9d
  402d52:	4c 8d ac 24 c0 00 00 	lea    0xc0(%rsp),%r13
  402d59:	00 
				a=z;
  402d5a:	4d 89 ee             	mov    %r13,%r14
		if (p < z-a) p = z-a;
  402d5d:	49 63 c1             	movslq %r9d,%rax
  402d60:	4d 29 f5             	sub    %r14,%r13
  402d63:	4c 89 5c 24 58       	mov    %r11,0x58(%rsp)
  402d68:	4c 39 e8             	cmp    %r13,%rax
		if (p > INT_MAX-pl) goto overflow;
  402d6b:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
		if (p < z-a) p = z-a;
  402d70:	45 0f 4c cd          	cmovl  %r13d,%r9d
		if (p > INT_MAX-pl) goto overflow;
  402d74:	29 d8                	sub    %ebx,%eax
  402d76:	41 39 c1             	cmp    %eax,%r9d
  402d79:	0f 8f 2b 01 00 00    	jg     402eaa <printf_core+0x926>
		if (w < pl+p) w = pl+p;
  402d7f:	41 8d 04 19          	lea    (%r9,%rbx,1),%eax
  402d83:	44 89 4c 24 50       	mov    %r9d,0x50(%rsp)
  402d88:	41 39 c4             	cmp    %eax,%r12d
  402d8b:	89 44 24 30          	mov    %eax,0x30(%rsp)
  402d8f:	44 0f 4c e0          	cmovl  %eax,%r12d
		if (w > INT_MAX-cnt) goto overflow;
  402d93:	44 3b 64 24 34       	cmp    0x34(%rsp),%r12d
  402d98:	0f 8f 0c 01 00 00    	jg     402eaa <printf_core+0x926>
		pad(f, ' ', w, pl+p, fl);
  402d9e:	48 8b 3c 24          	mov    (%rsp),%rdi
  402da2:	89 c1                	mov    %eax,%ecx
  402da4:	41 89 e8             	mov    %ebp,%r8d
  402da7:	44 89 e2             	mov    %r12d,%edx
  402daa:	be 20 00 00 00       	mov    $0x20,%esi
  402daf:	e8 d5 eb ff ff       	callq  401989 <pad>
		out(f, prefix, pl);
  402db4:	4c 8b 5c 24 58       	mov    0x58(%rsp),%r11
  402db9:	48 8b 3c 24          	mov    (%rsp),%rdi
  402dbd:	48 63 d3             	movslq %ebx,%rdx
		pad(f, ' ', w, pl+p, fl^LEFT_ADJ);
  402dc0:	44 89 e3             	mov    %r12d,%ebx
		out(f, prefix, pl);
  402dc3:	4c 89 de             	mov    %r11,%rsi
  402dc6:	e8 a7 eb ff ff       	callq  401972 <out>
		pad(f, '0', w, pl+p, fl^ZERO_PAD);
  402dcb:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
  402dcf:	48 8b 3c 24          	mov    (%rsp),%rdi
  402dd3:	41 89 e8             	mov    %ebp,%r8d
  402dd6:	41 81 f0 00 00 01 00 	xor    $0x10000,%r8d
  402ddd:	44 89 e2             	mov    %r12d,%edx
  402de0:	be 30 00 00 00       	mov    $0x30,%esi
  402de5:	e8 9f eb ff ff       	callq  401989 <pad>
		pad(f, '0', p, z-a, 0);
  402dea:	44 8b 4c 24 50       	mov    0x50(%rsp),%r9d
  402def:	48 8b 3c 24          	mov    (%rsp),%rdi
  402df3:	45 31 c0             	xor    %r8d,%r8d
  402df6:	44 89 e9             	mov    %r13d,%ecx
  402df9:	be 30 00 00 00       	mov    $0x30,%esi
  402dfe:	44 89 ca             	mov    %r9d,%edx
  402e01:	e8 83 eb ff ff       	callq  401989 <pad>
		out(f, a, z-a);
  402e06:	48 8b 3c 24          	mov    (%rsp),%rdi
  402e0a:	4c 89 ea             	mov    %r13,%rdx
  402e0d:	4c 89 f6             	mov    %r14,%rsi
  402e10:	e8 5d eb ff ff       	callq  401972 <out>
		pad(f, ' ', w, pl+p, fl^LEFT_ADJ);
  402e15:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
  402e19:	48 8b 3c 24          	mov    (%rsp),%rdi
  402e1d:	41 89 e8             	mov    %ebp,%r8d
  402e20:	41 81 f0 00 20 00 00 	xor    $0x2000,%r8d
  402e27:	44 89 e2             	mov    %r12d,%edx
  402e2a:	be 20 00 00 00       	mov    $0x20,%esi
  402e2f:	e8 55 eb ff ff       	callq  401989 <pad>
  402e34:	e9 af f7 ff ff       	jmpq   4025e8 <printf_core+0x64>
	if (f) return cnt;
  402e39:	48 83 3c 24 00       	cmpq   $0x0,(%rsp)
  402e3e:	0f 85 0f 01 00 00    	jne    402f53 <printf_core+0x9cf>
	if (!l10n) return 0;
  402e44:	83 7c 24 14 00       	cmpl   $0x0,0x14(%rsp)
  402e49:	0f 84 dc fa ff ff    	je     40292b <printf_core+0x3a7>
  402e4f:	4c 8b 4c 24 20       	mov    0x20(%rsp),%r9
  402e54:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  402e5a:	49 83 c1 10          	add    $0x10,%r9
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  402e5e:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  402e63:	42 8b 34 80          	mov    (%rax,%r8,4),%esi
  402e67:	85 f6                	test   %esi,%esi
  402e69:	74 2e                	je     402e99 <printf_core+0x915>
		pop_arg(nl_arg+i, nl_type[i], ap);
  402e6b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  402e70:	4c 89 cf             	mov    %r9,%rdi
  402e73:	e8 31 e9 ff ff       	callq  4017a9 <pop_arg>
	for (i=1; i<=NL_ARGMAX && nl_type[i]; i++)
  402e78:	49 ff c0             	inc    %r8
  402e7b:	49 83 c1 10          	add    $0x10,%r9
  402e7f:	49 83 f8 0a          	cmp    $0xa,%r8
  402e83:	75 d9                	jne    402e5e <printf_core+0x8da>
	return 1;
  402e85:	41 bf 01 00 00 00    	mov    $0x1,%r15d
  402e8b:	e9 c3 00 00 00       	jmpq   402f53 <printf_core+0x9cf>
	for (; i<=NL_ARGMAX && !nl_type[i]; i++);
  402e90:	49 ff c0             	inc    %r8
  402e93:	49 83 f8 0a          	cmp    $0xa,%r8
  402e97:	74 ec                	je     402e85 <printf_core+0x901>
  402e99:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  402e9e:	42 83 3c 80 00       	cmpl   $0x0,(%rax,%r8,4)
  402ea3:	74 eb                	je     402e90 <printf_core+0x90c>
  402ea5:	e9 a0 f8 ff ff       	jmpq   40274a <printf_core+0x1c6>
	return -1;
overflow:
	errno = EOVERFLOW;
  402eaa:	e8 01 06 00 00       	callq  4034b0 <__errno_location>
  402eaf:	c7 00 4b 00 00 00    	movl   $0x4b,(%rax)
			if (l<0) return -1;
  402eb5:	41 83 cf ff          	or     $0xffffffff,%r15d
  402eb9:	e9 95 00 00 00       	jmpq   402f53 <printf_core+0x9cf>
			if (i > INT_MAX) goto overflow;
  402ebe:	49 81 fd ff ff ff 7f 	cmp    $0x7fffffff,%r13
  402ec5:	77 e3                	ja     402eaa <printf_core+0x926>
			pad(f, ' ', w, p, fl);
  402ec7:	48 8b 3c 24          	mov    (%rsp),%rdi
  402ecb:	41 89 e8             	mov    %ebp,%r8d
  402ece:	44 89 e9             	mov    %r13d,%ecx
  402ed1:	44 89 e2             	mov    %r12d,%edx
  402ed4:	be 20 00 00 00       	mov    $0x20,%esi
			p = i;
  402ed9:	44 89 6c 24 30       	mov    %r13d,0x30(%rsp)
			for (i=0; i<0U+p && *ws && i+(l=wctomb(mb, *ws++))<=p; i+=l)
  402ede:	45 31 f6             	xor    %r14d,%r14d
			pad(f, ' ', w, p, fl);
  402ee1:	e8 a3 ea ff ff       	callq  401989 <pad>
			ws = arg.p;
  402ee6:	48 8b 9c 24 80 00 00 	mov    0x80(%rsp),%rbx
  402eed:	00 
			for (i=0; i<0U+p && *ws && i+(l=wctomb(mb, *ws++))<=p; i+=l)
  402eee:	4d 39 f5             	cmp    %r14,%r13
  402ef1:	77 31                	ja     402f24 <printf_core+0x9a0>
			pad(f, ' ', w, p, fl^LEFT_ADJ);
  402ef3:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
  402ef7:	48 8b 3c 24          	mov    (%rsp),%rdi
  402efb:	41 89 e8             	mov    %ebp,%r8d
  402efe:	41 81 f0 00 20 00 00 	xor    $0x2000,%r8d
  402f05:	44 89 e2             	mov    %r12d,%edx
  402f08:	be 20 00 00 00       	mov    $0x20,%esi
  402f0d:	e8 77 ea ff ff       	callq  401989 <pad>
			l = w>p ? w : p;
  402f12:	44 3b 64 24 30       	cmp    0x30(%rsp),%r12d
  402f17:	8b 5c 24 30          	mov    0x30(%rsp),%ebx
  402f1b:	41 0f 4d dc          	cmovge %r12d,%ebx
			continue;
  402f1f:	e9 c4 f6 ff ff       	jmpq   4025e8 <printf_core+0x64>
			for (i=0; i<0U+p && *ws && i+(l=wctomb(mb, *ws++))<=p; i+=l)
  402f24:	8b 33                	mov    (%rbx),%esi
  402f26:	85 f6                	test   %esi,%esi
  402f28:	74 c9                	je     402ef3 <printf_core+0x96f>
  402f2a:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  402f2f:	48 83 c3 04          	add    $0x4,%rbx
  402f33:	e8 97 1b 00 00       	callq  404acf <wctomb>
  402f38:	48 63 d0             	movslq %eax,%rdx
  402f3b:	49 01 d6             	add    %rdx,%r14
  402f3e:	4d 39 f5             	cmp    %r14,%r13
  402f41:	72 b0                	jb     402ef3 <printf_core+0x96f>
				out(f, mb, l);
  402f43:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
  402f48:	48 8b 3c 24          	mov    (%rsp),%rdi
  402f4c:	e8 21 ea ff ff       	callq  401972 <out>
  402f51:	eb 9b                	jmp    402eee <printf_core+0x96a>
	return -1;
}
  402f53:	48 81 c4 c8 00 00 00 	add    $0xc8,%rsp
  402f5a:	44 89 f8             	mov    %r15d,%eax
  402f5d:	5b                   	pop    %rbx
  402f5e:	5d                   	pop    %rbp
  402f5f:	41 5c                	pop    %r12
  402f61:	41 5d                	pop    %r13
  402f63:	41 5e                	pop    %r14
  402f65:	41 5f                	pop    %r15
  402f67:	c3                   	retq   

0000000000402f68 <vfprintf>:

int vfprintf(FILE *restrict f, const char *restrict fmt, va_list ap)
{
  402f68:	41 57                	push   %r15
  402f6a:	41 56                	push   %r14
	va_list ap2;
	int nl_type[NL_ARGMAX+1] = {0};
  402f6c:	31 c0                	xor    %eax,%eax
{
  402f6e:	41 55                	push   %r13
  402f70:	41 54                	push   %r12
  402f72:	49 89 fd             	mov    %rdi,%r13
  402f75:	55                   	push   %rbp
  402f76:	53                   	push   %rbx
	int nl_type[NL_ARGMAX+1] = {0};
  402f77:	b9 0a 00 00 00       	mov    $0xa,%ecx

	/* the copy allows passing va_list* even if va_list is an array */
	va_copy(ap2, ap);
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
		va_end(ap2);
		return -1;
  402f7c:	83 cb ff             	or     $0xffffffff,%ebx
{
  402f7f:	48 81 ec 58 01 00 00 	sub    $0x158,%rsp
	int nl_type[NL_ARGMAX+1] = {0};
  402f86:	48 8d 7c 24 38       	lea    0x38(%rsp),%rdi
{
  402f8b:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  402f90:	48 89 d6             	mov    %rdx,%rsi
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  402f93:	4c 8d 7c 24 38       	lea    0x38(%rsp),%r15
  402f98:	4c 8d b4 24 b0 00 00 	lea    0xb0(%rsp),%r14
  402f9f:	00 
	int nl_type[NL_ARGMAX+1] = {0};
  402fa0:	f3 ab                	rep stos %eax,%es:(%rdi)
	va_copy(ap2, ap);
  402fa2:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  402fa7:	b9 06 00 00 00       	mov    $0x6,%ecx
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  402fac:	4d 89 f8             	mov    %r15,%r8
	va_copy(ap2, ap);
  402faf:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  402fb4:	48 89 c7             	mov    %rax,%rdi
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  402fb7:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
	va_copy(ap2, ap);
  402fbc:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
  402fbe:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  402fc3:	31 ff                	xor    %edi,%edi
  402fc5:	4c 89 f1             	mov    %r14,%rcx
  402fc8:	e8 b7 f5 ff ff       	callq  402584 <printf_core>
  402fcd:	85 c0                	test   %eax,%eax
  402fcf:	0f 88 e9 00 00 00    	js     4030be <vfprintf+0x156>
	}

	FLOCK(f);
  402fd5:	41 8b 85 8c 00 00 00 	mov    0x8c(%r13),%eax
  402fdc:	45 31 e4             	xor    %r12d,%r12d
  402fdf:	85 c0                	test   %eax,%eax
  402fe1:	78 0b                	js     402fee <vfprintf+0x86>
  402fe3:	4c 89 ef             	mov    %r13,%rdi
  402fe6:	e8 ec 1c 00 00       	callq  404cd7 <__lockfile>
  402feb:	41 89 c4             	mov    %eax,%r12d
	olderr = f->flags & F_ERR;
  402fee:	41 8b 45 00          	mov    0x0(%r13),%eax
  402ff2:	89 c3                	mov    %eax,%ebx
  402ff4:	83 e3 20             	and    $0x20,%ebx
	if (f->mode < 1) f->flags &= ~F_ERR;
  402ff7:	41 80 bd 8a 00 00 00 	cmpb   $0x0,0x8a(%r13)
  402ffe:	00 
	olderr = f->flags & F_ERR;
  402fff:	89 5c 24 1c          	mov    %ebx,0x1c(%rsp)
	if (f->mode < 1) f->flags &= ~F_ERR;
  403003:	7f 07                	jg     40300c <vfprintf+0xa4>
  403005:	83 e0 df             	and    $0xffffffdf,%eax
  403008:	41 89 45 00          	mov    %eax,0x0(%r13)
	unsigned char internal_buf[80], *saved_buf = 0;
  40300c:	31 ed                	xor    %ebp,%ebp
	if (!f->buf_size) {
  40300e:	49 83 7d 60 00       	cmpq   $0x0,0x60(%r13)
  403013:	75 29                	jne    40303e <vfprintf+0xd6>
		saved_buf = f->buf;
		f->wpos = f->wbase = f->buf = internal_buf;
  403015:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
		saved_buf = f->buf;
  40301a:	49 8b 6d 58          	mov    0x58(%r13),%rbp
		f->buf_size = sizeof internal_buf;
  40301e:	49 c7 45 60 50 00 00 	movq   $0x50,0x60(%r13)
  403025:	00 
		f->wpos = f->wbase = f->buf = internal_buf;
  403026:	49 89 45 58          	mov    %rax,0x58(%r13)
  40302a:	49 89 45 38          	mov    %rax,0x38(%r13)
  40302e:	49 89 45 28          	mov    %rax,0x28(%r13)
		f->wend = internal_buf + sizeof internal_buf;
  403032:	48 8d 84 24 b0 00 00 	lea    0xb0(%rsp),%rax
  403039:	00 
  40303a:	49 89 45 20          	mov    %rax,0x20(%r13)
	}
	ret = printf_core(f, fmt, &ap2, nl_arg, nl_type);
  40303e:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  403043:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  403048:	4d 89 f8             	mov    %r15,%r8
  40304b:	4c 89 f1             	mov    %r14,%rcx
  40304e:	4c 89 ef             	mov    %r13,%rdi
  403051:	e8 2e f5 ff ff       	callq  402584 <printf_core>
	if (saved_buf) {
  403056:	48 85 ed             	test   %rbp,%rbp
	ret = printf_core(f, fmt, &ap2, nl_arg, nl_type);
  403059:	89 c3                	mov    %eax,%ebx
	if (saved_buf) {
  40305b:	74 3c                	je     403099 <vfprintf+0x131>
		f->write(f, 0, 0);
  40305d:	31 d2                	xor    %edx,%edx
  40305f:	31 f6                	xor    %esi,%esi
  403061:	4c 89 ef             	mov    %r13,%rdi
  403064:	41 ff 55 48          	callq  *0x48(%r13)
		if (!f->wpos) ret = -1;
  403068:	49 83 7d 28 00       	cmpq   $0x0,0x28(%r13)
  40306d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		f->buf = saved_buf;
  403072:	49 89 6d 58          	mov    %rbp,0x58(%r13)
		f->buf_size = 0;
  403076:	49 c7 45 60 00 00 00 	movq   $0x0,0x60(%r13)
  40307d:	00 
		f->wpos = f->wbase = f->wend = 0;
  40307e:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
  403085:	00 
  403086:	49 c7 45 38 00 00 00 	movq   $0x0,0x38(%r13)
  40308d:	00 
  40308e:	49 c7 45 28 00 00 00 	movq   $0x0,0x28(%r13)
  403095:	00 
		if (!f->wpos) ret = -1;
  403096:	0f 44 d8             	cmove  %eax,%ebx
	}
	if (f->flags & F_ERR) ret = -1;
  403099:	41 8b 45 00          	mov    0x0(%r13),%eax
	f->flags |= olderr;
  40309d:	8b 6c 24 1c          	mov    0x1c(%rsp),%ebp
	if (f->flags & F_ERR) ret = -1;
  4030a1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  4030a6:	a8 20                	test   $0x20,%al
  4030a8:	0f 45 da             	cmovne %edx,%ebx
	f->flags |= olderr;
  4030ab:	09 c5                	or     %eax,%ebp
	FUNLOCK(f);
  4030ad:	45 85 e4             	test   %r12d,%r12d
	f->flags |= olderr;
  4030b0:	41 89 6d 00          	mov    %ebp,0x0(%r13)
	FUNLOCK(f);
  4030b4:	74 08                	je     4030be <vfprintf+0x156>
  4030b6:	4c 89 ef             	mov    %r13,%rdi
  4030b9:	e8 6d 1c 00 00       	callq  404d2b <__unlockfile>
	va_end(ap2);
	return ret;
}
  4030be:	48 81 c4 58 01 00 00 	add    $0x158,%rsp
  4030c5:	89 d8                	mov    %ebx,%eax
  4030c7:	5b                   	pop    %rbx
  4030c8:	5d                   	pop    %rbp
  4030c9:	41 5c                	pop    %r12
  4030cb:	41 5d                	pop    %r13
  4030cd:	41 5e                	pop    %r14
  4030cf:	41 5f                	pop    %r15
  4030d1:	c3                   	retq   
  4030d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4030d9:	00 00 00 
  4030dc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004030e0 <strchr>:
#include <string.h>

char *__strchrnul(const char *, int);

char *strchr(const char *s, int c)
{
  4030e0:	53                   	push   %rbx
  4030e1:	89 f3                	mov    %esi,%ebx
	char *r = __strchrnul(s, c);
  4030e3:	e8 18 00 00 00       	callq  403100 <__strchrnul>
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  4030e8:	38 18                	cmp    %bl,(%rax)
  4030ea:	ba 00 00 00 00       	mov    $0x0,%edx
}
  4030ef:	5b                   	pop    %rbx
	return *(unsigned char *)r == (unsigned char)c ? r : 0;
  4030f0:	48 0f 45 c2          	cmovne %rdx,%rax
}
  4030f4:	c3                   	retq   
  4030f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4030fc:	00 00 00 
  4030ff:	90                   	nop

0000000000403100 <__strchrnul>:
#define ONES ((size_t)-1/UCHAR_MAX)
#define HIGHS (ONES * (UCHAR_MAX/2+1))
#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)

char *__strchrnul(const char *s, int c)
{
  403100:	40 0f b6 f6          	movzbl %sil,%esi
  403104:	53                   	push   %rbx
  403105:	48 89 fb             	mov    %rdi,%rbx
	size_t *w, k;

	c = (unsigned char)c;
	if (!c) return (char *)s + strlen(s);
  403108:	85 f6                	test   %esi,%esi
  40310a:	0f 84 e0 00 00 00    	je     4031f0 <__strchrnul+0xf0>

	for (; (uintptr_t)s % ALIGN; s++)
  403110:	40 f6 c7 07          	test   $0x7,%dil
  403114:	74 36                	je     40314c <__strchrnul+0x4c>
		if (!*s || *(unsigned char *)s == c) return (char *)s;
  403116:	0f b6 07             	movzbl (%rdi),%eax
  403119:	84 c0                	test   %al,%al
  40311b:	0f 84 c6 00 00 00    	je     4031e7 <__strchrnul+0xe7>
  403121:	39 c6                	cmp    %eax,%esi
  403123:	75 1e                	jne    403143 <__strchrnul+0x43>
  403125:	e9 bd 00 00 00       	jmpq   4031e7 <__strchrnul+0xe7>
  40312a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  403130:	0f b6 03             	movzbl (%rbx),%eax
  403133:	84 c0                	test   %al,%al
  403135:	0f 84 ac 00 00 00    	je     4031e7 <__strchrnul+0xe7>
  40313b:	39 f0                	cmp    %esi,%eax
  40313d:	0f 84 a4 00 00 00    	je     4031e7 <__strchrnul+0xe7>
	for (; (uintptr_t)s % ALIGN; s++)
  403143:	48 83 c3 01          	add    $0x1,%rbx
  403147:	f6 c3 07             	test   $0x7,%bl
  40314a:	75 e4                	jne    403130 <__strchrnul+0x30>
	k = ONES * c;
  40314c:	48 bf 01 01 01 01 01 	movabs $0x101010101010101,%rdi
  403153:	01 01 01 
  403156:	4c 63 ce             	movslq %esi,%r9
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  403159:	48 8b 13             	mov    (%rbx),%rdx
	k = ONES * c;
  40315c:	4c 0f af cf          	imul   %rdi,%r9
	for (w = (void *)s; !HASZERO(*w) && !HASZERO(*w^k); w++);
  403160:	49 ba 80 80 80 80 80 	movabs $0x8080808080808080,%r10
  403167:	80 80 80 
  40316a:	48 89 d0             	mov    %rdx,%rax
  40316d:	48 29 f8             	sub    %rdi,%rax
  403170:	4c 89 c9             	mov    %r9,%rcx
  403173:	48 31 d1             	xor    %rdx,%rcx
  403176:	48 f7 d2             	not    %rdx
  403179:	48 21 d0             	and    %rdx,%rax
  40317c:	48 89 ca             	mov    %rcx,%rdx
  40317f:	48 f7 d1             	not    %rcx
  403182:	48 29 fa             	sub    %rdi,%rdx
  403185:	48 21 d1             	and    %rdx,%rcx
  403188:	48 09 c8             	or     %rcx,%rax
  40318b:	4c 85 d0             	test   %r10,%rax
  40318e:	75 3c                	jne    4031cc <__strchrnul+0xcc>
  403190:	48 89 d8             	mov    %rbx,%rax
  403193:	49 b8 ff fe fe fe fe 	movabs $0xfefefefefefefeff,%r8
  40319a:	fe fe fe 
  40319d:	0f 1f 00             	nopl   (%rax)
  4031a0:	48 83 c0 08          	add    $0x8,%rax
  4031a4:	48 8b 08             	mov    (%rax),%rcx
  4031a7:	4c 89 cf             	mov    %r9,%rdi
  4031aa:	4a 8d 14 01          	lea    (%rcx,%r8,1),%rdx
  4031ae:	48 31 cf             	xor    %rcx,%rdi
  4031b1:	48 f7 d1             	not    %rcx
  4031b4:	48 21 ca             	and    %rcx,%rdx
  4031b7:	4a 8d 0c 07          	lea    (%rdi,%r8,1),%rcx
  4031bb:	48 f7 d7             	not    %rdi
  4031be:	48 21 cf             	and    %rcx,%rdi
  4031c1:	48 09 fa             	or     %rdi,%rdx
  4031c4:	4c 85 d2             	test   %r10,%rdx
  4031c7:	74 d7                	je     4031a0 <__strchrnul+0xa0>
  4031c9:	48 89 c3             	mov    %rax,%rbx
	for (s = (void *)w; *s && *(unsigned char *)s != c; s++);
  4031cc:	0f b6 03             	movzbl (%rbx),%eax
  4031cf:	84 c0                	test   %al,%al
  4031d1:	75 10                	jne    4031e3 <__strchrnul+0xe3>
  4031d3:	eb 12                	jmp    4031e7 <__strchrnul+0xe7>
  4031d5:	0f 1f 00             	nopl   (%rax)
  4031d8:	48 83 c3 01          	add    $0x1,%rbx
  4031dc:	0f b6 03             	movzbl (%rbx),%eax
  4031df:	84 c0                	test   %al,%al
  4031e1:	74 04                	je     4031e7 <__strchrnul+0xe7>
  4031e3:	39 c6                	cmp    %eax,%esi
  4031e5:	75 f1                	jne    4031d8 <__strchrnul+0xd8>
  4031e7:	48 89 d8             	mov    %rbx,%rax
	return (char *)s;
}
  4031ea:	5b                   	pop    %rbx
  4031eb:	c3                   	retq   
  4031ec:	0f 1f 40 00          	nopl   0x0(%rax)
	if (!c) return (char *)s + strlen(s);
  4031f0:	e8 0b 00 00 00       	callq  403200 <strlen>
  4031f5:	48 01 d8             	add    %rbx,%rax
}
  4031f8:	5b                   	pop    %rbx
  4031f9:	c3                   	retq   
  4031fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000403200 <strlen>:

size_t strlen(const char *s)
{
	const char *a = s;
	const size_t *w;
	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
  403200:	40 f6 c7 07          	test   $0x7,%dil
  403204:	74 7a                	je     403280 <strlen+0x80>
  403206:	80 3f 00             	cmpb   $0x0,(%rdi)
  403209:	74 7a                	je     403285 <strlen+0x85>
  40320b:	48 89 f8             	mov    %rdi,%rax
  40320e:	eb 05                	jmp    403215 <strlen+0x15>
  403210:	80 38 00             	cmpb   $0x0,(%rax)
  403213:	74 67                	je     40327c <strlen+0x7c>
  403215:	48 83 c0 01          	add    $0x1,%rax
  403219:	a8 07                	test   $0x7,%al
  40321b:	75 f3                	jne    403210 <strlen+0x10>
	for (w = (const void *)s; !HASZERO(*w); w++);
  40321d:	48 8b 10             	mov    (%rax),%rdx
  403220:	49 b8 ff fe fe fe fe 	movabs $0xfefefefefefefeff,%r8
  403227:	fe fe fe 
  40322a:	48 be 80 80 80 80 80 	movabs $0x8080808080808080,%rsi
  403231:	80 80 80 
  403234:	4a 8d 0c 02          	lea    (%rdx,%r8,1),%rcx
  403238:	48 f7 d2             	not    %rdx
  40323b:	48 21 ca             	and    %rcx,%rdx
  40323e:	48 85 f2             	test   %rsi,%rdx
  403241:	75 1b                	jne    40325e <strlen+0x5e>
  403243:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  403248:	48 83 c0 08          	add    $0x8,%rax
  40324c:	48 8b 10             	mov    (%rax),%rdx
  40324f:	4a 8d 0c 02          	lea    (%rdx,%r8,1),%rcx
  403253:	48 f7 d2             	not    %rdx
  403256:	48 21 ca             	and    %rcx,%rdx
  403259:	48 85 f2             	test   %rsi,%rdx
  40325c:	74 ea                	je     403248 <strlen+0x48>
	for (s = (const void *)w; *s; s++);
  40325e:	80 38 00             	cmpb   $0x0,(%rax)
	for (w = (const void *)s; !HASZERO(*w); w++);
  403261:	48 89 c2             	mov    %rax,%rdx
	for (s = (const void *)w; *s; s++);
  403264:	74 13                	je     403279 <strlen+0x79>
  403266:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40326d:	00 00 00 
  403270:	48 83 c2 01          	add    $0x1,%rdx
  403274:	80 3a 00             	cmpb   $0x0,(%rdx)
  403277:	75 f7                	jne    403270 <strlen+0x70>
	return s-a;
  403279:	48 89 d0             	mov    %rdx,%rax
  40327c:	48 29 f8             	sub    %rdi,%rax
}
  40327f:	c3                   	retq   
	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
  403280:	48 89 f8             	mov    %rdi,%rax
  403283:	eb 98                	jmp    40321d <strlen+0x1d>
  403285:	31 c0                	xor    %eax,%eax
  403287:	c3                   	retq   
  403288:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40328f:	00 

0000000000403290 <strnlen>:
#include <string.h>

size_t strnlen(const char *s, size_t n)
{
  403290:	55                   	push   %rbp
  403291:	53                   	push   %rbx
	const char *p = memchr(s, 0, n);
  403292:	48 89 f2             	mov    %rsi,%rdx
{
  403295:	48 89 f3             	mov    %rsi,%rbx
	const char *p = memchr(s, 0, n);
  403298:	31 f6                	xor    %esi,%esi
{
  40329a:	48 89 fd             	mov    %rdi,%rbp
  40329d:	48 83 ec 08          	sub    $0x8,%rsp
	const char *p = memchr(s, 0, n);
  4032a1:	e8 2a 1f 00 00       	callq  4051d0 <memchr>
	return p ? p-s : n;
  4032a6:	48 89 c2             	mov    %rax,%rdx
  4032a9:	48 29 ea             	sub    %rbp,%rdx
  4032ac:	48 85 c0             	test   %rax,%rax
  4032af:	48 89 d8             	mov    %rbx,%rax
  4032b2:	48 0f 45 c2          	cmovne %rdx,%rax
}
  4032b6:	48 83 c4 08          	add    $0x8,%rsp
  4032ba:	5b                   	pop    %rbx
  4032bb:	5d                   	pop    %rbp
  4032bc:	c3                   	retq   

00000000004032bd <memset>:
.global memset
.type memset,@function
memset:
	movzbq %sil,%rax
  4032bd:	48 0f b6 c6          	movzbq %sil,%rax
	mov $0x101010101010101,%r8
  4032c1:	49 b8 01 01 01 01 01 	movabs $0x101010101010101,%r8
  4032c8:	01 01 01 
	imul %r8,%rax
  4032cb:	49 0f af c0          	imul   %r8,%rax

	cmp $126,%rdx
  4032cf:	48 83 fa 7e          	cmp    $0x7e,%rdx
	ja 2f
  4032d3:	77 78                	ja     40334d <memset+0x90>

	test %edx,%edx
  4032d5:	85 d2                	test   %edx,%edx
	jz 1f
  4032d7:	74 70                	je     403349 <memset+0x8c>

	mov %sil,(%rdi)
  4032d9:	40 88 37             	mov    %sil,(%rdi)
	mov %sil,-1(%rdi,%rdx)
  4032dc:	40 88 74 17 ff       	mov    %sil,-0x1(%rdi,%rdx,1)
	cmp $2,%edx
  4032e1:	83 fa 02             	cmp    $0x2,%edx
	jbe 1f
  4032e4:	76 63                	jbe    403349 <memset+0x8c>

	mov %ax,1(%rdi)
  4032e6:	66 89 47 01          	mov    %ax,0x1(%rdi)
	mov %ax,(-1-2)(%rdi,%rdx)
  4032ea:	66 89 44 17 fd       	mov    %ax,-0x3(%rdi,%rdx,1)
	cmp $6,%edx
  4032ef:	83 fa 06             	cmp    $0x6,%edx
	jbe 1f
  4032f2:	76 55                	jbe    403349 <memset+0x8c>

	mov %eax,(1+2)(%rdi)
  4032f4:	89 47 03             	mov    %eax,0x3(%rdi)
	mov %eax,(-1-2-4)(%rdi,%rdx)
  4032f7:	89 44 17 f9          	mov    %eax,-0x7(%rdi,%rdx,1)
	cmp $14,%edx
  4032fb:	83 fa 0e             	cmp    $0xe,%edx
	jbe 1f
  4032fe:	76 49                	jbe    403349 <memset+0x8c>

	mov %rax,(1+2+4)(%rdi)
  403300:	48 89 47 07          	mov    %rax,0x7(%rdi)
	mov %rax,(-1-2-4-8)(%rdi,%rdx)
  403304:	48 89 44 17 f1       	mov    %rax,-0xf(%rdi,%rdx,1)
	cmp $30,%edx
  403309:	83 fa 1e             	cmp    $0x1e,%edx
	jbe 1f
  40330c:	76 3b                	jbe    403349 <memset+0x8c>

	mov %rax,(1+2+4+8)(%rdi)
  40330e:	48 89 47 0f          	mov    %rax,0xf(%rdi)
	mov %rax,(1+2+4+8+8)(%rdi)
  403312:	48 89 47 17          	mov    %rax,0x17(%rdi)
	mov %rax,(-1-2-4-8-16)(%rdi,%rdx)
  403316:	48 89 44 17 e1       	mov    %rax,-0x1f(%rdi,%rdx,1)
	mov %rax,(-1-2-4-8-8)(%rdi,%rdx)
  40331b:	48 89 44 17 e9       	mov    %rax,-0x17(%rdi,%rdx,1)
	cmp $62,%edx
  403320:	83 fa 3e             	cmp    $0x3e,%edx
	jbe 1f
  403323:	76 24                	jbe    403349 <memset+0x8c>

	mov %rax,(1+2+4+8+16)(%rdi)
  403325:	48 89 47 1f          	mov    %rax,0x1f(%rdi)
	mov %rax,(1+2+4+8+16+8)(%rdi)
  403329:	48 89 47 27          	mov    %rax,0x27(%rdi)
	mov %rax,(1+2+4+8+16+16)(%rdi)
  40332d:	48 89 47 2f          	mov    %rax,0x2f(%rdi)
	mov %rax,(1+2+4+8+16+24)(%rdi)
  403331:	48 89 47 37          	mov    %rax,0x37(%rdi)
	mov %rax,(-1-2-4-8-16-32)(%rdi,%rdx)
  403335:	48 89 44 17 c1       	mov    %rax,-0x3f(%rdi,%rdx,1)
	mov %rax,(-1-2-4-8-16-24)(%rdi,%rdx)
  40333a:	48 89 44 17 c9       	mov    %rax,-0x37(%rdi,%rdx,1)
	mov %rax,(-1-2-4-8-16-16)(%rdi,%rdx)
  40333f:	48 89 44 17 d1       	mov    %rax,-0x2f(%rdi,%rdx,1)
	mov %rax,(-1-2-4-8-16-8)(%rdi,%rdx)
  403344:	48 89 44 17 d9       	mov    %rax,-0x27(%rdi,%rdx,1)

1:	mov %rdi,%rax
  403349:	48 89 f8             	mov    %rdi,%rax
	ret
  40334c:	c3                   	retq   

2:	test $15,%edi
  40334d:	f7 c7 0f 00 00 00    	test   $0xf,%edi
	mov %rdi,%r8
  403353:	49 89 f8             	mov    %rdi,%r8
	mov %rax,-8(%rdi,%rdx)
  403356:	48 89 44 17 f8       	mov    %rax,-0x8(%rdi,%rdx,1)
	mov %rdx,%rcx
  40335b:	48 89 d1             	mov    %rdx,%rcx
	jnz 2f
  40335e:	75 0b                	jne    40336b <memset+0xae>

1:	shr $3,%rcx
  403360:	48 c1 e9 03          	shr    $0x3,%rcx
	rep
  403364:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	stosq
	mov %r8,%rax
  403367:	4c 89 c0             	mov    %r8,%rax
	ret
  40336a:	c3                   	retq   

2:	xor %edx,%edx
  40336b:	31 d2                	xor    %edx,%edx
	sub %edi,%edx
  40336d:	29 fa                	sub    %edi,%edx
	and $15,%edx
  40336f:	83 e2 0f             	and    $0xf,%edx
	mov %rax,(%rdi)
  403372:	48 89 07             	mov    %rax,(%rdi)
	mov %rax,8(%rdi)
  403375:	48 89 47 08          	mov    %rax,0x8(%rdi)
	sub %rdx,%rcx
  403379:	48 29 d1             	sub    %rdx,%rcx
	add %rdx,%rdi
  40337c:	48 01 d7             	add    %rdx,%rdi
	jmp 1b
  40337f:	eb df                	jmp    403360 <memset+0xa3>

0000000000403381 <__lock>:
#include "pthread_impl.h"

void __lock(volatile int *l)
{
	if (libc.threads_minus_1)
  403381:	8b 05 c5 6e a0 10    	mov    0x10a06ec5(%rip),%eax        # 10e0a24c <__libc+0xc>
  403387:	85 c0                	test   %eax,%eax
  403389:	75 01                	jne    40338c <__lock+0xb>
  40338b:	c3                   	retq   
{
  40338c:	55                   	push   %rbp
  40338d:	53                   	push   %rbx
  40338e:	48 8d 6f 04          	lea    0x4(%rdi),%rbp
  403392:	48 89 fb             	mov    %rdi,%rbx
  403395:	48 83 ec 08          	sub    $0x8,%rsp
}

#define a_swap a_swap
static inline int a_swap(volatile int *p, int v)
{
	__asm__ __volatile__(
  403399:	b8 01 00 00 00       	mov    $0x1,%eax
  40339e:	87 03                	xchg   %eax,(%rbx)
		while (a_swap(l, 1)) __wait(l, l+1, 1, 1);
  4033a0:	85 c0                	test   %eax,%eax
  4033a2:	74 17                	je     4033bb <__lock+0x3a>
  4033a4:	b9 01 00 00 00       	mov    $0x1,%ecx
  4033a9:	ba 01 00 00 00       	mov    $0x1,%edx
  4033ae:	48 89 ee             	mov    %rbp,%rsi
  4033b1:	48 89 df             	mov    %rbx,%rdi
  4033b4:	e8 40 00 00 00       	callq  4033f9 <__wait>
  4033b9:	eb de                	jmp    403399 <__lock+0x18>
}
  4033bb:	58                   	pop    %rax
  4033bc:	5b                   	pop    %rbx
  4033bd:	5d                   	pop    %rbp
  4033be:	c3                   	retq   

00000000004033bf <__unlock>:

void __unlock(volatile int *l)
{
	if (l[0]) {
  4033bf:	8b 07                	mov    (%rdi),%eax
  4033c1:	85 c0                	test   %eax,%eax
  4033c3:	74 33                	je     4033f8 <__unlock+0x39>
}

#define a_store a_store
static inline void a_store(volatile int *p, int x)
{
	__asm__ __volatile__(
  4033c5:	31 c0                	xor    %eax,%eax
  4033c7:	89 07                	mov    %eax,(%rdi)
  4033c9:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		a_store(l, 0);
		if (l[1]) __wake(l, 1, 1);
  4033ce:	8b 47 04             	mov    0x4(%rdi),%eax
  4033d1:	85 c0                	test   %eax,%eax
  4033d3:	74 23                	je     4033f8 <__unlock+0x39>
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  4033d5:	41 b8 ca 00 00 00    	mov    $0xca,%r8d
  4033db:	ba 01 00 00 00       	mov    $0x1,%edx
  4033e0:	be 81 00 00 00       	mov    $0x81,%esi
  4033e5:	4c 89 c0             	mov    %r8,%rax
  4033e8:	0f 05                	syscall 
void __wait(volatile int *, volatile int *, int, int);
static inline void __wake(volatile void *addr, int cnt, int priv)
{
	if (priv) priv = FUTEX_PRIVATE;
	if (cnt<0) cnt = INT_MAX;
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
  4033ea:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  4033ee:	75 08                	jne    4033f8 <__unlock+0x39>
  4033f0:	4c 89 c0             	mov    %r8,%rax
  4033f3:	48 89 d6             	mov    %rdx,%rsi
  4033f6:	0f 05                	syscall 
  4033f8:	c3                   	retq   

00000000004033f9 <__wait>:
#include "pthread_impl.h"

void __wait(volatile int *addr, volatile int *waiters, int val, int priv)
{
	int spins=100;
	if (priv) priv = FUTEX_PRIVATE;
  4033f9:	b8 80 00 00 00       	mov    $0x80,%eax
  4033fe:	85 c9                	test   %ecx,%ecx
{
  403400:	41 54                	push   %r12
	if (priv) priv = FUTEX_PRIVATE;
  403402:	0f 45 c8             	cmovne %eax,%ecx
{
  403405:	55                   	push   %rbp
  403406:	49 89 f0             	mov    %rsi,%r8
  403409:	53                   	push   %rbx
	if (priv) priv = FUTEX_PRIVATE;
  40340a:	b8 65 00 00 00       	mov    $0x65,%eax
{
  40340f:	89 d3                	mov    %edx,%ebx
	while (spins-- && (!waiters || !*waiters)) {
  403411:	ff c8                	dec    %eax
  403413:	74 18                	je     40342d <__wait+0x34>
  403415:	4d 85 c0             	test   %r8,%r8
  403418:	75 0a                	jne    403424 <__wait+0x2b>
		if (*addr==val) a_spin();
  40341a:	8b 17                	mov    (%rdi),%edx
  40341c:	39 da                	cmp    %ebx,%edx
  40341e:	75 50                	jne    403470 <__wait+0x77>
}

#define a_spin a_spin
static inline void a_spin()
{
	__asm__ __volatile__( "pause" : : : "memory" );
  403420:	f3 90                	pause  
  403422:	eb ed                	jmp    403411 <__wait+0x18>
	while (spins-- && (!waiters || !*waiters)) {
  403424:	41 8b 10             	mov    (%r8),%edx
  403427:	85 d2                	test   %edx,%edx
  403429:	74 ef                	je     40341a <__wait+0x21>
  40342b:	eb 05                	jmp    403432 <__wait+0x39>
		else return;
	}
	if (waiters) a_inc(waiters);
  40342d:	4d 85 c0             	test   %r8,%r8
  403430:	74 04                	je     403436 <__wait+0x3d>
	__asm__ __volatile__(
  403432:	f0 41 ff 00          	lock incl (%r8)
	while (*addr==val) {
		__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS
  403436:	48 63 d3             	movslq %ebx,%rdx
  403439:	4c 63 c9             	movslq %ecx,%r9

static __inline long __syscall4(long n, long a1, long a2, long a3, long a4)
{
	unsigned long ret;
	register long r10 __asm__("r10") = a4;
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  40343c:	bd ca 00 00 00       	mov    $0xca,%ebp
  403441:	41 bc ca 00 00 00    	mov    $0xca,%r12d
	while (*addr==val) {
  403447:	8b 07                	mov    (%rdi),%eax
  403449:	39 c3                	cmp    %eax,%ebx
  40344b:	75 1a                	jne    403467 <__wait+0x6e>
	register long r10 __asm__("r10") = a4;
  40344d:	45 31 d2             	xor    %r10d,%r10d
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  403450:	48 89 e8             	mov    %rbp,%rax
  403453:	4c 89 ce             	mov    %r9,%rsi
  403456:	0f 05                	syscall 
		|| __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
  403458:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  40345c:	75 e9                	jne    403447 <__wait+0x4e>
  40345e:	31 f6                	xor    %esi,%esi
  403460:	4c 89 e0             	mov    %r12,%rax
  403463:	0f 05                	syscall 
  403465:	eb e0                	jmp    403447 <__wait+0x4e>
	}
	if (waiters) a_dec(waiters);
  403467:	4d 85 c0             	test   %r8,%r8
  40346a:	74 04                	je     403470 <__wait+0x77>
	__asm__ __volatile__(
  40346c:	f0 41 ff 08          	lock decl (%r8)
}
  403470:	5b                   	pop    %rbx
  403471:	5d                   	pop    %rbp
  403472:	41 5c                	pop    %r12
  403474:	c3                   	retq   

0000000000403475 <gettimeofday>:
#include "syscall.h"

int gettimeofday(struct timeval *restrict tv, void *restrict tz)
{
	struct timespec ts;
	if (!tv) return 0;
  403475:	48 85 ff             	test   %rdi,%rdi
  403478:	74 33                	je     4034ad <gettimeofday+0x38>
{
  40347a:	53                   	push   %rbx
  40347b:	48 89 fb             	mov    %rdi,%rbx
	clock_gettime(CLOCK_REALTIME, &ts);
  40347e:	31 ff                	xor    %edi,%edi
{
  403480:	48 83 ec 10          	sub    $0x10,%rsp
	clock_gettime(CLOCK_REALTIME, &ts);
  403484:	48 89 e6             	mov    %rsp,%rsi
  403487:	e8 cb 1e 00 00       	callq  405357 <__clock_gettime>
	tv->tv_sec = ts.tv_sec;
  40348c:	48 8b 04 24          	mov    (%rsp),%rax
	tv->tv_usec = (int)ts.tv_nsec / 1000;
  403490:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
	tv->tv_sec = ts.tv_sec;
  403495:	48 89 03             	mov    %rax,(%rbx)
	tv->tv_usec = (int)ts.tv_nsec / 1000;
  403498:	8b 44 24 08          	mov    0x8(%rsp),%eax
  40349c:	99                   	cltd   
  40349d:	f7 f9                	idiv   %ecx
  40349f:	48 98                	cltq   
  4034a1:	48 89 43 08          	mov    %rax,0x8(%rbx)
	return 0;
}
  4034a5:	48 83 c4 10          	add    $0x10,%rsp
  4034a9:	31 c0                	xor    %eax,%eax
  4034ab:	5b                   	pop    %rbx
  4034ac:	c3                   	retq   
  4034ad:	31 c0                	xor    %eax,%eax
  4034af:	c3                   	retq   

00000000004034b0 <__errno_location>:
static inline struct pthread *__pthread_self()
{
	struct pthread *self;
	__asm__ __volatile__ ("mov %%fs:0,%0" : "=r" (self) );
  4034b0:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  4034b7:	00 00 
#include "pthread_impl.h"

int *__errno_location(void)
{
	return &__pthread_self()->errno_val;
  4034b9:	48 83 c0 44          	add    $0x44,%rax
}
  4034bd:	c3                   	retq   

00000000004034be <__strerror_l>:
	 * historical typo, so we just remap it. */
	if (EDQUOT==1133) {
		if (e==109) e=-1;
		else if (e==EDQUOT) e=109;
	}
	for (i=0; errid[i] && errid[i] != e; i++);
  4034be:	4c 8d 05 1b 36 00 00 	lea    0x361b(%rip),%r8        # 406ae0 <errid>
  4034c5:	31 d2                	xor    %edx,%edx
  4034c7:	41 0f b6 04 10       	movzbl (%r8,%rdx,1),%eax
  4034cc:	89 d1                	mov    %edx,%ecx
  4034ce:	84 c0                	test   %al,%al
  4034d0:	74 07                	je     4034d9 <__strerror_l+0x1b>
  4034d2:	48 ff c2             	inc    %rdx
  4034d5:	39 f8                	cmp    %edi,%eax
  4034d7:	75 ee                	jne    4034c7 <__strerror_l+0x9>
  4034d9:	48 8d 3d e0 2e 00 00 	lea    0x2ee0(%rip),%rdi        # 4063c0 <errmsg>
	for (s=errmsg; i; s++, i--) for (; *s; s++);
  4034e0:	85 c9                	test   %ecx,%ecx
  4034e2:	74 0d                	je     4034f1 <__strerror_l+0x33>
  4034e4:	80 3f 00             	cmpb   $0x0,(%rdi)
  4034e7:	48 8d 7f 01          	lea    0x1(%rdi),%rdi
  4034eb:	75 f7                	jne    4034e4 <__strerror_l+0x26>
  4034ed:	ff c9                	dec    %ecx
  4034ef:	eb ef                	jmp    4034e0 <__strerror_l+0x22>
	return (char *)LCTRANS(s, LC_MESSAGES, loc);
  4034f1:	48 8b 76 28          	mov    0x28(%rsi),%rsi
  4034f5:	e9 62 00 00 00       	jmpq   40355c <__lctrans>

00000000004034fa <strerror>:
  4034fa:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  403501:	00 00 
}

char *strerror(int e)
{
	return __strerror_l(e, CURRENT_LOCALE);
  403503:	48 8b b0 c8 00 00 00 	mov    0xc8(%rax),%rsi
  40350a:	e9 af ff ff ff       	jmpq   4034be <__strerror_l>

000000000040350f <_Exit>:
#include <stdlib.h>
#include "syscall.h"

_Noreturn void _Exit(int ec)
{
	__syscall(SYS_exit_group, ec);
  40350f:	48 63 ff             	movslq %edi,%rdi
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
  403512:	b8 e7 00 00 00       	mov    $0xe7,%eax
  403517:	0f 05                	syscall 
  403519:	ba 3c 00 00 00       	mov    $0x3c,%edx
  40351e:	48 89 d0             	mov    %rdx,%rax
  403521:	0f 05                	syscall 
  403523:	eb f9                	jmp    40351e <_Exit+0xf>
  403525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40352c:	00 00 00 
  40352f:	90                   	nop

0000000000403530 <__syscall_ret>:
#include <errno.h>
#include "syscall.h"

long __syscall_ret(unsigned long r)
{
	if (r > -4096UL) {
  403530:	48 81 ff 00 f0 ff ff 	cmp    $0xfffffffffffff000,%rdi
  403537:	77 07                	ja     403540 <__syscall_ret+0x10>
		errno = -r;
		return -1;
	}
	return r;
  403539:	48 89 f8             	mov    %rdi,%rax
  40353c:	c3                   	retq   
  40353d:	0f 1f 00             	nopl   (%rax)
{
  403540:	53                   	push   %rbx
  403541:	48 89 fb             	mov    %rdi,%rbx
		errno = -r;
  403544:	e8 67 ff ff ff       	callq  4034b0 <__errno_location>
  403549:	89 df                	mov    %ebx,%edi
  40354b:	f7 df                	neg    %edi
  40354d:	89 38                	mov    %edi,(%rax)
		return -1;
  40354f:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
}
  403556:	5b                   	pop    %rbx
  403557:	c3                   	retq   

0000000000403558 <__lctrans_impl>:
#include <locale.h>
#include "locale_impl.h"
#include "libc.h"

static const char *dummy(const char *msg, const struct __locale_map *lm)
{
  403558:	48 89 f8             	mov    %rdi,%rax
	return msg;
}
  40355b:	c3                   	retq   

000000000040355c <__lctrans>:

weak_alias(dummy, __lctrans_impl);

const char *__lctrans(const char *msg, const struct __locale_map *lm)
{
	return __lctrans_impl(msg, lm);
  40355c:	e9 f7 ff ff ff       	jmpq   403558 <__lctrans_impl>

0000000000403561 <__lctrans_cur>:
  403561:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  403568:	00 00 
}

const char *__lctrans_cur(const char *msg)
{
	return __lctrans_impl(msg, CURRENT_LOCALE->cat[LC_MESSAGES]);
  40356a:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  403571:	48 8b 70 28          	mov    0x28(%rax),%rsi
  403575:	e9 de ff ff ff       	jmpq   403558 <__lctrans_impl>
  40357a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000403580 <alloc_fwd>:
	c->csize |= C_INUSE;
	NEXT_CHUNK(c)->psize |= C_INUSE;
}

static int alloc_fwd(struct chunk *c)
{
  403580:	41 57                	push   %r15
  403582:	41 56                	push   %r14
  403584:	41 55                	push   %r13
  403586:	41 54                	push   %r12
  403588:	55                   	push   %rbp
  403589:	53                   	push   %rbx
  40358a:	48 83 ec 18          	sub    $0x18,%rsp
  40358e:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  403593:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	lock(mal.bins[i].lock);
  403598:	4c 8d 35 c1 45 20 00 	lea    0x2045c1(%rip),%r14        # 607b60 <mal>
  40359f:	48 8b 68 08          	mov    0x8(%rax),%rbp
	int i;
	size_t k;
	while (!((k=c->csize) & C_INUSE)) {
  4035a3:	40 f6 c5 01          	test   $0x1,%bpl
  4035a7:	0f 85 af 00 00 00    	jne    40365c <alloc_fwd+0xdc>
  4035ad:	0f 1f 00             	nopl   (%rax)
	x = x / SIZE_ALIGN - 1;
  4035b0:	48 89 e8             	mov    %rbp,%rax
  4035b3:	48 c1 e8 05          	shr    $0x5,%rax
  4035b7:	48 83 e8 01          	sub    $0x1,%rax
	if (x <= 32) return x;
  4035bb:	48 83 f8 20          	cmp    $0x20,%rax
  4035bf:	0f 87 db 00 00 00    	ja     4036a0 <alloc_fwd+0x120>
  4035c5:	4c 8d 24 40          	lea    (%rax,%rax,2),%r12
  4035c9:	89 44 24 04          	mov    %eax,0x4(%rsp)
  4035cd:	4c 63 e8             	movslq %eax,%r13
  4035d0:	49 c1 e4 03          	shl    $0x3,%r12
  4035d4:	4d 8d 44 24 08       	lea    0x8(%r12),%r8
	if (libc.threads_minus_1)
  4035d9:	8b 05 6d 6c a0 10    	mov    0x10a06c6d(%rip),%eax        # 10e0a24c <__libc+0xc>
	lock(mal.bins[i].lock);
  4035df:	4f 8d 3c 06          	lea    (%r14,%r8,1),%r15
	if (libc.threads_minus_1)
  4035e3:	85 c0                	test   %eax,%eax
  4035e5:	0f 84 85 00 00 00    	je     403670 <alloc_fwd+0xf0>
	__asm__ __volatile__(
  4035eb:	b8 01 00 00 00       	mov    $0x1,%eax
  4035f0:	41 87 07             	xchg   %eax,(%r15)
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
  4035f3:	85 c0                	test   %eax,%eax
  4035f5:	49 8d 5f 04          	lea    0x4(%r15),%rbx
  4035f9:	74 26                	je     403621 <alloc_fwd+0xa1>
  4035fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  403600:	b9 01 00 00 00       	mov    $0x1,%ecx
  403605:	ba 01 00 00 00       	mov    $0x1,%edx
  40360a:	48 89 de             	mov    %rbx,%rsi
  40360d:	4c 89 ff             	mov    %r15,%rdi
  403610:	e8 e4 fd ff ff       	callq  4033f9 <__wait>
  403615:	ba 01 00 00 00       	mov    $0x1,%edx
  40361a:	41 87 17             	xchg   %edx,(%r15)
  40361d:	85 d2                	test   %edx,%edx
  40361f:	75 df                	jne    403600 <alloc_fwd+0x80>
	if (!mal.bins[i].head)
  403621:	4b 8d 44 6d 00       	lea    0x0(%r13,%r13,2),%rax
  403626:	49 83 7c c6 10 00    	cmpq   $0x0,0x10(%r14,%rax,8)
  40362c:	0f 84 03 02 00 00    	je     403835 <alloc_fwd+0x2b5>
  403632:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  403637:	48 8b 40 08          	mov    0x8(%rax),%rax
		i = bin_index(k);
		lock_bin(i);
		if (c->csize == k) {
  40363b:	48 39 c5             	cmp    %rax,%rbp
  40363e:	0f 84 eb 00 00 00    	je     40372f <alloc_fwd+0x1af>
	if (lk[0]) {
  403644:	41 8b 17             	mov    (%r15),%edx
  403647:	85 d2                	test   %edx,%edx
  403649:	0f 85 6e 01 00 00    	jne    4037bd <alloc_fwd+0x23d>
  40364f:	48 89 c5             	mov    %rax,%rbp
	while (!((k=c->csize) & C_INUSE)) {
  403652:	40 f6 c5 01          	test   $0x1,%bpl
  403656:	0f 84 54 ff ff ff    	je     4035b0 <alloc_fwd+0x30>
			return 1;
		}
		unlock_bin(i);
	}
	return 0;
}
  40365c:	48 83 c4 18          	add    $0x18,%rsp
	return 0;
  403660:	31 c0                	xor    %eax,%eax
}
  403662:	5b                   	pop    %rbx
  403663:	5d                   	pop    %rbp
  403664:	41 5c                	pop    %r12
  403666:	41 5d                	pop    %r13
  403668:	41 5e                	pop    %r14
  40366a:	41 5f                	pop    %r15
  40366c:	c3                   	retq   
  40366d:	0f 1f 00             	nopl   (%rax)
	if (!mal.bins[i].head)
  403670:	4b 8d 44 6d 00       	lea    0x0(%r13,%r13,2),%rax
  403675:	49 83 7c c6 10 00    	cmpq   $0x0,0x10(%r14,%rax,8)
  40367b:	0f 85 ae 00 00 00    	jne    40372f <alloc_fwd+0x1af>
  403681:	48 89 e8             	mov    %rbp,%rax
		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
  403684:	4b 8d 54 6d 00       	lea    0x0(%r13,%r13,2),%rdx
  403689:	4d 01 f4             	add    %r14,%r12
  40368c:	49 8d 14 d6          	lea    (%r14,%rdx,8),%rdx
  403690:	4c 89 62 18          	mov    %r12,0x18(%rdx)
  403694:	4c 89 62 10          	mov    %r12,0x10(%rdx)
  403698:	eb a1                	jmp    40363b <alloc_fwd+0xbb>
  40369a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	if (x < 512) return bin_tab[x/8-4];
  4036a0:	48 3d ff 01 00 00    	cmp    $0x1ff,%rax
  4036a6:	77 30                	ja     4036d8 <alloc_fwd+0x158>
  4036a8:	48 8d 3d 91 34 00 00 	lea    0x3491(%rip),%rdi        # 406b40 <bin_tab>
  4036af:	48 c1 e8 03          	shr    $0x3,%rax
  4036b3:	0f b6 74 07 fc       	movzbl -0x4(%rdi,%rax,1),%esi
  4036b8:	4c 8d 24 76          	lea    (%rsi,%rsi,2),%r12
  4036bc:	89 74 24 04          	mov    %esi,0x4(%rsp)
  4036c0:	4c 63 ee             	movslq %esi,%r13
  4036c3:	49 c1 e4 03          	shl    $0x3,%r12
  4036c7:	4d 8d 44 24 08       	lea    0x8(%r12),%r8
  4036cc:	e9 08 ff ff ff       	jmpq   4035d9 <alloc_fwd+0x59>
  4036d1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	if (x > 0x1c00) return 63;
  4036d8:	48 3d 00 1c 00 00    	cmp    $0x1c00,%rax
  4036de:	77 30                	ja     403710 <alloc_fwd+0x190>
	return bin_tab[x/128-4] + 16;
  4036e0:	48 8d 1d 59 34 00 00 	lea    0x3459(%rip),%rbx        # 406b40 <bin_tab>
  4036e7:	48 c1 e8 07          	shr    $0x7,%rax
  4036eb:	44 0f b6 7c 03 fc    	movzbl -0x4(%rbx,%rax,1),%r15d
  4036f1:	41 8d 47 10          	lea    0x10(%r15),%eax
  4036f5:	4c 63 e8             	movslq %eax,%r13
  4036f8:	89 44 24 04          	mov    %eax,0x4(%rsp)
  4036fc:	4f 8d 64 6d 00       	lea    0x0(%r13,%r13,2),%r12
  403701:	49 c1 e4 03          	shl    $0x3,%r12
  403705:	4d 8d 44 24 08       	lea    0x8(%r12),%r8
  40370a:	e9 ca fe ff ff       	jmpq   4035d9 <alloc_fwd+0x59>
  40370f:	90                   	nop
	if (x > 0x1c00) return 63;
  403710:	41 bc e8 05 00 00    	mov    $0x5e8,%r12d
  403716:	41 b8 f0 05 00 00    	mov    $0x5f0,%r8d
  40371c:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%rsp)
  403723:	00 
  403724:	41 bd 3f 00 00 00    	mov    $0x3f,%r13d
  40372a:	e9 aa fe ff ff       	jmpq   4035d9 <alloc_fwd+0x59>
	if (c->prev == c->next)
  40372f:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  403734:	48 8b 43 18          	mov    0x18(%rbx),%rax
  403738:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  40373c:	48 39 d0             	cmp    %rdx,%rax
  40373f:	0f 84 c3 00 00 00    	je     403808 <alloc_fwd+0x288>
	c->next->prev = c->prev;
  403745:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
	c->prev->next = c->next;
  40374a:	48 89 50 10          	mov    %rdx,0x10(%rax)
	c->next->prev = c->prev;
  40374e:	48 8b 57 10          	mov    0x10(%rdi),%rdx
  403752:	48 89 42 18          	mov    %rax,0x18(%rdx)
	c->csize |= C_INUSE;
  403756:	48 89 e8             	mov    %rbp,%rax
	NEXT_CHUNK(c)->psize |= C_INUSE;
  403759:	48 83 e5 fe          	and    $0xfffffffffffffffe,%rbp
	c->csize |= C_INUSE;
  40375d:	48 83 c8 01          	or     $0x1,%rax
  403761:	48 89 47 08          	mov    %rax,0x8(%rdi)
	if (lk[0]) {
  403765:	41 8b 07             	mov    (%r15),%eax
	NEXT_CHUNK(c)->psize |= C_INUSE;
  403768:	48 83 0c 2f 01       	orq    $0x1,(%rdi,%rbp,1)
	if (lk[0]) {
  40376d:	85 c0                	test   %eax,%eax
  40376f:	74 38                	je     4037a9 <alloc_fwd+0x229>
	__asm__ __volatile__(
  403771:	31 c0                	xor    %eax,%eax
  403773:	41 89 07             	mov    %eax,(%r15)
  403776:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  40377b:	41 8b 47 04          	mov    0x4(%r15),%eax
  40377f:	85 c0                	test   %eax,%eax
  403781:	74 26                	je     4037a9 <alloc_fwd+0x229>
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  403783:	41 b9 ca 00 00 00    	mov    $0xca,%r9d
  403789:	ba 01 00 00 00       	mov    $0x1,%edx
  40378e:	be 81 00 00 00       	mov    $0x81,%esi
  403793:	4c 89 c8             	mov    %r9,%rax
  403796:	4c 89 ff             	mov    %r15,%rdi
  403799:	0f 05                	syscall 
  40379b:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  40379f:	75 08                	jne    4037a9 <alloc_fwd+0x229>
  4037a1:	4c 89 c8             	mov    %r9,%rax
  4037a4:	48 89 d6             	mov    %rdx,%rsi
  4037a7:	0f 05                	syscall 
}
  4037a9:	48 83 c4 18          	add    $0x18,%rsp
			return 1;
  4037ad:	b8 01 00 00 00       	mov    $0x1,%eax
}
  4037b2:	5b                   	pop    %rbx
  4037b3:	5d                   	pop    %rbp
  4037b4:	41 5c                	pop    %r12
  4037b6:	41 5d                	pop    %r13
  4037b8:	41 5e                	pop    %r14
  4037ba:	41 5f                	pop    %r15
  4037bc:	c3                   	retq   
  4037bd:	31 c0                	xor    %eax,%eax
  4037bf:	41 89 07             	mov    %eax,(%r15)
  4037c2:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  4037c7:	41 8b 47 04          	mov    0x4(%r15),%eax
  4037cb:	85 c0                	test   %eax,%eax
  4037cd:	0f 84 c0 fd ff ff    	je     403593 <alloc_fwd+0x13>
  4037d3:	41 b9 ca 00 00 00    	mov    $0xca,%r9d
  4037d9:	ba 01 00 00 00       	mov    $0x1,%edx
  4037de:	be 81 00 00 00       	mov    $0x81,%esi
  4037e3:	4c 89 c8             	mov    %r9,%rax
  4037e6:	4c 89 ff             	mov    %r15,%rdi
  4037e9:	0f 05                	syscall 
  4037eb:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  4037ef:	0f 85 9e fd ff ff    	jne    403593 <alloc_fwd+0x13>
  4037f5:	4c 89 c8             	mov    %r9,%rax
  4037f8:	48 89 d6             	mov    %rdx,%rsi
  4037fb:	0f 05                	syscall 
  4037fd:	e9 91 fd ff ff       	jmpq   403593 <alloc_fwd+0x13>
  403802:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
		a_and_64(&mal.binmap, ~(1ULL<<i));
  403808:	0f b6 4c 24 04       	movzbl 0x4(%rsp),%ecx
  40380d:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
  403814:	48 d3 c0             	rol    %cl,%rax
	__asm__ __volatile(
  403817:	f0 48 21 05 41 43 20 	lock and %rax,0x204341(%rip)        # 607b60 <mal>
  40381e:	00 
  40381f:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  403824:	48 8b 43 18          	mov    0x18(%rbx),%rax
  403828:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  40382c:	48 8b 6b 08          	mov    0x8(%rbx),%rbp
  403830:	e9 10 ff ff ff       	jmpq   403745 <alloc_fwd+0x1c5>
  403835:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  40383a:	48 8b 40 08          	mov    0x8(%rax),%rax
  40383e:	e9 41 fe ff ff       	jmpq   403684 <alloc_fwd+0x104>
  403843:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40384a:	00 00 00 
  40384d:	0f 1f 00             	nopl   (%rax)

0000000000403850 <alloc_rev>:

static int alloc_rev(struct chunk *c)
{
  403850:	41 57                	push   %r15
  403852:	41 56                	push   %r14
  403854:	41 55                	push   %r13
  403856:	41 54                	push   %r12
  403858:	55                   	push   %rbp
  403859:	53                   	push   %rbx
  40385a:	48 83 ec 18          	sub    $0x18,%rsp
  40385e:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  403863:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	lock(mal.bins[i].lock);
  403868:	4c 8d 35 f1 42 20 00 	lea    0x2042f1(%rip),%r14        # 607b60 <mal>
  40386f:	48 8b 28             	mov    (%rax),%rbp
	int i;
	size_t k;
	while (!((k=c->psize) & C_INUSE)) {
  403872:	40 f6 c5 01          	test   $0x1,%bpl
  403876:	0f 85 af 00 00 00    	jne    40392b <alloc_rev+0xdb>
  40387c:	0f 1f 40 00          	nopl   0x0(%rax)
	x = x / SIZE_ALIGN - 1;
  403880:	48 89 e8             	mov    %rbp,%rax
  403883:	48 c1 e8 05          	shr    $0x5,%rax
  403887:	48 83 e8 01          	sub    $0x1,%rax
	if (x <= 32) return x;
  40388b:	48 83 f8 20          	cmp    $0x20,%rax
  40388f:	0f 87 db 00 00 00    	ja     403970 <alloc_rev+0x120>
  403895:	4c 8d 24 40          	lea    (%rax,%rax,2),%r12
  403899:	89 44 24 04          	mov    %eax,0x4(%rsp)
  40389d:	4c 63 e8             	movslq %eax,%r13
  4038a0:	49 c1 e4 03          	shl    $0x3,%r12
  4038a4:	4d 8d 44 24 08       	lea    0x8(%r12),%r8
	if (libc.threads_minus_1)
  4038a9:	8b 05 9d 69 a0 10    	mov    0x10a0699d(%rip),%eax        # 10e0a24c <__libc+0xc>
	lock(mal.bins[i].lock);
  4038af:	4f 8d 3c 06          	lea    (%r14,%r8,1),%r15
	if (libc.threads_minus_1)
  4038b3:	85 c0                	test   %eax,%eax
  4038b5:	0f 84 85 00 00 00    	je     403940 <alloc_rev+0xf0>
	__asm__ __volatile__(
  4038bb:	b8 01 00 00 00       	mov    $0x1,%eax
  4038c0:	41 87 07             	xchg   %eax,(%r15)
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
  4038c3:	85 c0                	test   %eax,%eax
  4038c5:	49 8d 5f 04          	lea    0x4(%r15),%rbx
  4038c9:	74 26                	je     4038f1 <alloc_rev+0xa1>
  4038cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4038d0:	b9 01 00 00 00       	mov    $0x1,%ecx
  4038d5:	ba 01 00 00 00       	mov    $0x1,%edx
  4038da:	48 89 de             	mov    %rbx,%rsi
  4038dd:	4c 89 ff             	mov    %r15,%rdi
  4038e0:	e8 14 fb ff ff       	callq  4033f9 <__wait>
  4038e5:	ba 01 00 00 00       	mov    $0x1,%edx
  4038ea:	41 87 17             	xchg   %edx,(%r15)
  4038ed:	85 d2                	test   %edx,%edx
  4038ef:	75 df                	jne    4038d0 <alloc_rev+0x80>
	if (!mal.bins[i].head)
  4038f1:	4b 8d 44 6d 00       	lea    0x0(%r13,%r13,2),%rax
  4038f6:	49 83 7c c6 10 00    	cmpq   $0x0,0x10(%r14,%rax,8)
  4038fc:	0f 84 02 02 00 00    	je     403b04 <alloc_rev+0x2b4>
  403902:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  403907:	48 8b 00             	mov    (%rax),%rax
		i = bin_index(k);
		lock_bin(i);
		if (c->psize == k) {
  40390a:	48 39 c5             	cmp    %rax,%rbp
  40390d:	0f 84 ec 00 00 00    	je     4039ff <alloc_rev+0x1af>
	if (lk[0]) {
  403913:	41 8b 17             	mov    (%r15),%edx
  403916:	85 d2                	test   %edx,%edx
  403918:	0f 85 75 01 00 00    	jne    403a93 <alloc_rev+0x243>
  40391e:	48 89 c5             	mov    %rax,%rbp
	while (!((k=c->psize) & C_INUSE)) {
  403921:	40 f6 c5 01          	test   $0x1,%bpl
  403925:	0f 84 55 ff ff ff    	je     403880 <alloc_rev+0x30>
			return 1;
		}
		unlock_bin(i);
	}
	return 0;
}
  40392b:	48 83 c4 18          	add    $0x18,%rsp
	return 0;
  40392f:	31 c0                	xor    %eax,%eax
}
  403931:	5b                   	pop    %rbx
  403932:	5d                   	pop    %rbp
  403933:	41 5c                	pop    %r12
  403935:	41 5d                	pop    %r13
  403937:	41 5e                	pop    %r14
  403939:	41 5f                	pop    %r15
  40393b:	c3                   	retq   
  40393c:	0f 1f 40 00          	nopl   0x0(%rax)
	if (!mal.bins[i].head)
  403940:	4b 8d 44 6d 00       	lea    0x0(%r13,%r13,2),%rax
  403945:	49 83 7c c6 10 00    	cmpq   $0x0,0x10(%r14,%rax,8)
  40394b:	0f 85 ae 00 00 00    	jne    4039ff <alloc_rev+0x1af>
  403951:	48 89 e8             	mov    %rbp,%rax
		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
  403954:	4b 8d 54 6d 00       	lea    0x0(%r13,%r13,2),%rdx
  403959:	4d 01 f4             	add    %r14,%r12
  40395c:	49 8d 14 d6          	lea    (%r14,%rdx,8),%rdx
  403960:	4c 89 62 18          	mov    %r12,0x18(%rdx)
  403964:	4c 89 62 10          	mov    %r12,0x10(%rdx)
  403968:	eb a0                	jmp    40390a <alloc_rev+0xba>
  40396a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	if (x < 512) return bin_tab[x/8-4];
  403970:	48 3d ff 01 00 00    	cmp    $0x1ff,%rax
  403976:	77 30                	ja     4039a8 <alloc_rev+0x158>
  403978:	48 8d 0d c1 31 00 00 	lea    0x31c1(%rip),%rcx        # 406b40 <bin_tab>
  40397f:	48 c1 e8 03          	shr    $0x3,%rax
  403983:	0f b6 7c 01 fc       	movzbl -0x4(%rcx,%rax,1),%edi
  403988:	4c 8d 24 7f          	lea    (%rdi,%rdi,2),%r12
  40398c:	89 7c 24 04          	mov    %edi,0x4(%rsp)
  403990:	4c 63 ef             	movslq %edi,%r13
  403993:	49 c1 e4 03          	shl    $0x3,%r12
  403997:	4d 8d 44 24 08       	lea    0x8(%r12),%r8
  40399c:	e9 08 ff ff ff       	jmpq   4038a9 <alloc_rev+0x59>
  4039a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	if (x > 0x1c00) return 63;
  4039a8:	48 3d 00 1c 00 00    	cmp    $0x1c00,%rax
  4039ae:	77 30                	ja     4039e0 <alloc_rev+0x190>
	return bin_tab[x/128-4] + 16;
  4039b0:	48 8d 1d 89 31 00 00 	lea    0x3189(%rip),%rbx        # 406b40 <bin_tab>
  4039b7:	48 c1 e8 07          	shr    $0x7,%rax
  4039bb:	44 0f b6 7c 03 fc    	movzbl -0x4(%rbx,%rax,1),%r15d
  4039c1:	41 8d 47 10          	lea    0x10(%r15),%eax
  4039c5:	4c 63 e8             	movslq %eax,%r13
  4039c8:	89 44 24 04          	mov    %eax,0x4(%rsp)
  4039cc:	4f 8d 64 6d 00       	lea    0x0(%r13,%r13,2),%r12
  4039d1:	49 c1 e4 03          	shl    $0x3,%r12
  4039d5:	4d 8d 44 24 08       	lea    0x8(%r12),%r8
  4039da:	e9 ca fe ff ff       	jmpq   4038a9 <alloc_rev+0x59>
  4039df:	90                   	nop
	if (x > 0x1c00) return 63;
  4039e0:	41 bc e8 05 00 00    	mov    $0x5e8,%r12d
  4039e6:	41 b8 f0 05 00 00    	mov    $0x5f0,%r8d
  4039ec:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%rsp)
  4039f3:	00 
  4039f4:	41 bd 3f 00 00 00    	mov    $0x3f,%r13d
  4039fa:	e9 aa fe ff ff       	jmpq   4038a9 <alloc_rev+0x59>
			unbin(PREV_CHUNK(c), i);
  4039ff:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  403a04:	48 83 e5 fe          	and    $0xfffffffffffffffe,%rbp
  403a08:	48 29 e8             	sub    %rbp,%rax
	if (c->prev == c->next)
  403a0b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  403a0f:	48 8b 48 10          	mov    0x10(%rax),%rcx
  403a13:	48 39 ca             	cmp    %rcx,%rdx
  403a16:	0f 84 c4 00 00 00    	je     403ae0 <alloc_rev+0x290>
	c->prev->next = c->next;
  403a1c:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
	c->next->prev = c->prev;
  403a20:	48 8b 48 10          	mov    0x10(%rax),%rcx
  403a24:	48 89 51 18          	mov    %rdx,0x18(%rcx)
	c->csize |= C_INUSE;
  403a28:	48 8b 50 08          	mov    0x8(%rax),%rdx
  403a2c:	48 89 d1             	mov    %rdx,%rcx
	NEXT_CHUNK(c)->psize |= C_INUSE;
  403a2f:	48 83 e2 fe          	and    $0xfffffffffffffffe,%rdx
	c->csize |= C_INUSE;
  403a33:	48 83 c9 01          	or     $0x1,%rcx
  403a37:	48 89 48 08          	mov    %rcx,0x8(%rax)
	NEXT_CHUNK(c)->psize |= C_INUSE;
  403a3b:	48 83 0c 10 01       	orq    $0x1,(%rax,%rdx,1)
	if (lk[0]) {
  403a40:	41 8b 07             	mov    (%r15),%eax
  403a43:	85 c0                	test   %eax,%eax
  403a45:	74 38                	je     403a7f <alloc_rev+0x22f>
	__asm__ __volatile__(
  403a47:	31 c0                	xor    %eax,%eax
  403a49:	41 89 07             	mov    %eax,(%r15)
  403a4c:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  403a51:	41 8b 47 04          	mov    0x4(%r15),%eax
  403a55:	85 c0                	test   %eax,%eax
  403a57:	74 26                	je     403a7f <alloc_rev+0x22f>
  403a59:	41 b9 ca 00 00 00    	mov    $0xca,%r9d
  403a5f:	ba 01 00 00 00       	mov    $0x1,%edx
  403a64:	be 81 00 00 00       	mov    $0x81,%esi
  403a69:	4c 89 c8             	mov    %r9,%rax
  403a6c:	4c 89 ff             	mov    %r15,%rdi
  403a6f:	0f 05                	syscall 
  403a71:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  403a75:	75 08                	jne    403a7f <alloc_rev+0x22f>
  403a77:	4c 89 c8             	mov    %r9,%rax
  403a7a:	48 89 d6             	mov    %rdx,%rsi
  403a7d:	0f 05                	syscall 
}
  403a7f:	48 83 c4 18          	add    $0x18,%rsp
			return 1;
  403a83:	b8 01 00 00 00       	mov    $0x1,%eax
}
  403a88:	5b                   	pop    %rbx
  403a89:	5d                   	pop    %rbp
  403a8a:	41 5c                	pop    %r12
  403a8c:	41 5d                	pop    %r13
  403a8e:	41 5e                	pop    %r14
  403a90:	41 5f                	pop    %r15
  403a92:	c3                   	retq   
  403a93:	31 c0                	xor    %eax,%eax
  403a95:	41 89 07             	mov    %eax,(%r15)
  403a98:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  403a9d:	41 8b 47 04          	mov    0x4(%r15),%eax
  403aa1:	85 c0                	test   %eax,%eax
  403aa3:	0f 84 ba fd ff ff    	je     403863 <alloc_rev+0x13>
  403aa9:	41 b9 ca 00 00 00    	mov    $0xca,%r9d
  403aaf:	ba 01 00 00 00       	mov    $0x1,%edx
  403ab4:	be 81 00 00 00       	mov    $0x81,%esi
  403ab9:	4c 89 c8             	mov    %r9,%rax
  403abc:	4c 89 ff             	mov    %r15,%rdi
  403abf:	0f 05                	syscall 
  403ac1:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  403ac5:	0f 85 98 fd ff ff    	jne    403863 <alloc_rev+0x13>
  403acb:	4c 89 c8             	mov    %r9,%rax
  403ace:	48 89 d6             	mov    %rdx,%rsi
  403ad1:	0f 05                	syscall 
  403ad3:	e9 8b fd ff ff       	jmpq   403863 <alloc_rev+0x13>
  403ad8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  403adf:	00 
		a_and_64(&mal.binmap, ~(1ULL<<i));
  403ae0:	0f b6 4c 24 04       	movzbl 0x4(%rsp),%ecx
  403ae5:	48 c7 c2 fe ff ff ff 	mov    $0xfffffffffffffffe,%rdx
  403aec:	48 d3 c2             	rol    %cl,%rdx
	__asm__ __volatile(
  403aef:	f0 48 21 15 69 40 20 	lock and %rdx,0x204069(%rip)        # 607b60 <mal>
  403af6:	00 
  403af7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  403afb:	48 8b 48 10          	mov    0x10(%rax),%rcx
  403aff:	e9 18 ff ff ff       	jmpq   403a1c <alloc_rev+0x1cc>
  403b04:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  403b09:	48 8b 00             	mov    (%rax),%rax
  403b0c:	e9 43 fe ff ff       	jmpq   403954 <alloc_rev+0x104>
  403b11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  403b18:	00 00 00 
  403b1b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000403b20 <free>:
	struct chunk *self, *next;
	size_t final_size, new_size, size;
	int reclaim=0;
	int i;

	if (!p) return;
  403b20:	48 85 ff             	test   %rdi,%rdi
  403b23:	0f 84 65 04 00 00    	je     403f8e <free+0x46e>
{
  403b29:	41 57                	push   %r15
  403b2b:	41 56                	push   %r14
  403b2d:	41 55                	push   %r13
  403b2f:	41 54                	push   %r12

	self = MEM_TO_CHUNK(p);
  403b31:	4c 8d 67 f0          	lea    -0x10(%rdi),%r12
{
  403b35:	55                   	push   %rbp
  403b36:	53                   	push   %rbx
  403b37:	48 83 ec 38          	sub    $0x38,%rsp

	if (IS_MMAPPED(self)) {
  403b3b:	48 8b 77 f8          	mov    -0x8(%rdi),%rsi
  403b3f:	40 f6 c6 01          	test   $0x1,%sil
  403b43:	0f 84 77 02 00 00    	je     403dc0 <free+0x2a0>
		if (extra & 1) a_crash();
		__munmap(base, len);
		return;
	}

	final_size = new_size = CHUNK_SIZE(self);
  403b49:	48 89 f0             	mov    %rsi,%rax
  403b4c:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
	next = NEXT_CHUNK(self);
  403b50:	4d 8d 2c 04          	lea    (%r12,%rax,1),%r13
	final_size = new_size = CHUNK_SIZE(self);
  403b54:	48 89 44 24 18       	mov    %rax,0x18(%rsp)

	/* Crash on corrupted footer (likely from buffer overflow) */
	if (next->psize != self->csize) a_crash();
  403b59:	49 3b 75 00          	cmp    0x0(%r13),%rsi
  403b5d:	74 06                	je     403b65 <free+0x45>
}

#define a_crash a_crash
static inline void a_crash()
{
	__asm__ __volatile__( "hlt" : : : "memory" );
  403b5f:	f4                   	hlt    
  403b60:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
  403b65:	4c 8d 3d 00 46 20 00 	lea    0x204600(%rip),%r15        # 60816c <mal+0x60c>
{
  403b6c:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  403b71:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%rsp)
  403b78:	00 
	__asm__ __volatile__(
  403b79:	bd 01 00 00 00       	mov    $0x1,%ebp
  403b7e:	66 90                	xchg   %ax,%ax

	for (;;) {
		if (self->psize & next->csize & C_INUSE) {
  403b80:	49 8b 04 24          	mov    (%r12),%rax
  403b84:	49 23 45 08          	and    0x8(%r13),%rax
  403b88:	a8 01                	test   $0x1,%al
  403b8a:	0f 84 a0 01 00 00    	je     403d30 <free+0x210>
			self->csize = final_size | C_INUSE;
  403b90:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  403b95:	48 89 c8             	mov    %rcx,%rax
  403b98:	48 83 c8 01          	or     $0x1,%rax
  403b9c:	49 89 44 24 08       	mov    %rax,0x8(%r12)
			next->psize = final_size | C_INUSE;
  403ba1:	49 89 45 00          	mov    %rax,0x0(%r13)
	x = x / SIZE_ALIGN - 1;
  403ba5:	48 89 c8             	mov    %rcx,%rax
  403ba8:	48 c1 e8 05          	shr    $0x5,%rax
  403bac:	48 83 e8 01          	sub    $0x1,%rax
	if (x <= 32) return x;
  403bb0:	48 83 f8 20          	cmp    $0x20,%rax
  403bb4:	89 c1                	mov    %eax,%ecx
  403bb6:	76 1f                	jbe    403bd7 <free+0xb7>
	if (x < 512) return bin_tab[x/8-4];
  403bb8:	48 3d ff 01 00 00    	cmp    $0x1ff,%rax
  403bbe:	0f 87 2c 02 00 00    	ja     403df0 <free+0x2d0>
  403bc4:	48 8d 3d 75 2f 00 00 	lea    0x2f75(%rip),%rdi        # 406b40 <bin_tab>
  403bcb:	48 c1 e8 03          	shr    $0x3,%rax
  403bcf:	0f b6 4c 07 fc       	movzbl -0x4(%rdi,%rax,1),%ecx
  403bd4:	48 89 c8             	mov    %rcx,%rax
  403bd7:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
  403bdb:	89 4c 24 2c          	mov    %ecx,0x2c(%rsp)
  403bdf:	48 c1 e0 03          	shl    $0x3,%rax
  403be3:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  403be8:	48 8d 58 08          	lea    0x8(%rax),%rbx
  403bec:	48 63 c1             	movslq %ecx,%rax
  403bef:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
	lock(mal.bins[i].lock);
  403bf4:	48 8d 05 65 3f 20 00 	lea    0x203f65(%rip),%rax        # 607b60 <mal>
  403bfb:	48 01 c3             	add    %rax,%rbx
	if (libc.threads_minus_1)
  403bfe:	8b 05 48 66 a0 10    	mov    0x10a06648(%rip),%eax        # 10e0a24c <__libc+0xc>
  403c04:	85 c0                	test   %eax,%eax
  403c06:	74 2d                	je     403c35 <free+0x115>
  403c08:	89 e8                	mov    %ebp,%eax
  403c0a:	87 03                	xchg   %eax,(%rbx)
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
  403c0c:	85 c0                	test   %eax,%eax
  403c0e:	74 25                	je     403c35 <free+0x115>
  403c10:	4c 8d 73 04          	lea    0x4(%rbx),%r14
  403c14:	0f 1f 40 00          	nopl   0x0(%rax)
  403c18:	b9 01 00 00 00       	mov    $0x1,%ecx
  403c1d:	ba 01 00 00 00       	mov    $0x1,%edx
  403c22:	4c 89 f6             	mov    %r14,%rsi
  403c25:	48 89 df             	mov    %rbx,%rdi
  403c28:	e8 cc f7 ff ff       	callq  4033f9 <__wait>
  403c2d:	89 e8                	mov    %ebp,%eax
  403c2f:	87 03                	xchg   %eax,(%rbx)
  403c31:	85 c0                	test   %eax,%eax
  403c33:	75 e3                	jne    403c18 <free+0xf8>
	if (!mal.bins[i].head)
  403c35:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  403c3a:	48 8d 35 1f 3f 20 00 	lea    0x203f1f(%rip),%rsi        # 607b60 <mal>
  403c41:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
  403c45:	48 8d 04 c6          	lea    (%rsi,%rax,8),%rax
  403c49:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
  403c4e:	0f 84 dc 01 00 00    	je     403e30 <free+0x310>
	if (libc.threads_minus_1)
  403c54:	8b 05 f2 65 a0 10    	mov    0x10a065f2(%rip),%eax        # 10e0a24c <__libc+0xc>
  403c5a:	85 c0                	test   %eax,%eax
  403c5c:	74 37                	je     403c95 <free+0x175>
  403c5e:	89 e8                	mov    %ebp,%eax
  403c60:	87 05 02 45 20 00    	xchg   %eax,0x204502(%rip)        # 608168 <mal+0x608>
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
  403c66:	85 c0                	test   %eax,%eax
  403c68:	74 2b                	je     403c95 <free+0x175>
  403c6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  403c70:	48 8d 3d f1 44 20 00 	lea    0x2044f1(%rip),%rdi        # 608168 <mal+0x608>
  403c77:	b9 01 00 00 00       	mov    $0x1,%ecx
  403c7c:	ba 01 00 00 00       	mov    $0x1,%edx
  403c81:	4c 89 fe             	mov    %r15,%rsi
  403c84:	e8 70 f7 ff ff       	callq  4033f9 <__wait>
  403c89:	89 e8                	mov    %ebp,%eax
  403c8b:	87 05 d7 44 20 00    	xchg   %eax,0x2044d7(%rip)        # 608168 <mal+0x608>
  403c91:	85 c0                	test   %eax,%eax
  403c93:	75 db                	jne    403c70 <free+0x150>
			i = bin_index(final_size);
			lock_bin(i);
			lock(mal.free_lock);
			if (self->psize & next->csize & C_INUSE)
  403c95:	49 8b 04 24          	mov    (%r12),%rax
  403c99:	49 23 45 08          	and    0x8(%r13),%rax
  403c9d:	a8 01                	test   $0x1,%al
  403c9f:	0f 85 d3 01 00 00    	jne    403e78 <free+0x358>
	if (lk[0]) {
  403ca5:	8b 05 bd 44 20 00    	mov    0x2044bd(%rip),%eax        # 608168 <mal+0x608>
  403cab:	85 c0                	test   %eax,%eax
  403cad:	74 41                	je     403cf0 <free+0x1d0>
	__asm__ __volatile__(
  403caf:	31 c0                	xor    %eax,%eax
  403cb1:	89 05 b1 44 20 00    	mov    %eax,0x2044b1(%rip)        # 608168 <mal+0x608>
  403cb7:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  403cbc:	8b 05 aa 44 20 00    	mov    0x2044aa(%rip),%eax        # 60816c <mal+0x60c>
  403cc2:	85 c0                	test   %eax,%eax
  403cc4:	74 2a                	je     403cf0 <free+0x1d0>
  403cc6:	41 b8 ca 00 00 00    	mov    $0xca,%r8d
  403ccc:	48 8d 3d 95 44 20 00 	lea    0x204495(%rip),%rdi        # 608168 <mal+0x608>
  403cd3:	ba 01 00 00 00       	mov    $0x1,%edx
  403cd8:	be 81 00 00 00       	mov    $0x81,%esi
  403cdd:	4c 89 c0             	mov    %r8,%rax
  403ce0:	0f 05                	syscall 
  403ce2:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  403ce6:	0f 84 b4 02 00 00    	je     403fa0 <free+0x480>
  403cec:	0f 1f 40 00          	nopl   0x0(%rax)
	if (lk[0]) {
  403cf0:	8b 03                	mov    (%rbx),%eax
  403cf2:	85 c0                	test   %eax,%eax
  403cf4:	74 3a                	je     403d30 <free+0x210>
  403cf6:	31 c0                	xor    %eax,%eax
  403cf8:	89 03                	mov    %eax,(%rbx)
  403cfa:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  403cff:	8b 43 04             	mov    0x4(%rbx),%eax
  403d02:	85 c0                	test   %eax,%eax
  403d04:	74 2a                	je     403d30 <free+0x210>
  403d06:	41 b8 ca 00 00 00    	mov    $0xca,%r8d
  403d0c:	ba 01 00 00 00       	mov    $0x1,%edx
  403d11:	be 81 00 00 00       	mov    $0x81,%esi
  403d16:	4c 89 c0             	mov    %r8,%rax
  403d19:	48 89 df             	mov    %rbx,%rdi
  403d1c:	0f 05                	syscall 
  403d1e:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  403d22:	0f 84 68 02 00 00    	je     403f90 <free+0x470>
  403d28:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  403d2f:	00 
				break;
			unlock(mal.free_lock);
			unlock_bin(i);
		}

		if (alloc_rev(self)) {
  403d30:	4c 89 e7             	mov    %r12,%rdi
  403d33:	e8 18 fb ff ff       	callq  403850 <alloc_rev>
  403d38:	85 c0                	test   %eax,%eax
  403d3a:	74 3c                	je     403d78 <free+0x258>
			self = PREV_CHUNK(self);
  403d3c:	49 8b 04 24          	mov    (%r12),%rax
			size = CHUNK_SIZE(self);
			final_size += size;
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
  403d40:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
			self = PREV_CHUNK(self);
  403d45:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
  403d49:	49 29 c4             	sub    %rax,%r12
			size = CHUNK_SIZE(self);
  403d4c:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  403d51:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
			final_size += size;
  403d55:	48 01 44 24 08       	add    %rax,0x8(%rsp)
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
  403d5a:	48 8d 14 07          	lea    (%rdi,%rax,1),%rdx
  403d5e:	48 81 fa 00 80 02 00 	cmp    $0x28000,%rdx
  403d65:	76 11                	jbe    403d78 <free+0x258>
  403d67:	48 31 c2             	xor    %rax,%rdx
				reclaim = 1;
  403d6a:	48 39 d0             	cmp    %rdx,%rax
  403d6d:	8b 44 24 28          	mov    0x28(%rsp),%eax
  403d71:	0f 42 c5             	cmovb  %ebp,%eax
  403d74:	89 44 24 28          	mov    %eax,0x28(%rsp)
		}

		if (alloc_fwd(next)) {
  403d78:	4c 89 ef             	mov    %r13,%rdi
  403d7b:	e8 00 f8 ff ff       	callq  403580 <alloc_fwd>
  403d80:	85 c0                	test   %eax,%eax
  403d82:	0f 84 f8 fd ff ff    	je     403b80 <free+0x60>
			size = CHUNK_SIZE(next);
  403d88:	49 8b 45 08          	mov    0x8(%r13),%rax
			final_size += size;
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
  403d8c:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
			size = CHUNK_SIZE(next);
  403d91:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
			final_size += size;
  403d95:	48 01 44 24 08       	add    %rax,0x8(%rsp)
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
  403d9a:	48 01 c2             	add    %rax,%rdx
  403d9d:	48 81 fa 00 80 02 00 	cmp    $0x28000,%rdx
  403da4:	76 11                	jbe    403db7 <free+0x297>
				reclaim = 1;
  403da6:	8b 74 24 28          	mov    0x28(%rsp),%esi
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
  403daa:	48 31 c2             	xor    %rax,%rdx
				reclaim = 1;
  403dad:	48 39 d0             	cmp    %rdx,%rax
  403db0:	0f 42 f5             	cmovb  %ebp,%esi
  403db3:	89 74 24 28          	mov    %esi,0x28(%rsp)
			next = NEXT_CHUNK(next);
  403db7:	49 01 c5             	add    %rax,%r13
  403dba:	e9 c1 fd ff ff       	jmpq   403b80 <free+0x60>
  403dbf:	90                   	nop
		size_t extra = self->psize;
  403dc0:	48 8b 47 f0          	mov    -0x10(%rdi),%rax
		size_t len = CHUNK_SIZE(self) + extra;
  403dc4:	48 83 e6 fe          	and    $0xfffffffffffffffe,%rsi
		char *base = (char *)self - extra;
  403dc8:	4c 89 e7             	mov    %r12,%rdi
  403dcb:	48 29 c7             	sub    %rax,%rdi
		size_t len = CHUNK_SIZE(self) + extra;
  403dce:	48 01 c6             	add    %rax,%rsi
		if (extra & 1) a_crash();
  403dd1:	a8 01                	test   $0x1,%al
  403dd3:	74 01                	je     403dd6 <free+0x2b6>
	__asm__ __volatile__( "hlt" : : : "memory" );
  403dd5:	f4                   	hlt    
			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
#endif
	}

	unlock_bin(i);
}
  403dd6:	48 83 c4 38          	add    $0x38,%rsp
  403dda:	5b                   	pop    %rbx
  403ddb:	5d                   	pop    %rbp
  403ddc:	41 5c                	pop    %r12
  403dde:	41 5d                	pop    %r13
  403de0:	41 5e                	pop    %r14
  403de2:	41 5f                	pop    %r15
		__munmap(base, len);
  403de4:	e9 b7 0c 00 00       	jmpq   404aa0 <__munmap>
  403de9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	if (x > 0x1c00) return 63;
  403df0:	48 3d 00 1c 00 00    	cmp    $0x1c00,%rax
  403df6:	77 58                	ja     403e50 <free+0x330>
	return bin_tab[x/128-4] + 16;
  403df8:	48 8d 3d 41 2d 00 00 	lea    0x2d41(%rip),%rdi        # 406b40 <bin_tab>
  403dff:	48 c1 e8 07          	shr    $0x7,%rax
  403e03:	0f b6 44 07 fc       	movzbl -0x4(%rdi,%rax,1),%eax
  403e08:	83 c0 10             	add    $0x10,%eax
  403e0b:	89 44 24 2c          	mov    %eax,0x2c(%rsp)
  403e0f:	48 98                	cltq   
  403e11:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  403e16:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
  403e1a:	48 c1 e0 03          	shl    $0x3,%rax
  403e1e:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  403e23:	48 8d 58 08          	lea    0x8(%rax),%rbx
  403e27:	e9 c8 fd ff ff       	jmpq   403bf4 <free+0xd4>
  403e2c:	0f 1f 40 00          	nopl   0x0(%rax)
		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
  403e30:	48 8d 15 29 3d 20 00 	lea    0x203d29(%rip),%rdx        # 607b60 <mal>
  403e37:	48 03 54 24 20       	add    0x20(%rsp),%rdx
  403e3c:	48 89 50 18          	mov    %rdx,0x18(%rax)
  403e40:	48 89 50 10          	mov    %rdx,0x10(%rax)
  403e44:	e9 0b fe ff ff       	jmpq   403c54 <free+0x134>
  403e49:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
	if (x > 0x1c00) return 63;
  403e50:	48 c7 44 24 20 e8 05 	movq   $0x5e8,0x20(%rsp)
  403e57:	00 00 
  403e59:	bb f0 05 00 00       	mov    $0x5f0,%ebx
  403e5e:	c7 44 24 2c 3f 00 00 	movl   $0x3f,0x2c(%rsp)
  403e65:	00 
  403e66:	48 c7 44 24 10 3f 00 	movq   $0x3f,0x10(%rsp)
  403e6d:	00 00 
  403e6f:	e9 80 fd ff ff       	jmpq   403bf4 <free+0xd4>
  403e74:	0f 1f 40 00          	nopl   0x0(%rax)
	if (!(mal.binmap & 1ULL<<i))
  403e78:	48 8b 05 e1 3c 20 00 	mov    0x203ce1(%rip),%rax        # 607b60 <mal>
  403e7f:	8b 7c 24 2c          	mov    0x2c(%rsp),%edi
  403e83:	48 0f a3 f8          	bt     %rdi,%rax
  403e87:	72 12                	jb     403e9b <free+0x37b>
		a_or_64(&mal.binmap, 1ULL<<i);
  403e89:	89 f9                	mov    %edi,%ecx
  403e8b:	b8 01 00 00 00       	mov    $0x1,%eax
  403e90:	48 d3 e0             	shl    %cl,%rax
	__asm__ __volatile__(
  403e93:	f0 48 09 05 c5 3c 20 	lock or %rax,0x203cc5(%rip)        # 607b60 <mal>
  403e9a:	00 
	self->csize = final_size;
  403e9b:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  403ea0:	49 89 44 24 08       	mov    %rax,0x8(%r12)
	next->psize = final_size;
  403ea5:	49 89 45 00          	mov    %rax,0x0(%r13)
	if (lk[0]) {
  403ea9:	8b 05 b9 42 20 00    	mov    0x2042b9(%rip),%eax        # 608168 <mal+0x608>
  403eaf:	85 c0                	test   %eax,%eax
  403eb1:	74 45                	je     403ef8 <free+0x3d8>
	__asm__ __volatile__(
  403eb3:	31 c0                	xor    %eax,%eax
  403eb5:	89 05 ad 42 20 00    	mov    %eax,0x2042ad(%rip)        # 608168 <mal+0x608>
  403ebb:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  403ec0:	8b 05 a6 42 20 00    	mov    0x2042a6(%rip),%eax        # 60816c <mal+0x60c>
  403ec6:	85 c0                	test   %eax,%eax
  403ec8:	74 2e                	je     403ef8 <free+0x3d8>
  403eca:	41 b8 ca 00 00 00    	mov    $0xca,%r8d
  403ed0:	48 8d 3d 91 42 20 00 	lea    0x204291(%rip),%rdi        # 608168 <mal+0x608>
  403ed7:	ba 01 00 00 00       	mov    $0x1,%edx
  403edc:	be 81 00 00 00       	mov    $0x81,%esi
  403ee1:	4c 89 c0             	mov    %r8,%rax
  403ee4:	0f 05                	syscall 
  403ee6:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  403eea:	75 0c                	jne    403ef8 <free+0x3d8>
  403eec:	4c 89 c0             	mov    %r8,%rax
  403eef:	48 89 d6             	mov    %rdx,%rsi
  403ef2:	0f 05                	syscall 
  403ef4:	0f 1f 40 00          	nopl   0x0(%rax)
	self->next = BIN_TO_CHUNK(i);
  403ef8:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  403efd:	48 8d 05 5c 3c 20 00 	lea    0x203c5c(%rip),%rax        # 607b60 <mal>
	self->prev = mal.bins[i].tail;
  403f04:	48 8d 15 55 3c 20 00 	lea    0x203c55(%rip),%rdx        # 607b60 <mal>
	self->next = BIN_TO_CHUNK(i);
  403f0b:	48 01 f0             	add    %rsi,%rax
  403f0e:	49 89 44 24 10       	mov    %rax,0x10(%r12)
	self->prev = mal.bins[i].tail;
  403f13:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  403f18:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
  403f1c:	48 8b 44 c2 18       	mov    0x18(%rdx,%rax,8),%rax
  403f21:	49 89 44 24 18       	mov    %rax,0x18(%r12)
	self->next->prev = self;
  403f26:	48 8d 05 43 3c 20 00 	lea    0x203c43(%rip),%rax        # 607b70 <mal+0x10>
  403f2d:	4c 89 64 30 08       	mov    %r12,0x8(%rax,%rsi,1)
	self->prev->next = self;
  403f32:	49 8b 44 24 18       	mov    0x18(%r12),%rax
  403f37:	4c 89 60 10          	mov    %r12,0x10(%rax)
	if (reclaim) {
  403f3b:	8b 44 24 28          	mov    0x28(%rsp),%eax
  403f3f:	85 c0                	test   %eax,%eax
  403f41:	75 6a                	jne    403fad <free+0x48d>
	if (lk[0]) {
  403f43:	8b 03                	mov    (%rbx),%eax
  403f45:	85 c0                	test   %eax,%eax
  403f47:	74 37                	je     403f80 <free+0x460>
  403f49:	31 c0                	xor    %eax,%eax
  403f4b:	89 03                	mov    %eax,(%rbx)
  403f4d:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  403f52:	8b 43 04             	mov    0x4(%rbx),%eax
  403f55:	85 c0                	test   %eax,%eax
  403f57:	74 27                	je     403f80 <free+0x460>
  403f59:	41 b8 ca 00 00 00    	mov    $0xca,%r8d
  403f5f:	ba 01 00 00 00       	mov    $0x1,%edx
  403f64:	be 81 00 00 00       	mov    $0x81,%esi
  403f69:	4c 89 c0             	mov    %r8,%rax
  403f6c:	48 89 df             	mov    %rbx,%rdi
  403f6f:	0f 05                	syscall 
  403f71:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  403f75:	75 09                	jne    403f80 <free+0x460>
  403f77:	4c 89 c0             	mov    %r8,%rax
  403f7a:	48 89 d6             	mov    %rdx,%rsi
  403f7d:	0f 05                	syscall 
  403f7f:	90                   	nop
}
  403f80:	48 83 c4 38          	add    $0x38,%rsp
  403f84:	5b                   	pop    %rbx
  403f85:	5d                   	pop    %rbp
  403f86:	41 5c                	pop    %r12
  403f88:	41 5d                	pop    %r13
  403f8a:	41 5e                	pop    %r14
  403f8c:	41 5f                	pop    %r15
  403f8e:	f3 c3                	repz retq 
  403f90:	4c 89 c0             	mov    %r8,%rax
  403f93:	48 89 d6             	mov    %rdx,%rsi
  403f96:	0f 05                	syscall 
  403f98:	e9 93 fd ff ff       	jmpq   403d30 <free+0x210>
  403f9d:	0f 1f 00             	nopl   (%rax)
  403fa0:	4c 89 c0             	mov    %r8,%rax
  403fa3:	48 89 d6             	mov    %rdx,%rsi
  403fa6:	0f 05                	syscall 
  403fa8:	e9 43 fd ff ff       	jmpq   403cf0 <free+0x1d0>
		uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;
  403fad:	49 8d bc 24 1f 10 00 	lea    0x101f(%r12),%rdi
  403fb4:	00 
		uintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;
  403fb5:	49 8d 75 e0          	lea    -0x20(%r13),%rsi
		__madvise((void *)a, b-a, MADV_DONTNEED);
  403fb9:	ba 04 00 00 00       	mov    $0x4,%edx
		uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;
  403fbe:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
		uintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;
  403fc5:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
		__madvise((void *)a, b-a, MADV_DONTNEED);
  403fcc:	48 29 fe             	sub    %rdi,%rsi
  403fcf:	e8 6e 09 00 00       	callq  404942 <__madvise>
  403fd4:	e9 6a ff ff ff       	jmpq   403f43 <free+0x423>
  403fd9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000403fe0 <malloc>:
{
  403fe0:	41 57                	push   %r15
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
  403fe2:	48 8d 57 ff          	lea    -0x1(%rdi),%rdx
{
  403fe6:	41 56                	push   %r14
  403fe8:	41 55                	push   %r13
  403fea:	41 54                	push   %r12
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
  403fec:	48 b8 df ef ff ff ff 	movabs $0x7fffffffffffefdf,%rax
  403ff3:	ff ff 7f 
{
  403ff6:	55                   	push   %rbp
  403ff7:	53                   	push   %rbx
  403ff8:	48 83 ec 38          	sub    $0x38,%rsp
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
  403ffc:	48 39 c2             	cmp    %rax,%rdx
  403fff:	0f 86 0b 01 00 00    	jbe    404110 <malloc+0x130>
		if (*n) {
  404005:	48 85 ff             	test   %rdi,%rdi
  404008:	0f 85 86 05 00 00    	jne    404594 <malloc+0x5b4>
  40400e:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  404015:	ff ff 
  404017:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%rsp)
  40401e:	00 
			*n = SIZE_ALIGN;
  40401f:	48 c7 44 24 10 20 00 	movq   $0x20,0x10(%rsp)
  404026:	00 00 
  404028:	4c 8d 35 31 3b 20 00 	lea    0x203b31(%rip),%r14        # 607b60 <mal>
	__asm__ __volatile__(
  40402f:	41 bc 01 00 00 00    	mov    $0x1,%r12d
  404035:	0f 1f 00             	nopl   (%rax)
		uint64_t mask = mal.binmap & -(1ULL<<i);
  404038:	49 8b 1e             	mov    (%r14),%rbx
		if (!mask) {
  40403b:	48 23 5c 24 08       	and    0x8(%rsp),%rbx
  404040:	0f 84 5a 01 00 00    	je     4041a0 <malloc+0x1c0>
}

#define a_ctz_64 a_ctz_64
static inline int a_ctz_64(uint64_t x)
{
	__asm__( "bsf %1,%0" : "=r"(x) : "r"(x) );
  404046:	48 0f bc db          	bsf    %rbx,%rbx
	if (libc.threads_minus_1)
  40404a:	8b 05 fc 61 a0 10    	mov    0x10a061fc(%rip),%eax        # 10e0a24c <__libc+0xc>
	return x;
  404050:	89 5c 24 18          	mov    %ebx,0x18(%rsp)
  404054:	48 63 db             	movslq %ebx,%rbx
  404057:	48 8d 2c 5b          	lea    (%rbx,%rbx,2),%rbp
  40405b:	48 c1 e5 03          	shl    $0x3,%rbp
  40405f:	85 c0                	test   %eax,%eax
	lock(mal.bins[i].lock);
  404061:	4d 8d 7c 2e 08       	lea    0x8(%r14,%rbp,1),%r15
	if (libc.threads_minus_1)
  404066:	74 37                	je     40409f <malloc+0xbf>
	__asm__ __volatile__(
  404068:	44 89 e0             	mov    %r12d,%eax
  40406b:	41 87 07             	xchg   %eax,(%r15)
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
  40406e:	85 c0                	test   %eax,%eax
  404070:	74 2d                	je     40409f <malloc+0xbf>
  404072:	4d 8d 6f 04          	lea    0x4(%r15),%r13
  404076:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40407d:	00 00 00 
  404080:	b9 01 00 00 00       	mov    $0x1,%ecx
  404085:	ba 01 00 00 00       	mov    $0x1,%edx
  40408a:	4c 89 ee             	mov    %r13,%rsi
  40408d:	4c 89 ff             	mov    %r15,%rdi
  404090:	e8 64 f3 ff ff       	callq  4033f9 <__wait>
  404095:	44 89 e2             	mov    %r12d,%edx
  404098:	41 87 17             	xchg   %edx,(%r15)
  40409b:	85 d2                	test   %edx,%edx
  40409d:	75 e1                	jne    404080 <malloc+0xa0>
	if (!mal.bins[i].head)
  40409f:	48 8d 04 5b          	lea    (%rbx,%rbx,2),%rax
  4040a3:	49 8d 04 c6          	lea    (%r14,%rax,8),%rax
  4040a7:	48 8b 58 10          	mov    0x10(%rax),%rbx
  4040ab:	48 85 db             	test   %rbx,%rbx
  4040ae:	0f 84 dc 00 00 00    	je     404190 <malloc+0x1b0>
		if (c != BIN_TO_CHUNK(j)) {
  4040b4:	4c 01 f5             	add    %r14,%rbp
  4040b7:	48 39 eb             	cmp    %rbp,%rbx
  4040ba:	0f 85 2f 02 00 00    	jne    4042ef <malloc+0x30f>
	if (lk[0]) {
  4040c0:	41 8b 07             	mov    (%r15),%eax
  4040c3:	85 c0                	test   %eax,%eax
  4040c5:	0f 84 6d ff ff ff    	je     404038 <malloc+0x58>
	__asm__ __volatile__(
  4040cb:	31 c0                	xor    %eax,%eax
  4040cd:	41 89 07             	mov    %eax,(%r15)
  4040d0:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  4040d5:	41 8b 47 04          	mov    0x4(%r15),%eax
  4040d9:	85 c0                	test   %eax,%eax
  4040db:	0f 84 57 ff ff ff    	je     404038 <malloc+0x58>
  4040e1:	41 b9 ca 00 00 00    	mov    $0xca,%r9d
  4040e7:	ba 01 00 00 00       	mov    $0x1,%edx
  4040ec:	be 81 00 00 00       	mov    $0x81,%esi
  4040f1:	4c 89 c8             	mov    %r9,%rax
  4040f4:	4c 89 ff             	mov    %r15,%rdi
  4040f7:	0f 05                	syscall 
  4040f9:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  4040fd:	0f 85 35 ff ff ff    	jne    404038 <malloc+0x58>
  404103:	4c 89 c8             	mov    %r9,%rax
  404106:	48 89 d6             	mov    %rdx,%rsi
  404109:	0f 05                	syscall 
  40410b:	e9 28 ff ff ff       	jmpq   404038 <malloc+0x58>
	*n = (*n + OVERHEAD + SIZE_ALIGN - 1) & SIZE_MASK;
  404110:	48 83 c7 2f          	add    $0x2f,%rdi
  404114:	48 83 e7 e0          	and    $0xffffffffffffffe0,%rdi
	if (n > MMAP_THRESHOLD) {
  404118:	48 81 ff 00 80 03 00 	cmp    $0x38000,%rdi
	*n = (*n + OVERHEAD + SIZE_ALIGN - 1) & SIZE_MASK;
  40411f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
	if (n > MMAP_THRESHOLD) {
  404124:	0f 86 0d 03 00 00    	jbe    404437 <malloc+0x457>
		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
  40412a:	48 89 fd             	mov    %rdi,%rbp
		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
  40412d:	45 31 c9             	xor    %r9d,%r9d
  404130:	31 ff                	xor    %edi,%edi
		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
  404132:	48 81 c5 0f 10 00 00 	add    $0x100f,%rbp
		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
  404139:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
  40413f:	b9 22 00 00 00       	mov    $0x22,%ecx
		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
  404144:	48 81 e5 00 f0 ff ff 	and    $0xfffffffffffff000,%rbp
		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
  40414b:	ba 03 00 00 00       	mov    $0x3,%edx
  404150:	48 89 ee             	mov    %rbp,%rsi
  404153:	e8 03 08 00 00       	callq  40495b <__mmap>
		if (base == (void *)-1) return 0;
  404158:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  40415c:	0f 84 e7 03 00 00    	je     404549 <malloc+0x569>
		c->csize = len - (SIZE_ALIGN - OVERHEAD);
  404162:	48 83 ed 10          	sub    $0x10,%rbp
		return CHUNK_TO_MEM(c);
  404166:	48 8d 58 20          	lea    0x20(%rax),%rbx
		c->psize = SIZE_ALIGN - OVERHEAD;
  40416a:	48 c7 40 10 10 00 00 	movq   $0x10,0x10(%rax)
  404171:	00 
		c->csize = len - (SIZE_ALIGN - OVERHEAD);
  404172:	48 89 68 18          	mov    %rbp,0x18(%rax)
}
  404176:	48 83 c4 38          	add    $0x38,%rsp
  40417a:	48 89 d8             	mov    %rbx,%rax
  40417d:	5b                   	pop    %rbx
  40417e:	5d                   	pop    %rbp
  40417f:	41 5c                	pop    %r12
  404181:	41 5d                	pop    %r13
  404183:	41 5e                	pop    %r14
  404185:	41 5f                	pop    %r15
  404187:	c3                   	retq   
  404188:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40418f:	00 
		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
  404190:	4c 01 f5             	add    %r14,%rbp
  404193:	48 89 68 18          	mov    %rbp,0x18(%rax)
  404197:	48 89 68 10          	mov    %rbp,0x10(%rax)
  40419b:	e9 20 ff ff ff       	jmpq   4040c0 <malloc+0xe0>
	n += SIZE_ALIGN;
  4041a0:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  4041a5:	48 83 c0 20          	add    $0x20,%rax
  4041a9:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	if (libc.threads_minus_1)
  4041ae:	8b 05 98 60 a0 10    	mov    0x10a06098(%rip),%eax        # 10e0a24c <__libc+0xc>
  4041b4:	85 c0                	test   %eax,%eax
  4041b6:	0f 85 cf 02 00 00    	jne    40448b <malloc+0x4ab>
	p = __expand_heap(&n);
  4041bc:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
  4041c1:	e8 ba 14 00 00       	callq  405680 <__expand_heap>
	if (!p) {
  4041c6:	48 85 c0             	test   %rax,%rax
	p = __expand_heap(&n);
  4041c9:	48 89 c3             	mov    %rax,%rbx
	if (!p) {
  4041cc:	0f 84 27 03 00 00    	je     4044f9 <malloc+0x519>
	if (p != end) {
  4041d2:	48 3b 1d 77 39 20 00 	cmp    0x203977(%rip),%rbx        # 607b50 <end.3326>
		n -= SIZE_ALIGN;
  4041d9:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
	if (p != end) {
  4041de:	48 89 dd             	mov    %rbx,%rbp
  4041e1:	74 15                	je     4041f8 <malloc+0x218>
		n -= SIZE_ALIGN;
  4041e3:	48 83 e8 20          	sub    $0x20,%rax
		p = (char *)p + SIZE_ALIGN;
  4041e7:	48 8d 6b 20          	lea    0x20(%rbx),%rbp
		w->psize = 0 | C_INUSE;
  4041eb:	48 c7 43 10 01 00 00 	movq   $0x1,0x10(%rbx)
  4041f2:	00 
		n -= SIZE_ALIGN;
  4041f3:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
	end = (char *)p + n;
  4041f8:	48 8d 54 05 00       	lea    0x0(%rbp,%rax,1),%rdx
	w->psize = n | C_INUSE;
  4041fd:	48 83 c8 01          	or     $0x1,%rax
	w = MEM_TO_CHUNK(p);
  404201:	4c 8d 65 f0          	lea    -0x10(%rbp),%r12
	if (lk[0]) {
  404205:	48 8d 3d 4c 39 20 00 	lea    0x20394c(%rip),%rdi        # 607b58 <heap_lock.3325>
	w->psize = n | C_INUSE;
  40420c:	48 89 42 f0          	mov    %rax,-0x10(%rdx)
	w->csize = 0 | C_INUSE;
  404210:	48 c7 42 f8 01 00 00 	movq   $0x1,-0x8(%rdx)
  404217:	00 
	end = (char *)p + n;
  404218:	48 89 15 31 39 20 00 	mov    %rdx,0x203931(%rip)        # 607b50 <end.3326>
	if (lk[0]) {
  40421f:	8b 15 33 39 20 00    	mov    0x203933(%rip),%edx        # 607b58 <heap_lock.3325>
	w->csize = n | C_INUSE;
  404225:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (lk[0]) {
  404229:	85 d2                	test   %edx,%edx
  40422b:	74 36                	je     404263 <malloc+0x283>
  40422d:	31 c0                	xor    %eax,%eax
  40422f:	89 05 23 39 20 00    	mov    %eax,0x203923(%rip)        # 607b58 <heap_lock.3325>
  404235:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  40423a:	8b 05 1c 39 20 00    	mov    0x20391c(%rip),%eax        # 607b5c <heap_lock.3325+0x4>
  404240:	85 c0                	test   %eax,%eax
  404242:	74 1f                	je     404263 <malloc+0x283>
  404244:	41 b8 ca 00 00 00    	mov    $0xca,%r8d
  40424a:	ba 01 00 00 00       	mov    $0x1,%edx
  40424f:	be 81 00 00 00       	mov    $0x81,%esi
  404254:	4c 89 c0             	mov    %r8,%rax
  404257:	0f 05                	syscall 
  404259:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  40425d:	0f 84 ed 02 00 00    	je     404550 <malloc+0x570>
			if (!c) return 0;
  404263:	4d 85 e4             	test   %r12,%r12
  404266:	0f 84 dd 02 00 00    	je     404549 <malloc+0x569>
			if (alloc_rev(c)) {
  40426c:	4c 89 e7             	mov    %r12,%rdi
  40426f:	e8 dc f5 ff ff       	callq  403850 <alloc_rev>
  404274:	85 c0                	test   %eax,%eax
  404276:	0f 84 59 02 00 00    	je     4044d5 <malloc+0x4f5>
				c = PREV_CHUNK(c);
  40427c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  404280:	4c 89 e3             	mov    %r12,%rbx
				NEXT_CHUNK(x)->psize = c->csize =
  404283:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
				c = PREV_CHUNK(c);
  404287:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
  40428b:	48 29 c3             	sub    %rax,%rbx
					x->csize + CHUNK_SIZE(c);
  40428e:	48 8b 43 08          	mov    0x8(%rbx),%rax
  404292:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
  404296:	48 01 d0             	add    %rdx,%rax
				NEXT_CHUNK(x)->psize = c->csize =
  404299:	48 83 e2 fe          	and    $0xfffffffffffffffe,%rdx
  40429d:	48 89 43 08          	mov    %rax,0x8(%rbx)
  4042a1:	49 89 04 14          	mov    %rax,(%r12,%rdx,1)
	size_t n1 = CHUNK_SIZE(self);
  4042a5:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
	if (n >= n1 - DONTCARE) return;
  4042a9:	48 8d 50 f0          	lea    -0x10(%rax),%rdx
  4042ad:	48 3b 54 24 10       	cmp    0x10(%rsp),%rdx
  4042b2:	76 32                	jbe    4042e6 <malloc+0x306>
	split = (void *)((char *)self + n);
  4042b4:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
	split->csize = n1-n | C_INUSE;
  4042b9:	48 89 c1             	mov    %rax,%rcx
	split = (void *)((char *)self + n);
  4042bc:	48 8d 14 3b          	lea    (%rbx,%rdi,1),%rdx
  4042c0:	48 89 fe             	mov    %rdi,%rsi
	split->csize = n1-n | C_INUSE;
  4042c3:	48 29 f9             	sub    %rdi,%rcx
	split->psize = n | C_INUSE;
  4042c6:	48 83 ce 01          	or     $0x1,%rsi
	split->csize = n1-n | C_INUSE;
  4042ca:	48 83 c9 01          	or     $0x1,%rcx
	free(CHUNK_TO_MEM(split));
  4042ce:	48 8d 7a 10          	lea    0x10(%rdx),%rdi
	split->psize = n | C_INUSE;
  4042d2:	48 89 32             	mov    %rsi,(%rdx)
	split->csize = n1-n | C_INUSE;
  4042d5:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	next->psize = n1-n | C_INUSE;
  4042d9:	48 89 0c 03          	mov    %rcx,(%rbx,%rax,1)
	self->csize = n | C_INUSE;
  4042dd:	48 89 73 08          	mov    %rsi,0x8(%rbx)
	free(CHUNK_TO_MEM(split));
  4042e1:	e8 3a f8 ff ff       	callq  403b20 <free>
	return CHUNK_TO_MEM(c);
  4042e6:	48 83 c3 10          	add    $0x10,%rbx
  4042ea:	e9 87 fe ff ff       	jmpq   404176 <malloc+0x196>
	if (j < 40) return 0;
  4042ef:	8b 4c 24 18          	mov    0x18(%rsp),%ecx
  4042f3:	83 f9 27             	cmp    $0x27,%ecx
  4042f6:	0f 8e f6 00 00 00    	jle    4043f2 <malloc+0x412>
	if (j < i+3) {
  4042fc:	8b 44 24 1c          	mov    0x1c(%rsp),%eax
  404300:	83 c0 02             	add    $0x2,%eax
  404303:	39 c1                	cmp    %eax,%ecx
  404305:	0f 8e de 00 00 00    	jle    4043e9 <malloc+0x409>
		n1 = CHUNK_SIZE(self);
  40430b:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  40430f:	48 83 e2 fe          	and    $0xfffffffffffffffe,%rdx
  404313:	48 89 d6             	mov    %rdx,%rsi
  404316:	48 2b 74 24 10       	sub    0x10(%rsp),%rsi
	x = x / SIZE_ALIGN - 1;
  40431b:	48 89 f0             	mov    %rsi,%rax
  40431e:	48 c1 e8 05          	shr    $0x5,%rax
  404322:	48 83 e8 01          	sub    $0x1,%rax
	if (x <= 32) return x;
  404326:	48 83 f8 20          	cmp    $0x20,%rax
  40432a:	0f 86 c2 00 00 00    	jbe    4043f2 <malloc+0x412>
	if (x < 512) return bin_tab[x/8-4];
  404330:	48 3d ff 01 00 00    	cmp    $0x1ff,%rax
  404336:	0f 86 43 02 00 00    	jbe    40457f <malloc+0x59f>
	if (x > 0x1c00) return 63;
  40433c:	48 3d 00 1c 00 00    	cmp    $0x1c00,%rax
  404342:	b9 3f 00 00 00       	mov    $0x3f,%ecx
  404347:	77 13                	ja     40435c <malloc+0x37c>
	return bin_tab[x/128-4] + 16;
  404349:	48 8d 0d f0 27 00 00 	lea    0x27f0(%rip),%rcx        # 406b40 <bin_tab>
  404350:	48 c1 e8 07          	shr    $0x7,%rax
  404354:	0f b6 4c 01 fc       	movzbl -0x4(%rcx,%rax,1),%ecx
  404359:	83 c1 10             	add    $0x10,%ecx
	if (bin_index(n1-n) != j) return 0;
  40435c:	39 4c 24 18          	cmp    %ecx,0x18(%rsp)
  404360:	0f 85 8c 00 00 00    	jne    4043f2 <malloc+0x412>
	split = (void *)((char *)self + n);
  404366:	4c 8b 54 24 10       	mov    0x10(%rsp),%r10
	split->prev = self->prev;
  40436b:	48 8b 43 18          	mov    0x18(%rbx),%rax
	split->next = self->next;
  40436f:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
	split = (void *)((char *)self + n);
  404373:	4a 8d 0c 13          	lea    (%rbx,%r10,1),%rcx
	split->prev = self->prev;
  404377:	48 89 41 18          	mov    %rax,0x18(%rcx)
	split->next = self->next;
  40437b:	48 89 79 10          	mov    %rdi,0x10(%rcx)
	split->prev->next = split;
  40437f:	48 89 48 10          	mov    %rcx,0x10(%rax)
	split->next->prev = split;
  404383:	48 8b 41 10          	mov    0x10(%rcx),%rax
  404387:	48 89 48 18          	mov    %rcx,0x18(%rax)
	split->psize = n | C_INUSE;
  40438b:	4c 89 d0             	mov    %r10,%rax
	split->csize = n1-n;
  40438e:	48 89 71 08          	mov    %rsi,0x8(%rcx)
	split->psize = n | C_INUSE;
  404392:	48 83 c8 01          	or     $0x1,%rax
  404396:	48 89 01             	mov    %rax,(%rcx)
	next->psize = n1-n;
  404399:	48 89 34 13          	mov    %rsi,(%rbx,%rdx,1)
	if (lk[0]) {
  40439d:	41 8b 17             	mov    (%r15),%edx
	self->csize = n | C_INUSE;
  4043a0:	48 89 43 08          	mov    %rax,0x8(%rbx)
	if (lk[0]) {
  4043a4:	85 d2                	test   %edx,%edx
  4043a6:	0f 84 f9 fe ff ff    	je     4042a5 <malloc+0x2c5>
  4043ac:	31 c0                	xor    %eax,%eax
  4043ae:	41 89 07             	mov    %eax,(%r15)
  4043b1:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  4043b6:	41 8b 47 04          	mov    0x4(%r15),%eax
  4043ba:	85 c0                	test   %eax,%eax
  4043bc:	74 22                	je     4043e0 <malloc+0x400>
  4043be:	41 b9 ca 00 00 00    	mov    $0xca,%r9d
  4043c4:	ba 01 00 00 00       	mov    $0x1,%edx
  4043c9:	be 81 00 00 00       	mov    $0x81,%esi
  4043ce:	4c 89 c8             	mov    %r9,%rax
  4043d1:	4c 89 ff             	mov    %r15,%rdi
  4043d4:	0f 05                	syscall 
  4043d6:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  4043da:	0f 84 c6 01 00 00    	je     4045a6 <malloc+0x5c6>
  4043e0:	48 8b 43 08          	mov    0x8(%rbx),%rax
  4043e4:	e9 bc fe ff ff       	jmpq   4042a5 <malloc+0x2c5>
		if (j != 63) return 0;
  4043e9:	83 f9 3f             	cmp    $0x3f,%ecx
  4043ec:	0f 84 6b 01 00 00    	je     40455d <malloc+0x57d>
	if (c->prev == c->next)
  4043f2:	48 8b 43 18          	mov    0x18(%rbx),%rax
  4043f6:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  4043fa:	48 39 d0             	cmp    %rdx,%rax
  4043fd:	0f 84 b3 01 00 00    	je     4045b6 <malloc+0x5d6>
	c->prev->next = c->next;
  404403:	48 89 50 10          	mov    %rdx,0x10(%rax)
	c->next->prev = c->prev;
  404407:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  40440b:	48 89 42 18          	mov    %rax,0x18(%rdx)
	c->csize |= C_INUSE;
  40440f:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  404413:	48 89 d0             	mov    %rdx,%rax
	NEXT_CHUNK(c)->psize |= C_INUSE;
  404416:	48 83 e2 fe          	and    $0xfffffffffffffffe,%rdx
	c->csize |= C_INUSE;
  40441a:	48 83 c8 01          	or     $0x1,%rax
  40441e:	48 89 43 08          	mov    %rax,0x8(%rbx)
	NEXT_CHUNK(c)->psize |= C_INUSE;
  404422:	48 83 0c 13 01       	orq    $0x1,(%rbx,%rdx,1)
	if (lk[0]) {
  404427:	41 8b 17             	mov    (%r15),%edx
  40442a:	85 d2                	test   %edx,%edx
  40442c:	0f 84 73 fe ff ff    	je     4042a5 <malloc+0x2c5>
  404432:	e9 75 ff ff ff       	jmpq   4043ac <malloc+0x3cc>
  404437:	48 89 f8             	mov    %rdi,%rax
	x = x / SIZE_ALIGN - 1;
  40443a:	48 c1 e8 05          	shr    $0x5,%rax
  40443e:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
	if (x <= 32) return x;
  404442:	48 83 f9 20          	cmp    $0x20,%rcx
  404446:	0f 86 8e 01 00 00    	jbe    4045da <malloc+0x5fa>
	x--;
  40444c:	48 83 e8 02          	sub    $0x2,%rax
	if (x < 512) return bin_tab[x/8-4] + 1;
  404450:	48 3d ff 01 00 00    	cmp    $0x1ff,%rax
  404456:	0f 87 85 00 00 00    	ja     4044e1 <malloc+0x501>
  40445c:	48 8d 15 dd 26 00 00 	lea    0x26dd(%rip),%rdx        # 406b40 <bin_tab>
  404463:	48 c1 e8 03          	shr    $0x3,%rax
  404467:	0f b6 44 02 fc       	movzbl -0x4(%rdx,%rax,1),%eax
  40446c:	83 c0 01             	add    $0x1,%eax
	return bin_tab[x/128-4] + 17;
  40446f:	89 c6                	mov    %eax,%esi
  404471:	89 44 24 1c          	mov    %eax,0x1c(%rsp)
  404475:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  40447c:	89 f1                	mov    %esi,%ecx
  40447e:	48 d3 e0             	shl    %cl,%rax
  404481:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  404486:	e9 9d fb ff ff       	jmpq   404028 <malloc+0x48>
	__asm__ __volatile__(
  40448b:	b8 01 00 00 00       	mov    $0x1,%eax
  404490:	87 05 c2 36 20 00    	xchg   %eax,0x2036c2(%rip)        # 607b58 <heap_lock.3325>
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
  404496:	85 c0                	test   %eax,%eax
  404498:	0f 84 1e fd ff ff    	je     4041bc <malloc+0x1dc>
  40449e:	48 8d 1d b7 36 20 00 	lea    0x2036b7(%rip),%rbx        # 607b5c <heap_lock.3325+0x4>
  4044a5:	0f 1f 00             	nopl   (%rax)
  4044a8:	48 8d 3d a9 36 20 00 	lea    0x2036a9(%rip),%rdi        # 607b58 <heap_lock.3325>
  4044af:	b9 01 00 00 00       	mov    $0x1,%ecx
  4044b4:	ba 01 00 00 00       	mov    $0x1,%edx
  4044b9:	48 89 de             	mov    %rbx,%rsi
  4044bc:	e8 38 ef ff ff       	callq  4033f9 <__wait>
  4044c1:	b8 01 00 00 00       	mov    $0x1,%eax
  4044c6:	87 05 8c 36 20 00    	xchg   %eax,0x20368c(%rip)        # 607b58 <heap_lock.3325>
  4044cc:	85 c0                	test   %eax,%eax
  4044ce:	75 d8                	jne    4044a8 <malloc+0x4c8>
  4044d0:	e9 e7 fc ff ff       	jmpq   4041bc <malloc+0x1dc>
  4044d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
			if (alloc_rev(c)) {
  4044d9:	4c 89 e3             	mov    %r12,%rbx
  4044dc:	e9 c4 fd ff ff       	jmpq   4042a5 <malloc+0x2c5>
	return bin_tab[x/128-4] + 17;
  4044e1:	48 8d 15 58 26 00 00 	lea    0x2658(%rip),%rdx        # 406b40 <bin_tab>
  4044e8:	48 c1 e8 07          	shr    $0x7,%rax
  4044ec:	0f b6 44 02 fc       	movzbl -0x4(%rdx,%rax,1),%eax
  4044f1:	83 c0 11             	add    $0x11,%eax
  4044f4:	e9 76 ff ff ff       	jmpq   40446f <malloc+0x48f>
	if (lk[0]) {
  4044f9:	8b 05 59 36 20 00    	mov    0x203659(%rip),%eax        # 607b58 <heap_lock.3325>
  4044ff:	48 8d 3d 52 36 20 00 	lea    0x203652(%rip),%rdi        # 607b58 <heap_lock.3325>
  404506:	85 c0                	test   %eax,%eax
  404508:	74 3f                	je     404549 <malloc+0x569>
	__asm__ __volatile__(
  40450a:	31 c0                	xor    %eax,%eax
  40450c:	89 05 46 36 20 00    	mov    %eax,0x203646(%rip)        # 607b58 <heap_lock.3325>
  404512:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
		if (lk[1]) __wake(lk, 1, 1);
  404517:	8b 05 3f 36 20 00    	mov    0x20363f(%rip),%eax        # 607b5c <heap_lock.3325+0x4>
  40451d:	85 c0                	test   %eax,%eax
  40451f:	74 28                	je     404549 <malloc+0x569>
  404521:	41 b8 ca 00 00 00    	mov    $0xca,%r8d
  404527:	ba 01 00 00 00       	mov    $0x1,%edx
  40452c:	be 81 00 00 00       	mov    $0x81,%esi
  404531:	4c 89 c0             	mov    %r8,%rax
  404534:	0f 05                	syscall 
  404536:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  40453a:	75 0d                	jne    404549 <malloc+0x569>
  40453c:	4c 89 c0             	mov    %r8,%rax
  40453f:	48 89 d6             	mov    %rdx,%rsi
  404542:	0f 05                	syscall 
  404544:	e9 2d fc ff ff       	jmpq   404176 <malloc+0x196>
		if (base == (void *)-1) return 0;
  404549:	31 db                	xor    %ebx,%ebx
  40454b:	e9 26 fc ff ff       	jmpq   404176 <malloc+0x196>
  404550:	4c 89 c0             	mov    %r8,%rax
  404553:	48 89 d6             	mov    %rdx,%rsi
  404556:	0f 05                	syscall 
  404558:	e9 06 fd ff ff       	jmpq   404263 <malloc+0x283>
		n1 = CHUNK_SIZE(self);
  40455d:	48 8b 53 08          	mov    0x8(%rbx),%rdx
  404561:	48 83 e2 fe          	and    $0xfffffffffffffffe,%rdx
		if (n1-n <= MMAP_THRESHOLD) return 0;
  404565:	48 89 d6             	mov    %rdx,%rsi
  404568:	48 2b 74 24 10       	sub    0x10(%rsp),%rsi
  40456d:	48 81 fe 00 80 03 00 	cmp    $0x38000,%rsi
  404574:	0f 87 a1 fd ff ff    	ja     40431b <malloc+0x33b>
  40457a:	e9 73 fe ff ff       	jmpq   4043f2 <malloc+0x412>
	if (x < 512) return bin_tab[x/8-4];
  40457f:	48 8d 0d ba 25 00 00 	lea    0x25ba(%rip),%rcx        # 406b40 <bin_tab>
  404586:	48 c1 e8 03          	shr    $0x3,%rax
  40458a:	0f b6 4c 01 fc       	movzbl -0x4(%rcx,%rax,1),%ecx
  40458f:	e9 c8 fd ff ff       	jmpq   40435c <malloc+0x37c>
			errno = ENOMEM;
  404594:	e8 17 ef ff ff       	callq  4034b0 <__errno_location>
	if (adjust_size(&n) < 0) return 0;
  404599:	31 db                	xor    %ebx,%ebx
			errno = ENOMEM;
  40459b:	c7 00 0c 00 00 00    	movl   $0xc,(%rax)
  4045a1:	e9 d0 fb ff ff       	jmpq   404176 <malloc+0x196>
  4045a6:	4c 89 c8             	mov    %r9,%rax
  4045a9:	4c 89 ff             	mov    %r15,%rdi
  4045ac:	48 89 d6             	mov    %rdx,%rsi
  4045af:	0f 05                	syscall 
  4045b1:	e9 2a fe ff ff       	jmpq   4043e0 <malloc+0x400>
		a_and_64(&mal.binmap, ~(1ULL<<i));
  4045b6:	0f b6 4c 24 18       	movzbl 0x18(%rsp),%ecx
  4045bb:	48 c7 c0 fe ff ff ff 	mov    $0xfffffffffffffffe,%rax
  4045c2:	48 d3 c0             	rol    %cl,%rax
	__asm__ __volatile(
  4045c5:	f0 48 21 05 93 35 20 	lock and %rax,0x203593(%rip)        # 607b60 <mal>
  4045cc:	00 
  4045cd:	48 8b 43 18          	mov    0x18(%rbx),%rax
  4045d1:	48 8b 53 10          	mov    0x10(%rbx),%rdx
  4045d5:	e9 29 fe ff ff       	jmpq   404403 <malloc+0x423>
  4045da:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  4045e1:	89 4c 24 1c          	mov    %ecx,0x1c(%rsp)
  4045e5:	48 d3 e0             	shl    %cl,%rax
  4045e8:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  4045ed:	e9 36 fa ff ff       	jmpq   404028 <malloc+0x48>
  4045f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4045f9:	00 00 00 
  4045fc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000404600 <__malloc0>:
{
  404600:	53                   	push   %rbx
  404601:	48 89 fb             	mov    %rdi,%rbx
	void *p = malloc(n);
  404604:	e8 d7 f9 ff ff       	callq  403fe0 <malloc>
	if (p && !IS_MMAPPED(MEM_TO_CHUNK(p))) {
  404609:	48 85 c0             	test   %rax,%rax
  40460c:	74 38                	je     404646 <__malloc0+0x46>
  40460e:	f6 40 f8 01          	testb  $0x1,-0x8(%rax)
  404612:	74 32                	je     404646 <__malloc0+0x46>
		n = (n + sizeof *z - 1)/sizeof *z;
  404614:	48 83 c3 07          	add    $0x7,%rbx
  404618:	48 c1 eb 03          	shr    $0x3,%rbx
		for (z=p; n; n--, z++) if (*z) *z=0;
  40461c:	48 85 db             	test   %rbx,%rbx
  40461f:	74 25                	je     404646 <__malloc0+0x46>
  404621:	48 8d 0c d8          	lea    (%rax,%rbx,8),%rcx
  404625:	48 89 c2             	mov    %rax,%rdx
  404628:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40462f:	00 
  404630:	48 83 3a 00          	cmpq   $0x0,(%rdx)
  404634:	74 07                	je     40463d <__malloc0+0x3d>
  404636:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  40463d:	48 83 c2 08          	add    $0x8,%rdx
  404641:	48 39 d1             	cmp    %rdx,%rcx
  404644:	75 ea                	jne    404630 <__malloc0+0x30>
}
  404646:	5b                   	pop    %rbx
  404647:	c3                   	retq   
  404648:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40464f:	00 

0000000000404650 <realloc>:
	if (!p) return malloc(n);
  404650:	48 85 ff             	test   %rdi,%rdi
  404653:	0f 84 a7 01 00 00    	je     404800 <realloc+0x1b0>
{
  404659:	41 57                	push   %r15
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
  40465b:	48 8d 56 ff          	lea    -0x1(%rsi),%rdx
{
  40465f:	41 56                	push   %r14
  404661:	41 55                	push   %r13
  404663:	41 54                	push   %r12
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
  404665:	48 b8 df ef ff ff ff 	movabs $0x7fffffffffffefdf,%rax
  40466c:	ff ff 7f 
{
  40466f:	55                   	push   %rbp
  404670:	53                   	push   %rbx
  404671:	48 89 fd             	mov    %rdi,%rbp
  404674:	48 83 ec 18          	sub    $0x18,%rsp
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
  404678:	48 39 c2             	cmp    %rax,%rdx
  40467b:	0f 87 87 00 00 00    	ja     404708 <realloc+0xb8>
	*n = (*n + OVERHEAD + SIZE_ALIGN - 1) & SIZE_MASK;
  404681:	48 8d 5e 2f          	lea    0x2f(%rsi),%rbx
  404685:	48 83 e3 e0          	and    $0xffffffffffffffe0,%rbx
	n1 = n0 = CHUNK_SIZE(self);
  404689:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	self = MEM_TO_CHUNK(p);
  40468d:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
	n1 = n0 = CHUNK_SIZE(self);
  404691:	49 89 c5             	mov    %rax,%r13
  404694:	49 83 e5 fe          	and    $0xfffffffffffffffe,%r13
	if (IS_MMAPPED(self)) {
  404698:	a8 01                	test   $0x1,%al
  40469a:	0f 85 f8 00 00 00    	jne    404798 <realloc+0x148>
		size_t extra = self->psize;
  4046a0:	4c 8b 7d f0          	mov    -0x10(%rbp),%r15
		if (extra & 1) a_crash();
  4046a4:	41 f6 c7 01          	test   $0x1,%r15b
		size_t oldlen = n0 + extra;
  4046a8:	4b 8d 74 3d 00       	lea    0x0(%r13,%r15,1),%rsi
		size_t newlen = n + extra;
  4046ad:	4d 8d 34 1f          	lea    (%r15,%rbx,1),%r14
		if (extra & 1) a_crash();
  4046b1:	74 01                	je     4046b4 <realloc+0x64>
	__asm__ __volatile__( "hlt" : : : "memory" );
  4046b3:	f4                   	hlt    
		if (newlen < PAGE_SIZE && (new = malloc(n))) {
  4046b4:	49 81 fe ff 0f 00 00 	cmp    $0xfff,%r14
  4046bb:	0f 86 0f 01 00 00    	jbe    4047d0 <realloc+0x180>
		newlen = (newlen + PAGE_SIZE-1) & -PAGE_SIZE;
  4046c1:	49 81 c6 ff 0f 00 00 	add    $0xfff,%r14
  4046c8:	49 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%r14
		if (oldlen == newlen) return p;
  4046cf:	4c 39 f6             	cmp    %r14,%rsi
  4046d2:	0f 84 f0 00 00 00    	je     4047c8 <realloc+0x178>
		char *base = (char *)self - extra;
  4046d8:	4c 29 fa             	sub    %r15,%rdx
		base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE);
  4046db:	31 c0                	xor    %eax,%eax
  4046dd:	b9 01 00 00 00       	mov    $0x1,%ecx
		char *base = (char *)self - extra;
  4046e2:	48 89 d7             	mov    %rdx,%rdi
		base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE);
  4046e5:	4c 89 f2             	mov    %r14,%rdx
  4046e8:	e8 1f 03 00 00       	callq  404a0c <__mremap>
		if (base == (void *)-1)
  4046ed:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  4046f1:	74 67                	je     40475a <realloc+0x10a>
		self = (void *)(base + extra);
  4046f3:	4c 01 f8             	add    %r15,%rax
		self->csize = newlen - extra;
  4046f6:	4d 29 fe             	sub    %r15,%r14
  4046f9:	4c 89 70 08          	mov    %r14,0x8(%rax)
		return CHUNK_TO_MEM(self);
  4046fd:	4c 8d 60 10          	lea    0x10(%rax),%r12
  404701:	eb 7f                	jmp    404782 <realloc+0x132>
  404703:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		if (*n) {
  404708:	48 85 f6             	test   %rsi,%rsi
  40470b:	0f 85 49 01 00 00    	jne    40485a <realloc+0x20a>
			*n = SIZE_ALIGN;
  404711:	bb 20 00 00 00       	mov    $0x20,%ebx
  404716:	e9 6e ff ff ff       	jmpq   404689 <realloc+0x39>
  40471b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	if (n > n1 && alloc_fwd(next)) {
  404720:	4c 89 e7             	mov    %r12,%rdi
  404723:	48 89 14 24          	mov    %rdx,(%rsp)
  404727:	e8 54 ee ff ff       	callq  403580 <alloc_fwd>
  40472c:	85 c0                	test   %eax,%eax
  40472e:	0f 84 dc 00 00 00    	je     404810 <realloc+0x1c0>
		n1 += CHUNK_SIZE(next);
  404734:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
	if (n <= n1) {
  404739:	48 8b 14 24          	mov    (%rsp),%rdx
		n1 += CHUNK_SIZE(next);
  40473d:	48 83 e1 fe          	and    $0xfffffffffffffffe,%rcx
  404741:	49 8d 74 0d 00       	lea    0x0(%r13,%rcx,1),%rsi
	self->csize = n1 | C_INUSE;
  404746:	48 89 f0             	mov    %rsi,%rax
  404749:	48 83 c8 01          	or     $0x1,%rax
	if (n <= n1) {
  40474d:	48 39 de             	cmp    %rbx,%rsi
	self->csize = n1 | C_INUSE;
  404750:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	next->psize = n1 | C_INUSE;
  404754:	49 89 04 0c          	mov    %rax,(%r12,%rcx,1)
	if (n <= n1) {
  404758:	73 61                	jae    4047bb <realloc+0x16b>
	new = malloc(n-OVERHEAD);
  40475a:	48 8d 7b f0          	lea    -0x10(%rbx),%rdi
  40475e:	e8 7d f8 ff ff       	callq  403fe0 <malloc>
	if (!new) return 0;
  404763:	48 85 c0             	test   %rax,%rax
	new = malloc(n-OVERHEAD);
  404766:	49 89 c4             	mov    %rax,%r12
	if (!new) return 0;
  404769:	74 17                	je     404782 <realloc+0x132>
	memcpy(new, p, n0-OVERHEAD);
  40476b:	49 8d 55 f0          	lea    -0x10(%r13),%rdx
  40476f:	4c 89 e7             	mov    %r12,%rdi
  404772:	48 89 ee             	mov    %rbp,%rsi
  404775:	e8 62 0b 00 00       	callq  4052dc <memcpy>
	free(CHUNK_TO_MEM(self));
  40477a:	48 89 ef             	mov    %rbp,%rdi
  40477d:	e8 9e f3 ff ff       	callq  403b20 <free>
}
  404782:	48 83 c4 18          	add    $0x18,%rsp
  404786:	4c 89 e0             	mov    %r12,%rax
  404789:	5b                   	pop    %rbx
  40478a:	5d                   	pop    %rbp
  40478b:	41 5c                	pop    %r12
  40478d:	41 5d                	pop    %r13
  40478f:	41 5e                	pop    %r14
  404791:	41 5f                	pop    %r15
  404793:	c3                   	retq   
  404794:	0f 1f 40 00          	nopl   0x0(%rax)
	next = NEXT_CHUNK(self);
  404798:	4e 8d 24 2a          	lea    (%rdx,%r13,1),%r12
	if (next->psize != self->csize) a_crash();
  40479c:	49 3b 04 24          	cmp    (%r12),%rax
  4047a0:	74 01                	je     4047a3 <realloc+0x153>
  4047a2:	f4                   	hlt    
	if (n > n1 && alloc_fwd(next)) {
  4047a3:	49 39 dd             	cmp    %rbx,%r13
  4047a6:	0f 82 74 ff ff ff    	jb     404720 <realloc+0xd0>
	self->csize = n1 | C_INUSE;
  4047ac:	4c 89 e8             	mov    %r13,%rax
  4047af:	48 83 c8 01          	or     $0x1,%rax
  4047b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	next->psize = n1 | C_INUSE;
  4047b7:	49 89 04 24          	mov    %rax,(%r12)
	size_t n1 = CHUNK_SIZE(self);
  4047bb:	48 83 e0 fe          	and    $0xfffffffffffffffe,%rax
	if (n >= n1 - DONTCARE) return;
  4047bf:	48 8d 48 f0          	lea    -0x10(%rax),%rcx
  4047c3:	48 39 d9             	cmp    %rbx,%rcx
  4047c6:	77 60                	ja     404828 <realloc+0x1d8>
	free(CHUNK_TO_MEM(split));
  4047c8:	49 89 ec             	mov    %rbp,%r12
  4047cb:	eb b5                	jmp    404782 <realloc+0x132>
  4047cd:	0f 1f 00             	nopl   (%rax)
		if (newlen < PAGE_SIZE && (new = malloc(n))) {
  4047d0:	48 89 df             	mov    %rbx,%rdi
  4047d3:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  4047d8:	48 89 14 24          	mov    %rdx,(%rsp)
  4047dc:	e8 ff f7 ff ff       	callq  403fe0 <malloc>
  4047e1:	48 85 c0             	test   %rax,%rax
  4047e4:	49 89 c4             	mov    %rax,%r12
  4047e7:	48 8b 14 24          	mov    (%rsp),%rdx
  4047eb:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  4047f0:	0f 84 cb fe ff ff    	je     4046c1 <realloc+0x71>
			memcpy(new, p, n-OVERHEAD);
  4047f6:	48 8d 53 f0          	lea    -0x10(%rbx),%rdx
  4047fa:	e9 70 ff ff ff       	jmpq   40476f <realloc+0x11f>
  4047ff:	90                   	nop
	if (!p) return malloc(n);
  404800:	48 89 f7             	mov    %rsi,%rdi
  404803:	e9 d8 f7 ff ff       	jmpq   403fe0 <malloc>
  404808:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40480f:	00 
	self->csize = n1 | C_INUSE;
  404810:	4c 89 e8             	mov    %r13,%rax
  404813:	48 83 c8 01          	or     $0x1,%rax
  404817:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	next->psize = n1 | C_INUSE;
  40481b:	49 89 04 24          	mov    %rax,(%r12)
  40481f:	e9 36 ff ff ff       	jmpq   40475a <realloc+0x10a>
  404824:	0f 1f 40 00          	nopl   0x0(%rax)
	split->csize = n1-n | C_INUSE;
  404828:	48 89 c1             	mov    %rax,%rcx
	split = (void *)((char *)self + n);
  40482b:	48 01 da             	add    %rbx,%rdx
	split->psize = n | C_INUSE;
  40482e:	48 89 de             	mov    %rbx,%rsi
	split->csize = n1-n | C_INUSE;
  404831:	48 29 d9             	sub    %rbx,%rcx
	split->psize = n | C_INUSE;
  404834:	48 83 ce 01          	or     $0x1,%rsi
	free(CHUNK_TO_MEM(split));
  404838:	48 8d 7a 10          	lea    0x10(%rdx),%rdi
	split->csize = n1-n | C_INUSE;
  40483c:	48 83 c9 01          	or     $0x1,%rcx
	split->psize = n | C_INUSE;
  404840:	48 89 32             	mov    %rsi,(%rdx)
	split->csize = n1-n | C_INUSE;
  404843:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
	next->psize = n1-n | C_INUSE;
  404847:	48 89 4c 05 f0       	mov    %rcx,-0x10(%rbp,%rax,1)
	self->csize = n | C_INUSE;
  40484c:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
	free(CHUNK_TO_MEM(split));
  404850:	e8 cb f2 ff ff       	callq  403b20 <free>
  404855:	e9 6e ff ff ff       	jmpq   4047c8 <realloc+0x178>
			errno = ENOMEM;
  40485a:	e8 51 ec ff ff       	callq  4034b0 <__errno_location>
	if (adjust_size(&n) < 0) return 0;
  40485f:	45 31 e4             	xor    %r12d,%r12d
			errno = ENOMEM;
  404862:	c7 00 0c 00 00 00    	movl   $0xc,(%rax)
  404868:	e9 15 ff ff ff       	jmpq   404782 <realloc+0x132>

000000000040486d <__fpclassifyl>:
	return __fpclassify(x);
}
#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
int __fpclassifyl(long double x)
{
	union ldshape u = {x};
  40486d:	db 6c 24 08          	fldt   0x8(%rsp)
  404871:	db 7c 24 e8          	fstpt  -0x18(%rsp)
  404875:	8b 54 24 f0          	mov    -0x10(%rsp),%edx
	int e = u.i.se & 0x7fff;
	int msb = u.i.m>>63;
  404879:	48 8b 4c 24 e8       	mov    -0x18(%rsp),%rcx
  40487e:	66 81 e2 ff 7f       	and    $0x7fff,%dx
  404883:	48 89 ce             	mov    %rcx,%rsi
  404886:	48 c1 ee 3f          	shr    $0x3f,%rsi
	int e = u.i.se & 0x7fff;
  40488a:	0f b7 c2             	movzwl %dx,%eax
	if (!e && !msb)
  40488d:	09 f0                	or     %esi,%eax
  40488f:	75 0c                	jne    40489d <__fpclassifyl+0x30>
		return u.i.m ? FP_SUBNORMAL : FP_ZERO;
  404891:	31 c0                	xor    %eax,%eax
  404893:	48 85 c9             	test   %rcx,%rcx
  404896:	0f 95 c0             	setne  %al
  404899:	83 c0 02             	add    $0x2,%eax
  40489c:	c3                   	retq   
	if (!msb)
		return FP_NAN;
  40489d:	31 c0                	xor    %eax,%eax
	if (!msb)
  40489f:	48 85 f6             	test   %rsi,%rsi
  4048a2:	74 14                	je     4048b8 <__fpclassifyl+0x4b>
	if (e == 0x7fff)
  4048a4:	66 81 fa ff 7f       	cmp    $0x7fff,%dx
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
	return FP_NORMAL;
  4048a9:	b8 04 00 00 00       	mov    $0x4,%eax
	if (e == 0x7fff)
  4048ae:	75 08                	jne    4048b8 <__fpclassifyl+0x4b>
		return u.i.m << 1 ? FP_NAN : FP_INFINITE;
  4048b0:	31 c0                	xor    %eax,%eax
  4048b2:	48 01 c9             	add    %rcx,%rcx
  4048b5:	0f 94 c0             	sete   %al
}
  4048b8:	c3                   	retq   

00000000004048b9 <__signbitl>:
#include "libm.h"

#if (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
int __signbitl(long double x)
{
	union ldshape u = {x};
  4048b9:	db 6c 24 08          	fldt   0x8(%rsp)
  4048bd:	db 7c 24 e8          	fstpt  -0x18(%rsp)
	return u.i.se >> 15;
  4048c1:	8b 44 24 f0          	mov    -0x10(%rsp),%eax
  4048c5:	66 c1 e8 0f          	shr    $0xf,%ax
  4048c9:	0f b7 c0             	movzwl %ax,%eax
}
  4048cc:	c3                   	retq   

00000000004048cd <frexpl>:
{
	return frexp(x, e);
}
#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
long double frexpl(long double x, int *e)
{
  4048cd:	53                   	push   %rbx
  4048ce:	48 83 ec 10          	sub    $0x10,%rsp
  4048d2:	db 6c 24 20          	fldt   0x20(%rsp)
	union ldshape u = {x};
  4048d6:	d9 c0                	fld    %st(0)
  4048d8:	db 3c 24             	fstpt  (%rsp)
	int ee = u.i.se & 0x7fff;
  4048db:	8b 44 24 08          	mov    0x8(%rsp),%eax

	if (!ee) {
  4048df:	89 c1                	mov    %eax,%ecx
  4048e1:	66 81 e1 ff 7f       	and    $0x7fff,%cx
  4048e6:	75 30                	jne    404918 <frexpl+0x4b>
		if (x) {
  4048e8:	d9 ee                	fldz   
  4048ea:	d9 c9                	fxch   %st(1)
  4048ec:	db e9                	fucomi %st(1),%st
  4048ee:	dd d9                	fstp   %st(1)
  4048f0:	7a 02                	jp     4048f4 <frexpl+0x27>
  4048f2:	74 1c                	je     404910 <frexpl+0x43>
			x = frexpl(x*0x1p120, e);
  4048f4:	d8 0d 82 22 00 00    	fmuls  0x2282(%rip)        # 406b7c <bin_tab+0x3c>
  4048fa:	48 83 ec 10          	sub    $0x10,%rsp
  4048fe:	48 89 fb             	mov    %rdi,%rbx
  404901:	db 3c 24             	fstpt  (%rsp)
  404904:	e8 c4 ff ff ff       	callq  4048cd <frexpl>
			*e -= 120;
  404909:	83 2b 78             	subl   $0x78,(%rbx)
  40490c:	59                   	pop    %rcx
  40490d:	5e                   	pop    %rsi
  40490e:	eb 2c                	jmp    40493c <frexpl+0x6f>
		} else *e = 0;
  404910:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
  404916:	eb 24                	jmp    40493c <frexpl+0x6f>
		return x;
	} else if (ee == 0x7fff) {
  404918:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
	int ee = u.i.se & 0x7fff;
  40491d:	0f b7 d1             	movzwl %cx,%edx
	} else if (ee == 0x7fff) {
  404920:	74 1a                	je     40493c <frexpl+0x6f>
  404922:	dd d8                	fstp   %st(0)
		return x;
	}

	*e = ee - 0x3ffe;
	u.i.se &= 0x8000;
  404924:	66 25 00 80          	and    $0x8000,%ax
	*e = ee - 0x3ffe;
  404928:	81 ea fe 3f 00 00    	sub    $0x3ffe,%edx
	u.i.se |= 0x3ffe;
  40492e:	66 0d fe 3f          	or     $0x3ffe,%ax
	*e = ee - 0x3ffe;
  404932:	89 17                	mov    %edx,(%rdi)
	u.i.se |= 0x3ffe;
  404934:	66 89 44 24 08       	mov    %ax,0x8(%rsp)
	return u.f;
  404939:	db 2c 24             	fldt   (%rsp)
}
  40493c:	48 83 c4 10          	add    $0x10,%rsp
  404940:	5b                   	pop    %rbx
  404941:	c3                   	retq   

0000000000404942 <__madvise>:
#include <sys/mman.h>
#include "syscall.h"
#include "libc.h"

int __madvise(void *addr, size_t len, int advice)
{
  404942:	48 83 ec 08          	sub    $0x8,%rsp
	return syscall(SYS_madvise, addr, len, advice);
  404946:	48 63 d2             	movslq %edx,%rdx
  404949:	b8 1c 00 00 00       	mov    $0x1c,%eax
  40494e:	0f 05                	syscall 
  404950:	48 89 c7             	mov    %rax,%rdi
  404953:	e8 d8 eb ff ff       	callq  403530 <__syscall_ret>
}
  404958:	5a                   	pop    %rdx
  404959:	c3                   	retq   

000000000040495a <__vm_wait>:
#include <stdint.h>
#include <limits.h>
#include "syscall.h"
#include "libc.h"

static void dummy(void) { }
  40495a:	c3                   	retq   

000000000040495b <__mmap>:

#define UNIT SYSCALL_MMAP2_UNIT
#define OFF_MASK ((-0x2000ULL << (8*sizeof(syscall_arg_t)-1)) | (UNIT-1))

void *__mmap(void *start, size_t len, int prot, int flags, int fd, off_t off)
{
  40495b:	55                   	push   %rbp
  40495c:	53                   	push   %rbx
  40495d:	48 83 ec 28          	sub    $0x28,%rsp
	long ret;
	if (off & OFF_MASK) {
  404961:	41 f7 c1 ff 0f 00 00 	test   $0xfff,%r9d
  404968:	74 0d                	je     404977 <__mmap+0x1c>
		errno = EINVAL;
  40496a:	e8 41 eb ff ff       	callq  4034b0 <__errno_location>
  40496f:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
  404975:	eb 1a                	jmp    404991 <__mmap+0x36>
		return MAP_FAILED;
	}
	if (len >= PTRDIFF_MAX) {
  404977:	48 b8 fe ff ff ff ff 	movabs $0x7ffffffffffffffe,%rax
  40497e:	ff ff 7f 
  404981:	48 39 c6             	cmp    %rax,%rsi
  404984:	76 16                	jbe    40499c <__mmap+0x41>
		errno = ENOMEM;
  404986:	e8 25 eb ff ff       	callq  4034b0 <__errno_location>
  40498b:	c7 00 0c 00 00 00    	movl   $0xc,(%rax)
#endif
	/* Fixup incorrect EPERM from kernel. */
	if (ret == -EPERM && !start && (flags&MAP_ANON) && !(flags&MAP_FIXED))
		ret = -ENOMEM;
	return (void *)__syscall_ret(ret);
}
  404991:	48 83 c4 28          	add    $0x28,%rsp
		errno = ENOMEM;
  404995:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
}
  404999:	5b                   	pop    %rbx
  40499a:	5d                   	pop    %rbp
  40499b:	c3                   	retq   
	if (flags & MAP_FIXED) {
  40499c:	f6 c1 10             	test   $0x10,%cl
  40499f:	89 d5                	mov    %edx,%ebp
  4049a1:	89 cb                	mov    %ecx,%ebx
  4049a3:	74 2b                	je     4049d0 <__mmap+0x75>
  4049a5:	4c 89 4c 24 18       	mov    %r9,0x18(%rsp)
  4049aa:	44 89 44 24 14       	mov    %r8d,0x14(%rsp)
  4049af:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  4049b4:	48 89 3c 24          	mov    %rdi,(%rsp)
		__vm_wait();
  4049b8:	e8 9d ff ff ff       	callq  40495a <__vm_wait>
  4049bd:	4c 8b 4c 24 18       	mov    0x18(%rsp),%r9
  4049c2:	44 8b 44 24 14       	mov    0x14(%rsp),%r8d
  4049c7:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  4049cc:	48 8b 3c 24          	mov    (%rsp),%rdi
	ret = __syscall(SYS_mmap, start, len, prot, flags, fd, off);
  4049d0:	48 63 d5             	movslq %ebp,%rdx
  4049d3:	4c 63 d3             	movslq %ebx,%r10

static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6)
{
	unsigned long ret;
	register long r10 __asm__("r10") = a4;
	register long r8 __asm__("r8") = a5;
  4049d6:	4d 63 c0             	movslq %r8d,%r8
	register long r9 __asm__("r9") = a6;
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  4049d9:	b8 09 00 00 00       	mov    $0x9,%eax
  4049de:	0f 05                	syscall 
	if (ret == -EPERM && !start && (flags&MAP_ANON) && !(flags&MAP_FIXED))
  4049e0:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  4049e4:	75 17                	jne    4049fd <__mmap+0xa2>
  4049e6:	48 85 ff             	test   %rdi,%rdi
  4049e9:	75 12                	jne    4049fd <__mmap+0xa2>
  4049eb:	83 e3 30             	and    $0x30,%ebx
		ret = -ENOMEM;
  4049ee:	31 c0                	xor    %eax,%eax
  4049f0:	83 fb 20             	cmp    $0x20,%ebx
  4049f3:	0f 95 c0             	setne  %al
  4049f6:	48 f7 d8             	neg    %rax
  4049f9:	48 83 c8 f4          	or     $0xfffffffffffffff4,%rax
}
  4049fd:	48 83 c4 28          	add    $0x28,%rsp
	return (void *)__syscall_ret(ret);
  404a01:	48 89 c7             	mov    %rax,%rdi
}
  404a04:	5b                   	pop    %rbx
  404a05:	5d                   	pop    %rbp
	return (void *)__syscall_ret(ret);
  404a06:	e9 25 eb ff ff       	jmpq   403530 <__syscall_ret>

0000000000404a0b <dummy>:
#include <stdint.h>
#include <stdarg.h>
#include "syscall.h"
#include "libc.h"

static void dummy(void) { }
  404a0b:	c3                   	retq   

0000000000404a0c <__mremap>:
weak_alias(dummy, __vm_wait);

void *__mremap(void *old_addr, size_t old_len, size_t new_len, int flags, ...)
{
  404a0c:	53                   	push   %rbx
	va_list ap;
	void *new_addr = 0;

	if (new_len >= PTRDIFF_MAX) {
  404a0d:	48 b8 fe ff ff ff ff 	movabs $0x7ffffffffffffffe,%rax
  404a14:	ff ff 7f 
{
  404a17:	48 83 ec 70          	sub    $0x70,%rsp
	if (new_len >= PTRDIFF_MAX) {
  404a1b:	48 39 c2             	cmp    %rax,%rdx
{
  404a1e:	4c 89 44 24 60       	mov    %r8,0x60(%rsp)
	if (new_len >= PTRDIFF_MAX) {
  404a23:	76 11                	jbe    404a36 <__mremap+0x2a>
		errno = ENOMEM;
  404a25:	e8 86 ea ff ff       	callq  4034b0 <__errno_location>
  404a2a:	c7 00 0c 00 00 00    	movl   $0xc,(%rax)
		return MAP_FAILED;
  404a30:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
  404a34:	eb 63                	jmp    404a99 <__mremap+0x8d>
	void *new_addr = 0;
  404a36:	45 31 c0             	xor    %r8d,%r8d
	}

	if (flags & MREMAP_FIXED) {
  404a39:	f6 c1 02             	test   $0x2,%cl
  404a3c:	89 cb                	mov    %ecx,%ebx
  404a3e:	74 47                	je     404a87 <__mremap+0x7b>
  404a40:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  404a45:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  404a4a:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
		__vm_wait();
  404a4f:	e8 06 ff ff ff       	callq  40495a <__vm_wait>
		va_start(ap, flags);
  404a54:	48 8d 84 24 80 00 00 	lea    0x80(%rsp),%rax
  404a5b:	00 
		new_addr = va_arg(ap, void *);
  404a5c:	4c 8b 44 24 60       	mov    0x60(%rsp),%r8
  404a61:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  404a66:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  404a6b:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
		va_start(ap, flags);
  404a70:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  404a75:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
  404a7a:	c7 44 24 28 20 00 00 	movl   $0x20,0x28(%rsp)
  404a81:	00 
  404a82:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
		va_end(ap);
	}

	return (void *)syscall(SYS_mremap, old_addr, old_len, new_len, flags, new_addr);
  404a87:	4c 63 d3             	movslq %ebx,%r10
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  404a8a:	b8 19 00 00 00       	mov    $0x19,%eax
  404a8f:	0f 05                	syscall 
  404a91:	48 89 c7             	mov    %rax,%rdi
  404a94:	e8 97 ea ff ff       	callq  403530 <__syscall_ret>
}
  404a99:	48 83 c4 70          	add    $0x70,%rsp
  404a9d:	5b                   	pop    %rbx
  404a9e:	c3                   	retq   

0000000000404a9f <dummy>:
#include <sys/mman.h>
#include "syscall.h"
#include "libc.h"

static void dummy(void) { }
  404a9f:	c3                   	retq   

0000000000404aa0 <__munmap>:
weak_alias(dummy, __vm_wait);

int __munmap(void *start, size_t len)
{
  404aa0:	48 83 ec 18          	sub    $0x18,%rsp
  404aa4:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  404aa9:	48 89 34 24          	mov    %rsi,(%rsp)
	__vm_wait();
  404aad:	e8 a8 fe ff ff       	callq  40495a <__vm_wait>
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2)
  404ab2:	b8 0b 00 00 00       	mov    $0xb,%eax
  404ab7:	48 8b 34 24          	mov    (%rsp),%rsi
  404abb:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  404ac0:	0f 05                	syscall 
  404ac2:	48 89 c7             	mov    %rax,%rdi
	return syscall(SYS_munmap, start, len);
  404ac5:	e8 66 ea ff ff       	callq  403530 <__syscall_ret>
}
  404aca:	48 83 c4 18          	add    $0x18,%rsp
  404ace:	c3                   	retq   

0000000000404acf <wctomb>:
#include <stdlib.h>
#include <wchar.h>

int wctomb(char *s, wchar_t wc)
{
	if (!s) return 0;
  404acf:	48 85 ff             	test   %rdi,%rdi
  404ad2:	74 0d                	je     404ae1 <wctomb+0x12>
{
  404ad4:	48 83 ec 08          	sub    $0x8,%rsp
	return wcrtomb(s, wc, 0);
  404ad8:	31 d2                	xor    %edx,%edx
  404ada:	e8 10 0d 00 00       	callq  4057ef <wcrtomb>
}
  404adf:	5a                   	pop    %rdx
  404ae0:	c3                   	retq   
  404ae1:	31 c0                	xor    %eax,%eax
  404ae3:	c3                   	retq   

0000000000404ae4 <__fdopen>:
#include <fcntl.h>
#include <errno.h>
#include <string.h>

FILE *__fdopen(int fd, const char *mode)
{
  404ae4:	41 54                	push   %r12
  404ae6:	55                   	push   %rbp
  404ae7:	49 89 f4             	mov    %rsi,%r12
  404aea:	53                   	push   %rbx
  404aeb:	89 fd                	mov    %edi,%ebp
	FILE *f;
	struct winsize wsz;

	/* Check for valid initial mode character */
	if (!strchr("rwa", *mode)) {
  404aed:	48 8d 3d 1c 15 00 00 	lea    0x151c(%rip),%rdi        # 406010 <_fini+0x64d>
{
  404af4:	48 83 ec 10          	sub    $0x10,%rsp
	if (!strchr("rwa", *mode)) {
  404af8:	0f be 36             	movsbl (%rsi),%esi
  404afb:	e8 e0 e5 ff ff       	callq  4030e0 <strchr>
  404b00:	48 85 c0             	test   %rax,%rax
  404b03:	75 12                	jne    404b17 <__fdopen+0x33>
		errno = EINVAL;
  404b05:	e8 a6 e9 ff ff       	callq  4034b0 <__errno_location>
		return 0;
  404b0a:	31 db                	xor    %ebx,%ebx
		errno = EINVAL;
  404b0c:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
		return 0;
  404b12:	e9 32 01 00 00       	jmpq   404c49 <__fdopen+0x165>
	}

	/* Allocate FILE+buffer or fail */
	if (!(f=malloc(sizeof *f + UNGET + BUFSIZ))) return 0;
  404b17:	bf f0 04 00 00       	mov    $0x4f0,%edi
  404b1c:	e8 bf f4 ff ff       	callq  403fe0 <malloc>
  404b21:	48 85 c0             	test   %rax,%rax
  404b24:	48 89 c3             	mov    %rax,%rbx
  404b27:	0f 84 1c 01 00 00    	je     404c49 <__fdopen+0x165>

	/* Zero-fill only the struct, not the buffer */
	memset(f, 0, sizeof *f);
  404b2d:	31 f6                	xor    %esi,%esi
  404b2f:	ba e8 00 00 00       	mov    $0xe8,%edx
  404b34:	48 89 c7             	mov    %rax,%rdi
  404b37:	e8 81 e7 ff ff       	callq  4032bd <memset>

	/* Impose mode restrictions */
	if (!strchr(mode, '+')) f->flags = (*mode == 'r') ? F_NOWR : F_NORD;
  404b3c:	be 2b 00 00 00       	mov    $0x2b,%esi
  404b41:	4c 89 e7             	mov    %r12,%rdi
  404b44:	e8 97 e5 ff ff       	callq  4030e0 <strchr>
  404b49:	48 85 c0             	test   %rax,%rax
  404b4c:	75 13                	jne    404b61 <__fdopen+0x7d>
  404b4e:	31 c0                	xor    %eax,%eax
  404b50:	41 80 3c 24 72       	cmpb   $0x72,(%r12)
  404b55:	0f 94 c0             	sete   %al
  404b58:	8d 04 85 04 00 00 00 	lea    0x4(,%rax,4),%eax
  404b5f:	89 03                	mov    %eax,(%rbx)

	/* Apply close-on-exec flag */
	if (strchr(mode, 'e')) __syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
  404b61:	be 65 00 00 00       	mov    $0x65,%esi
  404b66:	4c 89 e7             	mov    %r12,%rdi
  404b69:	e8 72 e5 ff ff       	callq  4030e0 <strchr>
  404b6e:	48 85 c0             	test   %rax,%rax
  404b71:	74 14                	je     404b87 <__fdopen+0xa3>
  404b73:	48 63 fd             	movslq %ebp,%rdi
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  404b76:	ba 01 00 00 00       	mov    $0x1,%edx
  404b7b:	be 02 00 00 00       	mov    $0x2,%esi
  404b80:	b8 48 00 00 00       	mov    $0x48,%eax
  404b85:	0f 05                	syscall 

	/* Set append mode on fd if opened for append */
	if (*mode == 'a') {
  404b87:	41 80 3c 24 61       	cmpb   $0x61,(%r12)
  404b8c:	75 2f                	jne    404bbd <__fdopen+0xd9>
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2)
  404b8e:	41 b8 48 00 00 00    	mov    $0x48,%r8d
		int flags = __syscall(SYS_fcntl, fd, F_GETFL);
  404b94:	48 63 fd             	movslq %ebp,%rdi
  404b97:	be 03 00 00 00       	mov    $0x3,%esi
  404b9c:	4c 89 c0             	mov    %r8,%rax
  404b9f:	0f 05                	syscall 
		if (!(flags & O_APPEND))
  404ba1:	0f ba e0 0a          	bt     $0xa,%eax
  404ba5:	72 10                	jb     404bb7 <__fdopen+0xd3>
			__syscall(SYS_fcntl, fd, F_SETFL, flags | O_APPEND);
  404ba7:	80 cc 04             	or     $0x4,%ah
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  404baa:	be 04 00 00 00       	mov    $0x4,%esi
  404baf:	48 63 d0             	movslq %eax,%rdx
  404bb2:	4c 89 c0             	mov    %r8,%rax
  404bb5:	0f 05                	syscall 
		f->flags |= F_APP;
  404bb7:	81 0b 80 00 00 00    	orl    $0x80,(%rbx)
	f->buf = (unsigned char *)f + sizeof *f + UNGET;
	f->buf_size = BUFSIZ;

	/* Activate line buffered mode for terminals */
	f->lbf = EOF;
	if (!(f->flags & F_NOWR) && !__syscall(SYS_ioctl, fd, TIOCGWINSZ, &wsz))
  404bbd:	f6 03 08             	testb  $0x8,(%rbx)
	f->buf = (unsigned char *)f + sizeof *f + UNGET;
  404bc0:	48 8d 83 f0 00 00 00 	lea    0xf0(%rbx),%rax
	f->fd = fd;
  404bc7:	89 6b 78             	mov    %ebp,0x78(%rbx)
	f->buf_size = BUFSIZ;
  404bca:	48 c7 43 60 00 04 00 	movq   $0x400,0x60(%rbx)
  404bd1:	00 
	f->lbf = EOF;
  404bd2:	c6 83 8b 00 00 00 ff 	movb   $0xff,0x8b(%rbx)
	f->buf = (unsigned char *)f + sizeof *f + UNGET;
  404bd9:	48 89 43 58          	mov    %rax,0x58(%rbx)
	if (!(f->flags & F_NOWR) && !__syscall(SYS_ioctl, fd, TIOCGWINSZ, &wsz))
  404bdd:	75 20                	jne    404bff <__fdopen+0x11b>
  404bdf:	48 63 fd             	movslq %ebp,%rdi
  404be2:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  404be7:	be 13 54 00 00       	mov    $0x5413,%esi
  404bec:	b8 10 00 00 00       	mov    $0x10,%eax
  404bf1:	0f 05                	syscall 
  404bf3:	48 85 c0             	test   %rax,%rax
  404bf6:	75 07                	jne    404bff <__fdopen+0x11b>
		f->lbf = '\n';
  404bf8:	c6 83 8b 00 00 00 0a 	movb   $0xa,0x8b(%rbx)

	/* Initialize op ptrs. No problem if some are unneeded. */
	f->read = __stdio_read;
  404bff:	48 c7 c0 fd 4d 40 00 	mov    $0x404dfd,%rax
	f->write = __stdio_write;
	f->seek = __stdio_seek;
	f->close = __stdio_close;

	if (!libc.threaded) f->lock = -1;
  404c06:	83 3d 37 56 a0 10 00 	cmpl   $0x0,0x10a05637(%rip)        # 10e0a244 <__libc+0x4>
	f->read = __stdio_read;
  404c0d:	48 89 43 40          	mov    %rax,0x40(%rbx)
	f->write = __stdio_write;
  404c11:	48 c7 c0 bc 4e 40 00 	mov    $0x404ebc,%rax
  404c18:	48 89 43 48          	mov    %rax,0x48(%rbx)
	f->seek = __stdio_seek;
  404c1c:	48 c7 c0 a6 4e 40 00 	mov    $0x404ea6,%rax
  404c23:	48 89 43 50          	mov    %rax,0x50(%rbx)
	f->close = __stdio_close;
  404c27:	48 c7 c0 dd 4d 40 00 	mov    $0x404ddd,%rax
  404c2e:	48 89 43 18          	mov    %rax,0x18(%rbx)
	if (!libc.threaded) f->lock = -1;
  404c32:	75 0a                	jne    404c3e <__fdopen+0x15a>
  404c34:	c7 83 8c 00 00 00 ff 	movl   $0xffffffff,0x8c(%rbx)
  404c3b:	ff ff ff 

	/* Add new FILE to open file list */
	return __ofl_add(f);
  404c3e:	48 89 df             	mov    %rbx,%rdi
  404c41:	e8 5a 05 00 00       	callq  4051a0 <__ofl_add>
  404c46:	48 89 c3             	mov    %rax,%rbx
}
  404c49:	48 83 c4 10          	add    $0x10,%rsp
  404c4d:	48 89 d8             	mov    %rbx,%rax
  404c50:	5b                   	pop    %rbx
  404c51:	5d                   	pop    %rbp
  404c52:	41 5c                	pop    %r12
  404c54:	c3                   	retq   

0000000000404c55 <__fmodeflags>:
#include <fcntl.h>
#include <string.h>

int __fmodeflags(const char *mode)
{
  404c55:	55                   	push   %rbp
  404c56:	53                   	push   %rbx
	int flags;
	if (strchr(mode, '+')) flags = O_RDWR;
  404c57:	be 2b 00 00 00       	mov    $0x2b,%esi
{
  404c5c:	48 89 fd             	mov    %rdi,%rbp
  404c5f:	bb 02 00 00 00       	mov    $0x2,%ebx
  404c64:	48 83 ec 08          	sub    $0x8,%rsp
	if (strchr(mode, '+')) flags = O_RDWR;
  404c68:	e8 73 e4 ff ff       	callq  4030e0 <strchr>
  404c6d:	48 85 c0             	test   %rax,%rax
  404c70:	75 09                	jne    404c7b <__fmodeflags+0x26>
	else if (*mode == 'r') flags = O_RDONLY;
  404c72:	31 db                	xor    %ebx,%ebx
  404c74:	80 7d 00 72          	cmpb   $0x72,0x0(%rbp)
  404c78:	0f 95 c3             	setne  %bl
	else flags = O_WRONLY;
	if (strchr(mode, 'x')) flags |= O_EXCL;
  404c7b:	be 78 00 00 00       	mov    $0x78,%esi
  404c80:	48 89 ef             	mov    %rbp,%rdi
  404c83:	e8 58 e4 ff ff       	callq  4030e0 <strchr>
  404c88:	89 da                	mov    %ebx,%edx
	if (strchr(mode, 'e')) flags |= O_CLOEXEC;
  404c8a:	be 65 00 00 00       	mov    $0x65,%esi
  404c8f:	48 89 ef             	mov    %rbp,%rdi
	if (strchr(mode, 'x')) flags |= O_EXCL;
  404c92:	80 ca 80             	or     $0x80,%dl
  404c95:	48 85 c0             	test   %rax,%rax
  404c98:	0f 45 da             	cmovne %edx,%ebx
	if (strchr(mode, 'e')) flags |= O_CLOEXEC;
  404c9b:	e8 40 e4 ff ff       	callq  4030e0 <strchr>
  404ca0:	89 da                	mov    %ebx,%edx
  404ca2:	81 ca 00 00 08 00    	or     $0x80000,%edx
  404ca8:	48 85 c0             	test   %rax,%rax
	if (*mode != 'r') flags |= O_CREAT;
  404cab:	8a 45 00             	mov    0x0(%rbp),%al
	if (strchr(mode, 'e')) flags |= O_CLOEXEC;
  404cae:	0f 45 da             	cmovne %edx,%ebx
	if (*mode != 'r') flags |= O_CREAT;
  404cb1:	3c 72                	cmp    $0x72,%al
  404cb3:	74 1c                	je     404cd1 <__fmodeflags+0x7c>
	if (*mode == 'w') flags |= O_TRUNC;
  404cb5:	3c 77                	cmp    $0x77,%al
  404cb7:	75 08                	jne    404cc1 <__fmodeflags+0x6c>
  404cb9:	81 cb 40 02 00 00    	or     $0x240,%ebx
  404cbf:	eb 10                	jmp    404cd1 <__fmodeflags+0x7c>
	if (*mode != 'r') flags |= O_CREAT;
  404cc1:	89 da                	mov    %ebx,%edx
  404cc3:	81 cb 40 04 00 00    	or     $0x440,%ebx
  404cc9:	83 ca 40             	or     $0x40,%edx
  404ccc:	3c 61                	cmp    $0x61,%al
  404cce:	0f 45 da             	cmovne %edx,%ebx
	if (*mode == 'a') flags |= O_APPEND;
	return flags;
}
  404cd1:	89 d8                	mov    %ebx,%eax
  404cd3:	5a                   	pop    %rdx
  404cd4:	5b                   	pop    %rbx
  404cd5:	5d                   	pop    %rbp
  404cd6:	c3                   	retq   

0000000000404cd7 <__lockfile>:
#include "stdio_impl.h"
#include "pthread_impl.h"

int __lockfile(FILE *f)
{
  404cd7:	41 54                	push   %r12
  404cd9:	55                   	push   %rbp
  404cda:	53                   	push   %rbx
  404cdb:	64 48 8b 04 25 00 00 	mov    %fs:0x0,%rax
  404ce2:	00 00 
	int owner, tid = __pthread_self()->tid;
  404ce4:	8b 68 38             	mov    0x38(%rax),%ebp
	if (f->lock == tid)
  404ce7:	8b 97 8c 00 00 00    	mov    0x8c(%rdi),%edx
  404ced:	31 c0                	xor    %eax,%eax
  404cef:	39 d5                	cmp    %edx,%ebp
  404cf1:	74 33                	je     404d26 <__lockfile+0x4f>
		return 0;
	while ((owner = a_cas(&f->lock, 0, tid)))
  404cf3:	4c 8d a7 8c 00 00 00 	lea    0x8c(%rdi),%r12
  404cfa:	48 89 fb             	mov    %rdi,%rbx
	__asm__ __volatile__ (
  404cfd:	31 c0                	xor    %eax,%eax
  404cff:	f0 41 0f b1 2c 24    	lock cmpxchg %ebp,(%r12)
  404d05:	85 c0                	test   %eax,%eax
  404d07:	89 c2                	mov    %eax,%edx
  404d09:	74 16                	je     404d21 <__lockfile+0x4a>
		__wait(&f->lock, &f->waiters, owner, 1);
  404d0b:	48 8d b3 90 00 00 00 	lea    0x90(%rbx),%rsi
  404d12:	b9 01 00 00 00       	mov    $0x1,%ecx
  404d17:	4c 89 e7             	mov    %r12,%rdi
  404d1a:	e8 da e6 ff ff       	callq  4033f9 <__wait>
  404d1f:	eb dc                	jmp    404cfd <__lockfile+0x26>
	return 1;
  404d21:	b8 01 00 00 00       	mov    $0x1,%eax
}
  404d26:	5b                   	pop    %rbx
  404d27:	5d                   	pop    %rbp
  404d28:	41 5c                	pop    %r12
  404d2a:	c3                   	retq   

0000000000404d2b <__unlockfile>:

void __unlockfile(FILE *f)
{
  404d2b:	48 89 f8             	mov    %rdi,%rax
	__asm__ __volatile__(
  404d2e:	31 d2                	xor    %edx,%edx
	a_store(&f->lock, 0);
  404d30:	48 8d bf 8c 00 00 00 	lea    0x8c(%rdi),%rdi
  404d37:	89 90 8c 00 00 00    	mov    %edx,0x8c(%rax)
  404d3d:	f0 83 0c 24 00       	lock orl $0x0,(%rsp)
	 * obtained by malloc from the heap, it's safe to assume
	 * the dereferences below will not fault. In the worst case,
	 * a spurious syscall will be made. If the implementation of
	 * malloc changes, this assumption needs revisiting. */

	if (f->waiters) __wake(&f->lock, 1, 1);
  404d42:	8b 80 90 00 00 00    	mov    0x90(%rax),%eax
  404d48:	85 c0                	test   %eax,%eax
  404d4a:	74 23                	je     404d6f <__unlockfile+0x44>
  404d4c:	41 b8 ca 00 00 00    	mov    $0xca,%r8d
  404d52:	ba 01 00 00 00       	mov    $0x1,%edx
  404d57:	be 81 00 00 00       	mov    $0x81,%esi
  404d5c:	4c 89 c0             	mov    %r8,%rax
  404d5f:	0f 05                	syscall 
  404d61:	48 83 f8 da          	cmp    $0xffffffffffffffda,%rax
  404d65:	75 08                	jne    404d6f <__unlockfile+0x44>
  404d67:	4c 89 c0             	mov    %r8,%rax
  404d6a:	48 89 d6             	mov    %rdx,%rsi
  404d6d:	0f 05                	syscall 
  404d6f:	c3                   	retq   

0000000000404d70 <__overflow>:
#include "stdio_impl.h"

int __overflow(FILE *f, int _c)
{
  404d70:	53                   	push   %rbx
  404d71:	48 89 fb             	mov    %rdi,%rbx
  404d74:	48 83 ec 10          	sub    $0x10,%rsp
	unsigned char c = _c;
	if (!f->wend && __towrite(f)) return EOF;
  404d78:	48 83 7f 20 00       	cmpq   $0x0,0x20(%rdi)
	unsigned char c = _c;
  404d7d:	40 88 74 24 0f       	mov    %sil,0xf(%rsp)
	if (!f->wend && __towrite(f)) return EOF;
  404d82:	74 0c                	je     404d90 <__overflow+0x20>
	if (f->wpos < f->wend && c != f->lbf) return *f->wpos++ = c;
  404d84:	48 8b 53 28          	mov    0x28(%rbx),%rdx
  404d88:	48 3b 53 20          	cmp    0x20(%rbx),%rdx
  404d8c:	72 10                	jb     404d9e <__overflow+0x2e>
  404d8e:	eb 2a                	jmp    404dba <__overflow+0x4a>
	if (!f->wend && __towrite(f)) return EOF;
  404d90:	e8 56 02 00 00       	callq  404feb <__towrite>
  404d95:	85 c0                	test   %eax,%eax
  404d97:	74 eb                	je     404d84 <__overflow+0x14>
  404d99:	83 c8 ff             	or     $0xffffffff,%eax
  404d9c:	eb 36                	jmp    404dd4 <__overflow+0x64>
	if (f->wpos < f->wend && c != f->lbf) return *f->wpos++ = c;
  404d9e:	0f b6 44 24 0f       	movzbl 0xf(%rsp),%eax
  404da3:	0f be b3 8b 00 00 00 	movsbl 0x8b(%rbx),%esi
  404daa:	39 f0                	cmp    %esi,%eax
  404dac:	74 0c                	je     404dba <__overflow+0x4a>
  404dae:	48 8d 72 01          	lea    0x1(%rdx),%rsi
  404db2:	48 89 73 28          	mov    %rsi,0x28(%rbx)
  404db6:	88 02                	mov    %al,(%rdx)
  404db8:	eb 1a                	jmp    404dd4 <__overflow+0x64>
	if (f->write(f, &c, 1)!=1) return EOF;
  404dba:	48 8d 74 24 0f       	lea    0xf(%rsp),%rsi
  404dbf:	ba 01 00 00 00       	mov    $0x1,%edx
  404dc4:	48 89 df             	mov    %rbx,%rdi
  404dc7:	ff 53 48             	callq  *0x48(%rbx)
  404dca:	48 ff c8             	dec    %rax
  404dcd:	75 ca                	jne    404d99 <__overflow+0x29>
	return c;
  404dcf:	0f b6 44 24 0f       	movzbl 0xf(%rsp),%eax
}
  404dd4:	48 83 c4 10          	add    $0x10,%rsp
  404dd8:	5b                   	pop    %rbx
  404dd9:	c3                   	retq   

0000000000404dda <__aio_close>:
#include "stdio_impl.h"

static int dummy(int fd)
{
  404dda:	89 f8                	mov    %edi,%eax
	return fd;
}
  404ddc:	c3                   	retq   

0000000000404ddd <__stdio_close>:

weak_alias(dummy, __aio_close);

int __stdio_close(FILE *f)
{
  404ddd:	48 83 ec 08          	sub    $0x8,%rsp
	return syscall(SYS_close, __aio_close(f->fd));
  404de1:	8b 7f 78             	mov    0x78(%rdi),%edi
  404de4:	e8 f1 ff ff ff       	callq  404dda <__aio_close>
  404de9:	48 63 f8             	movslq %eax,%rdi
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
  404dec:	b8 03 00 00 00       	mov    $0x3,%eax
  404df1:	0f 05                	syscall 
  404df3:	48 89 c7             	mov    %rax,%rdi
  404df6:	e8 35 e7 ff ff       	callq  403530 <__syscall_ret>
}
  404dfb:	5a                   	pop    %rdx
  404dfc:	c3                   	retq   

0000000000404dfd <__stdio_read>:
#include "stdio_impl.h"
#include <sys/uio.h>

size_t __stdio_read(FILE *f, unsigned char *buf, size_t len)
{
  404dfd:	41 54                	push   %r12
  404dff:	55                   	push   %rbp
  404e00:	48 89 d5             	mov    %rdx,%rbp
  404e03:	53                   	push   %rbx
	struct iovec iov[2] = {
		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
  404e04:	31 d2                	xor    %edx,%edx
  404e06:	48 89 e9             	mov    %rbp,%rcx
{
  404e09:	48 89 fb             	mov    %rdi,%rbx
  404e0c:	49 89 f4             	mov    %rsi,%r12
  404e0f:	48 83 ec 20          	sub    $0x20,%rsp
		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
  404e13:	48 8b 47 60          	mov    0x60(%rdi),%rax
	struct iovec iov[2] = {
  404e17:	48 89 34 24          	mov    %rsi,(%rsp)
		{ .iov_base = f->buf, .iov_len = f->buf_size }
	};
	ssize_t cnt;

	cnt = syscall(SYS_readv, f->fd, iov, 2);
  404e1b:	48 89 e6             	mov    %rsp,%rsi
		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
  404e1e:	48 85 c0             	test   %rax,%rax
	struct iovec iov[2] = {
  404e21:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2),
  404e26:	b8 13 00 00 00       	mov    $0x13,%eax
		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
  404e2b:	0f 95 c2             	setne  %dl
  404e2e:	48 29 d1             	sub    %rdx,%rcx
	struct iovec iov[2] = {
  404e31:	48 8b 57 58          	mov    0x58(%rdi),%rdx
	cnt = syscall(SYS_readv, f->fd, iov, 2);
  404e35:	48 63 7f 78          	movslq 0x78(%rdi),%rdi
		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
  404e39:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
	struct iovec iov[2] = {
  404e3e:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  404e43:	ba 02 00 00 00       	mov    $0x2,%edx
  404e48:	0f 05                	syscall 
  404e4a:	48 89 c7             	mov    %rax,%rdi
	cnt = syscall(SYS_readv, f->fd, iov, 2);
  404e4d:	e8 de e6 ff ff       	callq  403530 <__syscall_ret>
	if (cnt <= 0) {
  404e52:	48 85 c0             	test   %rax,%rax
  404e55:	7f 0c                	jg     404e63 <__stdio_read+0x66>
		f->flags |= F_EOF ^ ((F_ERR^F_EOF) & cnt);
  404e57:	89 c2                	mov    %eax,%edx
  404e59:	83 e2 30             	and    $0x30,%edx
  404e5c:	83 f2 10             	xor    $0x10,%edx
  404e5f:	09 13                	or     %edx,(%rbx)
  404e61:	eb 34                	jmp    404e97 <__stdio_read+0x9a>
		return cnt;
	}
	if (cnt <= iov[0].iov_len) return cnt;
  404e63:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  404e68:	48 39 c1             	cmp    %rax,%rcx
  404e6b:	73 2a                	jae    404e97 <__stdio_read+0x9a>
	cnt -= iov[0].iov_len;
	f->rpos = f->buf;
  404e6d:	48 8b 53 58          	mov    0x58(%rbx),%rdx
	cnt -= iov[0].iov_len;
  404e71:	48 29 c8             	sub    %rcx,%rax
	f->rend = f->buf + cnt;
  404e74:	48 01 d0             	add    %rdx,%rax
	if (f->buf_size) buf[len-1] = *f->rpos++;
  404e77:	48 83 7b 60 00       	cmpq   $0x0,0x60(%rbx)
	f->rpos = f->buf;
  404e7c:	48 89 53 08          	mov    %rdx,0x8(%rbx)
	f->rend = f->buf + cnt;
  404e80:	48 89 43 10          	mov    %rax,0x10(%rbx)
	if (f->buf_size) buf[len-1] = *f->rpos++;
  404e84:	74 14                	je     404e9a <__stdio_read+0x9d>
  404e86:	48 8d 42 01          	lea    0x1(%rdx),%rax
  404e8a:	48 89 43 08          	mov    %rax,0x8(%rbx)
  404e8e:	8a 02                	mov    (%rdx),%al
  404e90:	41 88 44 2c ff       	mov    %al,-0x1(%r12,%rbp,1)
  404e95:	eb 03                	jmp    404e9a <__stdio_read+0x9d>
  404e97:	48 89 c5             	mov    %rax,%rbp
	return len;
}
  404e9a:	48 83 c4 20          	add    $0x20,%rsp
  404e9e:	48 89 e8             	mov    %rbp,%rax
  404ea1:	5b                   	pop    %rbx
  404ea2:	5d                   	pop    %rbp
  404ea3:	41 5c                	pop    %r12
  404ea5:	c3                   	retq   

0000000000404ea6 <__stdio_seek>:
	off_t ret;
#ifdef SYS__llseek
	if (syscall(SYS__llseek, f->fd, off>>32, off, &ret, whence)<0)
		ret = -1;
#else
	ret = syscall(SYS_lseek, f->fd, off, whence);
  404ea6:	48 63 7f 78          	movslq 0x78(%rdi),%rdi
  404eaa:	48 63 d2             	movslq %edx,%rdx
  404ead:	b8 08 00 00 00       	mov    $0x8,%eax
  404eb2:	0f 05                	syscall 
  404eb4:	48 89 c7             	mov    %rax,%rdi
  404eb7:	e9 74 e6 ff ff       	jmpq   403530 <__syscall_ret>

0000000000404ebc <__stdio_write>:
#include "stdio_impl.h"
#include <sys/uio.h>

size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
{
  404ebc:	41 57                	push   %r15
  404ebe:	41 56                	push   %r14
  404ec0:	49 89 d7             	mov    %rdx,%r15
  404ec3:	41 55                	push   %r13
  404ec5:	41 54                	push   %r12
		{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },
		{ .iov_base = (void *)buf, .iov_len = len }
	};
	struct iovec *iov = iovs;
	size_t rem = iov[0].iov_len + iov[1].iov_len;
	int iovcnt = 2;
  404ec7:	41 bd 02 00 00 00    	mov    $0x2,%r13d
{
  404ecd:	55                   	push   %rbp
  404ece:	53                   	push   %rbx
  404ecf:	41 be 14 00 00 00    	mov    $0x14,%r14d
  404ed5:	48 89 fb             	mov    %rdi,%rbx
  404ed8:	48 83 ec 28          	sub    $0x28,%rsp
		{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },
  404edc:	48 8b 47 38          	mov    0x38(%rdi),%rax
  404ee0:	4c 8b 67 28          	mov    0x28(%rdi),%r12
	struct iovec iovs[2] = {
  404ee4:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  404ee9:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
	struct iovec *iov = iovs;
  404eee:	48 89 e5             	mov    %rsp,%rbp
		{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },
  404ef1:	49 29 c4             	sub    %rax,%r12
	struct iovec iovs[2] = {
  404ef4:	48 89 04 24          	mov    %rax,(%rsp)
  404ef8:	4c 89 64 24 08       	mov    %r12,0x8(%rsp)
	size_t rem = iov[0].iov_len + iov[1].iov_len;
  404efd:	49 01 d4             	add    %rdx,%r12
	ssize_t cnt;
	for (;;) {
		cnt = syscall(SYS_writev, f->fd, iov, iovcnt);
  404f00:	48 63 7b 78          	movslq 0x78(%rbx),%rdi
  404f04:	49 63 d5             	movslq %r13d,%rdx
  404f07:	4c 89 f0             	mov    %r14,%rax
  404f0a:	48 89 ee             	mov    %rbp,%rsi
  404f0d:	0f 05                	syscall 
  404f0f:	48 89 c7             	mov    %rax,%rdi
  404f12:	e8 19 e6 ff ff       	callq  403530 <__syscall_ret>
		if (cnt == rem) {
  404f17:	49 39 c4             	cmp    %rax,%r12
  404f1a:	75 19                	jne    404f35 <__stdio_write+0x79>
			f->wend = f->buf + f->buf_size;
  404f1c:	48 8b 43 58          	mov    0x58(%rbx),%rax
  404f20:	48 89 c2             	mov    %rax,%rdx
  404f23:	48 03 53 60          	add    0x60(%rbx),%rdx
			f->wpos = f->wbase = f->buf;
  404f27:	48 89 43 38          	mov    %rax,0x38(%rbx)
  404f2b:	48 89 43 28          	mov    %rax,0x28(%rbx)
			f->wend = f->buf + f->buf_size;
  404f2f:	48 89 53 20          	mov    %rdx,0x20(%rbx)
			return len;
  404f33:	eb 52                	jmp    404f87 <__stdio_write+0xcb>
		}
		if (cnt < 0) {
  404f35:	48 85 c0             	test   %rax,%rax
  404f38:	79 27                	jns    404f61 <__stdio_write+0xa5>
			f->wpos = f->wbase = f->wend = 0;
			f->flags |= F_ERR;
  404f3a:	83 0b 20             	orl    $0x20,(%rbx)
			return iovcnt == 2 ? 0 : len-iov[0].iov_len;
  404f3d:	41 83 fd 02          	cmp    $0x2,%r13d
			f->wpos = f->wbase = f->wend = 0;
  404f41:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
  404f48:	00 
  404f49:	48 c7 43 38 00 00 00 	movq   $0x0,0x38(%rbx)
  404f50:	00 
  404f51:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
  404f58:	00 
			return iovcnt == 2 ? 0 : len-iov[0].iov_len;
  404f59:	74 29                	je     404f84 <__stdio_write+0xc8>
  404f5b:	4c 2b 7d 08          	sub    0x8(%rbp),%r15
  404f5f:	eb 26                	jmp    404f87 <__stdio_write+0xcb>
		}
		rem -= cnt;
		if (cnt > iov[0].iov_len) {
  404f61:	48 8b 55 08          	mov    0x8(%rbp),%rdx
		rem -= cnt;
  404f65:	49 29 c4             	sub    %rax,%r12
		if (cnt > iov[0].iov_len) {
  404f68:	48 39 d0             	cmp    %rdx,%rax
  404f6b:	76 0a                	jbe    404f77 <__stdio_write+0xbb>
			cnt -= iov[0].iov_len;
  404f6d:	48 29 d0             	sub    %rdx,%rax
			iov++; iovcnt--;
  404f70:	48 83 c5 10          	add    $0x10,%rbp
  404f74:	41 ff cd             	dec    %r13d
		}
		iov[0].iov_base = (char *)iov[0].iov_base + cnt;
  404f77:	48 01 45 00          	add    %rax,0x0(%rbp)
		iov[0].iov_len -= cnt;
  404f7b:	48 29 45 08          	sub    %rax,0x8(%rbp)
		cnt = syscall(SYS_writev, f->fd, iov, iovcnt);
  404f7f:	e9 7c ff ff ff       	jmpq   404f00 <__stdio_write+0x44>
			return iovcnt == 2 ? 0 : len-iov[0].iov_len;
  404f84:	45 31 ff             	xor    %r15d,%r15d
	}
}
  404f87:	48 83 c4 28          	add    $0x28,%rsp
  404f8b:	4c 89 f8             	mov    %r15,%rax
  404f8e:	5b                   	pop    %rbx
  404f8f:	5d                   	pop    %rbp
  404f90:	41 5c                	pop    %r12
  404f92:	41 5d                	pop    %r13
  404f94:	41 5e                	pop    %r14
  404f96:	41 5f                	pop    %r15
  404f98:	c3                   	retq   

0000000000404f99 <__stdout_write>:
#include "stdio_impl.h"
#include <sys/ioctl.h>

size_t __stdout_write(FILE *f, const unsigned char *buf, size_t len)
{
  404f99:	48 83 ec 18          	sub    $0x18,%rsp
	struct winsize wsz;
	f->write = __stdio_write;
	if (!(f->flags & F_SVB) && __syscall(SYS_ioctl, f->fd, TIOCGWINSZ, &wsz))
  404f9d:	f6 07 40             	testb  $0x40,(%rdi)
	f->write = __stdio_write;
  404fa0:	48 c7 c0 bc 4e 40 00 	mov    $0x404ebc,%rax
{
  404fa7:	49 89 f8             	mov    %rdi,%r8
  404faa:	49 89 f1             	mov    %rsi,%r9
  404fad:	49 89 d2             	mov    %rdx,%r10
	f->write = __stdio_write;
  404fb0:	48 89 47 48          	mov    %rax,0x48(%rdi)
	if (!(f->flags & F_SVB) && __syscall(SYS_ioctl, f->fd, TIOCGWINSZ, &wsz))
  404fb4:	75 22                	jne    404fd8 <__stdout_write+0x3f>
  404fb6:	48 63 7f 78          	movslq 0x78(%rdi),%rdi
  404fba:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
  404fbf:	be 13 54 00 00       	mov    $0x5413,%esi
  404fc4:	b8 10 00 00 00       	mov    $0x10,%eax
  404fc9:	0f 05                	syscall 
  404fcb:	48 85 c0             	test   %rax,%rax
  404fce:	74 08                	je     404fd8 <__stdout_write+0x3f>
		f->lbf = -1;
  404fd0:	41 c6 80 8b 00 00 00 	movb   $0xff,0x8b(%r8)
  404fd7:	ff 
	return __stdio_write(f, buf, len);
  404fd8:	4c 89 d2             	mov    %r10,%rdx
  404fdb:	4c 89 ce             	mov    %r9,%rsi
  404fde:	4c 89 c7             	mov    %r8,%rdi
  404fe1:	e8 d6 fe ff ff       	callq  404ebc <__stdio_write>
}
  404fe6:	48 83 c4 18          	add    $0x18,%rsp
  404fea:	c3                   	retq   

0000000000404feb <__towrite>:
#include "stdio_impl.h"

int __towrite(FILE *f)
{
	f->mode |= f->mode-1;
  404feb:	8a 97 8a 00 00 00    	mov    0x8a(%rdi),%dl
  404ff1:	8d 42 ff             	lea    -0x1(%rdx),%eax
  404ff4:	09 d0                	or     %edx,%eax
  404ff6:	88 87 8a 00 00 00    	mov    %al,0x8a(%rdi)
	if (f->flags & (F_NOWR)) {
  404ffc:	8b 07                	mov    (%rdi),%eax
  404ffe:	a8 08                	test   $0x8,%al
  405000:	74 09                	je     40500b <__towrite+0x20>
		f->flags |= F_ERR;
  405002:	83 c8 20             	or     $0x20,%eax
  405005:	89 07                	mov    %eax,(%rdi)
		return EOF;
  405007:	83 c8 ff             	or     $0xffffffff,%eax
  40500a:	c3                   	retq   
	}
	/* Clear read buffer (easier than summoning nasal demons) */
	f->rpos = f->rend = 0;

	/* Activate write through the buffer. */
	f->wpos = f->wbase = f->buf;
  40500b:	48 8b 47 58          	mov    0x58(%rdi),%rax
	f->rpos = f->rend = 0;
  40500f:	48 c7 47 10 00 00 00 	movq   $0x0,0x10(%rdi)
  405016:	00 
  405017:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
  40501e:	00 
	f->wpos = f->wbase = f->buf;
  40501f:	48 89 47 38          	mov    %rax,0x38(%rdi)
  405023:	48 89 47 28          	mov    %rax,0x28(%rdi)
	f->wend = f->buf + f->buf_size;
  405027:	48 03 47 60          	add    0x60(%rdi),%rax
  40502b:	48 89 47 20          	mov    %rax,0x20(%rdi)

	return 0;
  40502f:	31 c0                	xor    %eax,%eax
}
  405031:	c3                   	retq   

0000000000405032 <__towrite_needs_stdio_exit>:

void __stdio_exit_needed(void);

void __towrite_needs_stdio_exit()
{
	__stdio_exit_needed();
  405032:	e9 19 09 00 00       	jmpq   405950 <__stdio_exit>

0000000000405037 <fputs>:
#include "stdio_impl.h"
#include <string.h>

int fputs(const char *restrict s, FILE *restrict f)
{
  405037:	41 54                	push   %r12
  405039:	55                   	push   %rbp
  40503a:	49 89 f4             	mov    %rsi,%r12
  40503d:	53                   	push   %rbx
  40503e:	48 89 fd             	mov    %rdi,%rbp
	size_t l = strlen(s);
  405041:	e8 ba e1 ff ff       	callq  403200 <strlen>
	return (fwrite(s, 1, l, f)==l) - 1;
  405046:	4c 89 e1             	mov    %r12,%rcx
	size_t l = strlen(s);
  405049:	48 89 c3             	mov    %rax,%rbx
	return (fwrite(s, 1, l, f)==l) - 1;
  40504c:	48 89 ef             	mov    %rbp,%rdi
  40504f:	48 89 c2             	mov    %rax,%rdx
  405052:	be 01 00 00 00       	mov    $0x1,%esi
  405057:	e8 bb 00 00 00       	callq  405117 <fwrite>
  40505c:	48 39 c3             	cmp    %rax,%rbx
  40505f:	0f 95 c0             	setne  %al
  405062:	0f b6 c0             	movzbl %al,%eax
}
  405065:	5b                   	pop    %rbx
	return (fwrite(s, 1, l, f)==l) - 1;
  405066:	f7 d8                	neg    %eax
}
  405068:	5d                   	pop    %rbp
  405069:	41 5c                	pop    %r12
  40506b:	c3                   	retq   

000000000040506c <__fwritex>:
#include "stdio_impl.h"
#include <string.h>

size_t __fwritex(const unsigned char *restrict s, size_t l, FILE *restrict f)
{
  40506c:	41 55                	push   %r13
  40506e:	41 54                	push   %r12
  405070:	49 89 fd             	mov    %rdi,%r13
  405073:	55                   	push   %rbp
  405074:	53                   	push   %rbx
  405075:	49 89 f4             	mov    %rsi,%r12
  405078:	48 89 d3             	mov    %rdx,%rbx
  40507b:	48 83 ec 08          	sub    $0x8,%rsp
	size_t i=0;

	if (!f->wend && __towrite(f)) return 0;
  40507f:	48 83 7a 20 00       	cmpq   $0x0,0x20(%rdx)
  405084:	74 23                	je     4050a9 <__fwritex+0x3d>

	if (l > f->wend - f->wpos) return f->write(f, s, l);
  405086:	48 8b 43 20          	mov    0x20(%rbx),%rax
  40508a:	48 2b 43 28          	sub    0x28(%rbx),%rax
  40508e:	4c 39 e0             	cmp    %r12,%rax
  405091:	73 26                	jae    4050b9 <__fwritex+0x4d>
  405093:	48 8b 43 48          	mov    0x48(%rbx),%rax
  405097:	4c 89 e2             	mov    %r12,%rdx
  40509a:	4c 89 ee             	mov    %r13,%rsi
	}

	memcpy(f->wpos, s, l);
	f->wpos += l;
	return l+i;
}
  40509d:	59                   	pop    %rcx
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  40509e:	48 89 df             	mov    %rbx,%rdi
}
  4050a1:	5b                   	pop    %rbx
  4050a2:	5d                   	pop    %rbp
  4050a3:	41 5c                	pop    %r12
  4050a5:	41 5d                	pop    %r13
	if (l > f->wend - f->wpos) return f->write(f, s, l);
  4050a7:	ff e0                	jmpq   *%rax
	if (!f->wend && __towrite(f)) return 0;
  4050a9:	48 89 d7             	mov    %rdx,%rdi
  4050ac:	e8 3a ff ff ff       	callq  404feb <__towrite>
  4050b1:	85 c0                	test   %eax,%eax
  4050b3:	74 d1                	je     405086 <__fwritex+0x1a>
  4050b5:	31 c0                	xor    %eax,%eax
  4050b7:	eb 56                	jmp    40510f <__fwritex+0xa3>
	if (f->lbf >= 0) {
  4050b9:	80 bb 8b 00 00 00 00 	cmpb   $0x0,0x8b(%rbx)
  4050c0:	4c 89 e5             	mov    %r12,%rbp
  4050c3:	78 16                	js     4050db <__fwritex+0x6f>
		for (i=l; i && s[i-1] != '\n'; i--);
  4050c5:	48 85 ed             	test   %rbp,%rbp
  4050c8:	74 13                	je     4050dd <__fwritex+0x71>
  4050ca:	41 80 7c 2d ff 0a    	cmpb   $0xa,-0x1(%r13,%rbp,1)
  4050d0:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  4050d4:	74 20                	je     4050f6 <__fwritex+0x8a>
  4050d6:	48 89 c5             	mov    %rax,%rbp
  4050d9:	eb ea                	jmp    4050c5 <__fwritex+0x59>
	size_t i=0;
  4050db:	31 ed                	xor    %ebp,%ebp
	memcpy(f->wpos, s, l);
  4050dd:	48 8b 7b 28          	mov    0x28(%rbx),%rdi
  4050e1:	4c 89 e2             	mov    %r12,%rdx
  4050e4:	4c 89 ee             	mov    %r13,%rsi
  4050e7:	e8 f0 01 00 00       	callq  4052dc <memcpy>
	f->wpos += l;
  4050ec:	4c 01 63 28          	add    %r12,0x28(%rbx)
	return l+i;
  4050f0:	49 8d 04 2c          	lea    (%r12,%rbp,1),%rax
  4050f4:	eb 19                	jmp    40510f <__fwritex+0xa3>
			size_t n = f->write(f, s, i);
  4050f6:	48 89 ea             	mov    %rbp,%rdx
  4050f9:	4c 89 ee             	mov    %r13,%rsi
  4050fc:	48 89 df             	mov    %rbx,%rdi
  4050ff:	ff 53 48             	callq  *0x48(%rbx)
			if (n < i) return n;
  405102:	48 39 c5             	cmp    %rax,%rbp
  405105:	77 08                	ja     40510f <__fwritex+0xa3>
			s += i;
  405107:	49 01 ed             	add    %rbp,%r13
			l -= i;
  40510a:	49 29 ec             	sub    %rbp,%r12
  40510d:	eb ce                	jmp    4050dd <__fwritex+0x71>
}
  40510f:	5a                   	pop    %rdx
  405110:	5b                   	pop    %rbx
  405111:	5d                   	pop    %rbp
  405112:	41 5c                	pop    %r12
  405114:	41 5d                	pop    %r13
  405116:	c3                   	retq   

0000000000405117 <fwrite>:

size_t fwrite(const void *restrict src, size_t size, size_t nmemb, FILE *restrict f)
{
  405117:	41 57                	push   %r15
  405119:	41 56                	push   %r14
	size_t k, l = size*nmemb;
	if (!size) nmemb = 0;
  40511b:	b8 00 00 00 00       	mov    $0x0,%eax
{
  405120:	41 55                	push   %r13
  405122:	41 54                	push   %r12
	size_t k, l = size*nmemb;
  405124:	49 89 f5             	mov    %rsi,%r13
{
  405127:	55                   	push   %rbp
  405128:	53                   	push   %rbx
  405129:	48 89 d3             	mov    %rdx,%rbx
	size_t k, l = size*nmemb;
  40512c:	4c 0f af ea          	imul   %rdx,%r13
{
  405130:	49 89 ff             	mov    %rdi,%r15
  405133:	48 89 f5             	mov    %rsi,%rbp
  405136:	48 83 ec 18          	sub    $0x18,%rsp
	if (!size) nmemb = 0;
  40513a:	48 85 f6             	test   %rsi,%rsi
{
  40513d:	49 89 cc             	mov    %rcx,%r12
	if (!size) nmemb = 0;
  405140:	48 0f 44 d8          	cmove  %rax,%rbx
	FLOCK(f);
  405144:	8b 81 8c 00 00 00    	mov    0x8c(%rcx),%eax
  40514a:	45 31 f6             	xor    %r14d,%r14d
  40514d:	85 c0                	test   %eax,%eax
  40514f:	78 0b                	js     40515c <fwrite+0x45>
  405151:	48 89 cf             	mov    %rcx,%rdi
  405154:	e8 7e fb ff ff       	callq  404cd7 <__lockfile>
  405159:	41 89 c6             	mov    %eax,%r14d
	k = __fwritex(src, l, f);
  40515c:	4c 89 e2             	mov    %r12,%rdx
  40515f:	4c 89 ee             	mov    %r13,%rsi
  405162:	4c 89 ff             	mov    %r15,%rdi
  405165:	e8 02 ff ff ff       	callq  40506c <__fwritex>
	FUNLOCK(f);
  40516a:	45 85 f6             	test   %r14d,%r14d
  40516d:	74 12                	je     405181 <fwrite+0x6a>
  40516f:	4c 89 e7             	mov    %r12,%rdi
  405172:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  405177:	e8 af fb ff ff       	callq  404d2b <__unlockfile>
  40517c:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
	return k==l ? nmemb : k/size;
  405181:	49 39 c5             	cmp    %rax,%r13
  405184:	74 08                	je     40518e <fwrite+0x77>
  405186:	31 d2                	xor    %edx,%edx
  405188:	48 f7 f5             	div    %rbp
  40518b:	48 89 c3             	mov    %rax,%rbx
}
  40518e:	48 83 c4 18          	add    $0x18,%rsp
  405192:	48 89 d8             	mov    %rbx,%rax
  405195:	5b                   	pop    %rbx
  405196:	5d                   	pop    %rbp
  405197:	41 5c                	pop    %r12
  405199:	41 5d                	pop    %r13
  40519b:	41 5e                	pop    %r14
  40519d:	41 5f                	pop    %r15
  40519f:	c3                   	retq   

00000000004051a0 <__ofl_add>:
#include "stdio_impl.h"

FILE *__ofl_add(FILE *f)
{
  4051a0:	53                   	push   %rbx
  4051a1:	48 89 fb             	mov    %rdi,%rbx
	FILE **head = __ofl_lock();
  4051a4:	e8 b2 c4 ff ff       	callq  40165b <__ofl_lock>
	f->next = *head;
  4051a9:	48 8b 10             	mov    (%rax),%rdx
  4051ac:	48 89 53 70          	mov    %rdx,0x70(%rbx)
	if (*head) (*head)->prev = f;
  4051b0:	48 8b 10             	mov    (%rax),%rdx
  4051b3:	48 85 d2             	test   %rdx,%rdx
  4051b6:	74 04                	je     4051bc <__ofl_add+0x1c>
  4051b8:	48 89 5a 68          	mov    %rbx,0x68(%rdx)
	*head = f;
  4051bc:	48 89 18             	mov    %rbx,(%rax)
	__ofl_unlock();
  4051bf:	e8 b0 c4 ff ff       	callq  401674 <__ofl_unlock>
	return f;
}
  4051c4:	48 89 d8             	mov    %rbx,%rax
  4051c7:	5b                   	pop    %rbx
  4051c8:	c3                   	retq   
  4051c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000004051d0 <memchr>:

void *memchr(const void *src, int c, size_t n)
{
	const unsigned char *s = src;
	c = (unsigned char)c;
	for (; ((uintptr_t)s & ALIGN) && n && *s != c; s++, n--);
  4051d0:	40 f6 c7 07          	test   $0x7,%dil
  4051d4:	40 0f b6 f6          	movzbl %sil,%esi
  4051d8:	75 1f                	jne    4051f9 <memchr+0x29>
  4051da:	eb 2c                	jmp    405208 <memchr+0x38>
  4051dc:	0f 1f 40 00          	nopl   0x0(%rax)
  4051e0:	0f b6 07             	movzbl (%rdi),%eax
  4051e3:	39 c6                	cmp    %eax,%esi
  4051e5:	0f 84 e5 00 00 00    	je     4052d0 <memchr+0x100>
  4051eb:	48 83 c7 01          	add    $0x1,%rdi
  4051ef:	48 83 ea 01          	sub    $0x1,%rdx
  4051f3:	40 f6 c7 07          	test   $0x7,%dil
  4051f7:	74 0f                	je     405208 <memchr+0x38>
  4051f9:	48 85 d2             	test   %rdx,%rdx
  4051fc:	75 e2                	jne    4051e0 <memchr+0x10>
		const size_t *w;
		size_t k = ONES * c;
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
		for (s = (const void *)w; n && *s != c; s++, n--);
	}
	return n ? (void *)s : 0;
  4051fe:	31 c0                	xor    %eax,%eax
  405200:	c3                   	retq   
  405201:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  405208:	31 c0                	xor    %eax,%eax
	if (n && *s != c) {
  40520a:	48 85 d2             	test   %rdx,%rdx
  40520d:	0f 84 c0 00 00 00    	je     4052d3 <memchr+0x103>
  405213:	0f b6 07             	movzbl (%rdi),%eax
  405216:	39 c6                	cmp    %eax,%esi
  405218:	0f 84 b2 00 00 00    	je     4052d0 <memchr+0x100>
		size_t k = ONES * c;
  40521e:	4c 63 d6             	movslq %esi,%r10
  405221:	49 b8 01 01 01 01 01 	movabs $0x101010101010101,%r8
  405228:	01 01 01 
  40522b:	4d 0f af d0          	imul   %r8,%r10
		for (w = (const void *)s; n>=SS && !HASZERO(*w^k); w++, n-=SS);
  40522f:	48 83 fa 07          	cmp    $0x7,%rdx
  405233:	76 69                	jbe    40529e <memchr+0xce>
  405235:	4c 89 d0             	mov    %r10,%rax
  405238:	48 33 07             	xor    (%rdi),%rax
  40523b:	48 89 c1             	mov    %rax,%rcx
  40523e:	4c 29 c0             	sub    %r8,%rax
  405241:	49 b8 80 80 80 80 80 	movabs $0x8080808080808080,%r8
  405248:	80 80 80 
  40524b:	48 f7 d1             	not    %rcx
  40524e:	48 21 c8             	and    %rcx,%rax
  405251:	4c 85 c0             	test   %r8,%rax
  405254:	75 48                	jne    40529e <memchr+0xce>
  405256:	48 89 f8             	mov    %rdi,%rax
  405259:	49 b9 ff fe fe fe fe 	movabs $0xfefefefefefefeff,%r9
  405260:	fe fe fe 
  405263:	eb 18                	jmp    40527d <memchr+0xad>
  405265:	0f 1f 00             	nopl   (%rax)
  405268:	4c 89 d1             	mov    %r10,%rcx
  40526b:	48 33 08             	xor    (%rax),%rcx
  40526e:	4a 8d 3c 09          	lea    (%rcx,%r9,1),%rdi
  405272:	48 f7 d1             	not    %rcx
  405275:	48 21 f9             	and    %rdi,%rcx
  405278:	4c 85 c1             	test   %r8,%rcx
  40527b:	75 17                	jne    405294 <memchr+0xc4>
  40527d:	48 83 ea 08          	sub    $0x8,%rdx
  405281:	48 83 c0 08          	add    $0x8,%rax
  405285:	48 83 fa 07          	cmp    $0x7,%rdx
  405289:	77 dd                	ja     405268 <memchr+0x98>
		for (s = (const void *)w; n && *s != c; s++, n--);
  40528b:	48 85 d2             	test   %rdx,%rdx
  40528e:	0f 84 6a ff ff ff    	je     4051fe <memchr+0x2e>
  405294:	0f b6 08             	movzbl (%rax),%ecx
  405297:	48 89 c7             	mov    %rax,%rdi
  40529a:	39 ce                	cmp    %ecx,%esi
  40529c:	74 3c                	je     4052da <memchr+0x10a>
  40529e:	48 8d 4f 01          	lea    0x1(%rdi),%rcx
  4052a2:	48 01 fa             	add    %rdi,%rdx
  4052a5:	eb 14                	jmp    4052bb <memchr+0xeb>
  4052a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4052ae:	00 00 
  4052b0:	0f b6 38             	movzbl (%rax),%edi
  4052b3:	48 83 c1 01          	add    $0x1,%rcx
  4052b7:	39 fe                	cmp    %edi,%esi
  4052b9:	74 1d                	je     4052d8 <memchr+0x108>
  4052bb:	48 39 ca             	cmp    %rcx,%rdx
  4052be:	48 89 c8             	mov    %rcx,%rax
  4052c1:	75 ed                	jne    4052b0 <memchr+0xe0>
  4052c3:	e9 36 ff ff ff       	jmpq   4051fe <memchr+0x2e>
  4052c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4052cf:	00 
  4052d0:	48 89 f8             	mov    %rdi,%rax
}
  4052d3:	f3 c3                	repz retq 
  4052d5:	0f 1f 00             	nopl   (%rax)
  4052d8:	f3 c3                	repz retq 
  4052da:	f3 c3                	repz retq 

00000000004052dc <memcpy>:
.global __memcpy_fwd
.hidden __memcpy_fwd
.type memcpy,@function
memcpy:
__memcpy_fwd:
	mov %rdi,%rax
  4052dc:	48 89 f8             	mov    %rdi,%rax
	cmp $8,%rdx
  4052df:	48 83 fa 08          	cmp    $0x8,%rdx
	jc 1f
  4052e3:	72 14                	jb     4052f9 <memcpy+0x1d>
	test $7,%edi
  4052e5:	f7 c7 07 00 00 00    	test   $0x7,%edi
	jz 1f
  4052eb:	74 0c                	je     4052f9 <memcpy+0x1d>
2:	movsb
  4052ed:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
	dec %rdx
  4052ee:	48 ff ca             	dec    %rdx
	test $7,%edi
  4052f1:	f7 c7 07 00 00 00    	test   $0x7,%edi
	jnz 2b
  4052f7:	75 f4                	jne    4052ed <memcpy+0x11>
1:	mov %rdx,%rcx
  4052f9:	48 89 d1             	mov    %rdx,%rcx
	shr $3,%rcx
  4052fc:	48 c1 e9 03          	shr    $0x3,%rcx
	rep
  405300:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	movsq
	and $7,%edx
  405303:	83 e2 07             	and    $0x7,%edx
	jz 1f
  405306:	74 05                	je     40530d <memcpy+0x31>
2:	movsb
  405308:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
	dec %edx
  405309:	ff ca                	dec    %edx
	jnz 2b
  40530b:	75 fb                	jne    405308 <memcpy+0x2c>
1:	ret
  40530d:	c3                   	retq   

000000000040530e <cgt_init>:
void *__vdsosym(const char *, const char *);

static void *volatile vdso_func;

static int cgt_init(clockid_t clk, struct timespec *ts)
{
  40530e:	55                   	push   %rbp
  40530f:	53                   	push   %rbx
  405310:	48 89 f5             	mov    %rsi,%rbp
  405313:	89 fb                	mov    %edi,%ebx
	void *p = __vdsosym(VDSO_CGT_VER, VDSO_CGT_SYM);
  405315:	48 8d 35 64 18 00 00 	lea    0x1864(%rip),%rsi        # 406b80 <bin_tab+0x40>
  40531c:	48 8d 3d 72 18 00 00 	lea    0x1872(%rip),%rdi        # 406b95 <bin_tab+0x55>
{
  405323:	48 83 ec 08          	sub    $0x8,%rsp
	void *p = __vdsosym(VDSO_CGT_VER, VDSO_CGT_SYM);
  405327:	e8 a4 00 00 00       	callq  4053d0 <__vdsosym>
  40532c:	48 89 c2             	mov    %rax,%rdx
	__asm__( "lock ; cmpxchg %3, %1"
  40532f:	48 8d 05 d8 ff ff ff 	lea    -0x28(%rip),%rax        # 40530e <cgt_init>
  405336:	f0 48 0f b1 15 69 1f 	lock cmpxchg %rdx,0x201f69(%rip)        # 6072a8 <vdso_func>
  40533d:	20 00 
	int (*f)(clockid_t, struct timespec *) =
		(int (*)(clockid_t, struct timespec *))p;
	a_cas_p(&vdso_func, (void *)cgt_init, p);
	return f ? f(clk, ts) : -ENOSYS;
  40533f:	48 85 d2             	test   %rdx,%rdx
  405342:	74 0a                	je     40534e <cgt_init+0x40>
}
  405344:	59                   	pop    %rcx
	return f ? f(clk, ts) : -ENOSYS;
  405345:	48 89 ee             	mov    %rbp,%rsi
  405348:	89 df                	mov    %ebx,%edi
}
  40534a:	5b                   	pop    %rbx
  40534b:	5d                   	pop    %rbp
	return f ? f(clk, ts) : -ENOSYS;
  40534c:	ff e2                	jmpq   *%rdx
}
  40534e:	5a                   	pop    %rdx
  40534f:	b8 da ff ff ff       	mov    $0xffffffda,%eax
  405354:	5b                   	pop    %rbx
  405355:	5d                   	pop    %rbp
  405356:	c3                   	retq   

0000000000405357 <__clock_gettime>:
static void *volatile vdso_func = (void *)cgt_init;

#endif

int __clock_gettime(clockid_t clk, struct timespec *ts)
{
  405357:	55                   	push   %rbp
  405358:	53                   	push   %rbx
  405359:	89 fd                	mov    %edi,%ebp
  40535b:	48 89 f3             	mov    %rsi,%rbx
  40535e:	48 83 ec 08          	sub    $0x8,%rsp
	int r;

#ifdef VDSO_CGT_SYM
	int (*f)(clockid_t, struct timespec *) =
		(int (*)(clockid_t, struct timespec *))vdso_func;
  405362:	48 8b 05 3f 1f 20 00 	mov    0x201f3f(%rip),%rax        # 6072a8 <vdso_func>
	if (f) {
  405369:	48 85 c0             	test   %rax,%rax
  40536c:	74 12                	je     405380 <__clock_gettime+0x29>
		r = f(clk, ts);
  40536e:	ff d0                	callq  *%rax
		if (!r) return r;
  405370:	85 c0                	test   %eax,%eax
  405372:	74 4e                	je     4053c2 <__clock_gettime+0x6b>
		if (r == -EINVAL) return __syscall_ret(r);
  405374:	83 f8 ea             	cmp    $0xffffffea,%eax
  405377:	48 c7 c7 ea ff ff ff 	mov    $0xffffffffffffffea,%rdi
  40537e:	74 3d                	je     4053bd <__clock_gettime+0x66>
		 * also handles the case where cgt_init fails to find
		 * a vdso function to use. */
	}
#endif

	r = __syscall(SYS_clock_gettime, clk, ts);
  405380:	48 63 fd             	movslq %ebp,%rdi
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1), "S"(a2)
  405383:	b8 e4 00 00 00       	mov    $0xe4,%eax
  405388:	48 89 de             	mov    %rbx,%rsi
  40538b:	0f 05                	syscall 
	if (r == -ENOSYS) {
  40538d:	83 f8 da             	cmp    $0xffffffda,%eax
	r = __syscall(SYS_clock_gettime, clk, ts);
  405390:	48 63 f8             	movslq %eax,%rdi
	if (r == -ENOSYS) {
  405393:	75 28                	jne    4053bd <__clock_gettime+0x66>
		if (clk == CLOCK_REALTIME) {
  405395:	85 ed                	test   %ebp,%ebp
			__syscall(SYS_gettimeofday, ts, 0);
			ts->tv_nsec = (int)ts->tv_nsec * 1000;
			return 0;
		}
		r = -EINVAL;
  405397:	48 c7 c7 ea ff ff ff 	mov    $0xffffffffffffffea,%rdi
		if (clk == CLOCK_REALTIME) {
  40539e:	75 1d                	jne    4053bd <__clock_gettime+0x66>
  4053a0:	31 f6                	xor    %esi,%esi
  4053a2:	b8 60 00 00 00       	mov    $0x60,%eax
  4053a7:	48 89 df             	mov    %rbx,%rdi
  4053aa:	0f 05                	syscall 
			ts->tv_nsec = (int)ts->tv_nsec * 1000;
  4053ac:	69 43 08 e8 03 00 00 	imul   $0x3e8,0x8(%rbx),%eax
  4053b3:	48 98                	cltq   
  4053b5:	48 89 43 08          	mov    %rax,0x8(%rbx)
			return 0;
  4053b9:	31 c0                	xor    %eax,%eax
  4053bb:	eb 05                	jmp    4053c2 <__clock_gettime+0x6b>
	}
	return __syscall_ret(r);
  4053bd:	e8 6e e1 ff ff       	callq  403530 <__syscall_ret>
}
  4053c2:	5a                   	pop    %rdx
  4053c3:	5b                   	pop    %rbx
  4053c4:	5d                   	pop    %rbp
  4053c5:	c3                   	retq   
  4053c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4053cd:	00 00 00 

00000000004053d0 <__vdsosym>:
#define OK_BINDS (1<<STB_GLOBAL | 1<<STB_WEAK | 1<<STB_GNU_UNIQUE)

void *__vdsosym(const char *vername, const char *name)
{
	size_t i;
	for (i=0; libc.auxv[i] != AT_SYSINFO_EHDR; i+=2)
  4053d0:	4c 8b 05 79 4e a0 10 	mov    0x10a04e79(%rip),%r8        # 10e0a250 <__libc+0x10>
  4053d7:	49 8b 00             	mov    (%r8),%rax
  4053da:	48 83 f8 21          	cmp    $0x21,%rax
  4053de:	0f 84 5a 02 00 00    	je     40563e <__vdsosym+0x26e>
		if (!libc.auxv[i]) return 0;
  4053e4:	31 c9                	xor    %ecx,%ecx
  4053e6:	48 85 c0             	test   %rax,%rax
  4053e9:	75 11                	jne    4053fc <__vdsosym+0x2c>
  4053eb:	e9 80 01 00 00       	jmpq   405570 <__vdsosym+0x1a0>
  4053f0:	48 85 c0             	test   %rax,%rax
	for (i=0; libc.auxv[i] != AT_SYSINFO_EHDR; i+=2)
  4053f3:	48 89 d1             	mov    %rdx,%rcx
		if (!libc.auxv[i]) return 0;
  4053f6:	0f 84 74 01 00 00    	je     405570 <__vdsosym+0x1a0>
	for (i=0; libc.auxv[i] != AT_SYSINFO_EHDR; i+=2)
  4053fc:	48 8d 51 02          	lea    0x2(%rcx),%rdx
  405400:	49 8b 04 d0          	mov    (%r8,%rdx,8),%rax
  405404:	48 83 f8 21          	cmp    $0x21,%rax
  405408:	75 e6                	jne    4053f0 <__vdsosym+0x20>
  40540a:	48 8d 04 cd 18 00 00 	lea    0x18(,%rcx,8),%rax
  405411:	00 
	if (!libc.auxv[i+1]) return 0;
  405412:	4d 8b 1c 00          	mov    (%r8,%rax,1),%r11
  405416:	4d 85 db             	test   %r11,%r11
  405419:	0f 84 51 01 00 00    	je     405570 <__vdsosym+0x1a0>
	Ehdr *eh = (void *)libc.auxv[i+1];
	Phdr *ph = (void *)((char *)eh + eh->e_phoff);
	size_t *dynv=0, base=-1;
	for (i=0; i<eh->e_phnum; i++, ph=(void *)((char *)ph+eh->e_phentsize)) {
  40541f:	45 0f b7 4b 38       	movzwl 0x38(%r11),%r9d
	Phdr *ph = (void *)((char *)eh + eh->e_phoff);
  405424:	4c 89 da             	mov    %r11,%rdx
  405427:	49 03 53 20          	add    0x20(%r11),%rdx
	for (i=0; i<eh->e_phnum; i++, ph=(void *)((char *)ph+eh->e_phentsize)) {
  40542b:	4d 85 c9             	test   %r9,%r9
  40542e:	0f 84 3c 01 00 00    	je     405570 <__vdsosym+0x1a0>
{
  405434:	41 57                	push   %r15
  405436:	41 56                	push   %r14
	for (i=0; i<eh->e_phnum; i++, ph=(void *)((char *)ph+eh->e_phentsize)) {
  405438:	31 c0                	xor    %eax,%eax
{
  40543a:	41 55                	push   %r13
  40543c:	41 54                	push   %r12
	for (i=0; i<eh->e_phnum; i++, ph=(void *)((char *)ph+eh->e_phentsize)) {
  40543e:	31 c9                	xor    %ecx,%ecx
{
  405440:	55                   	push   %rbp
  405441:	53                   	push   %rbx
	for (i=0; i<eh->e_phnum; i++, ph=(void *)((char *)ph+eh->e_phentsize)) {
  405442:	48 c7 c5 ff ff ff ff 	mov    $0xffffffffffffffff,%rbp
{
  405449:	48 83 ec 28          	sub    $0x28,%rsp
  40544d:	45 0f b7 53 36       	movzwl 0x36(%r11),%r10d
  405452:	eb 1a                	jmp    40546e <__vdsosym+0x9e>
  405454:	0f 1f 40 00          	nopl   0x0(%rax)
		if (ph->p_type == PT_LOAD)
			base = (size_t)eh + ph->p_offset - ph->p_vaddr;
		else if (ph->p_type == PT_DYNAMIC)
  405458:	41 83 f8 02          	cmp    $0x2,%r8d
  40545c:	0f 84 d6 00 00 00    	je     405538 <__vdsosym+0x168>
	for (i=0; i<eh->e_phnum; i++, ph=(void *)((char *)ph+eh->e_phentsize)) {
  405462:	48 83 c1 01          	add    $0x1,%rcx
  405466:	4c 01 d2             	add    %r10,%rdx
  405469:	4c 39 c9             	cmp    %r9,%rcx
  40546c:	74 20                	je     40548e <__vdsosym+0xbe>
		if (ph->p_type == PT_LOAD)
  40546e:	44 8b 02             	mov    (%rdx),%r8d
  405471:	41 83 f8 01          	cmp    $0x1,%r8d
  405475:	75 e1                	jne    405458 <__vdsosym+0x88>
			base = (size_t)eh + ph->p_offset - ph->p_vaddr;
  405477:	4c 89 dd             	mov    %r11,%rbp
	for (i=0; i<eh->e_phnum; i++, ph=(void *)((char *)ph+eh->e_phentsize)) {
  40547a:	48 83 c1 01          	add    $0x1,%rcx
			base = (size_t)eh + ph->p_offset - ph->p_vaddr;
  40547e:	48 03 6a 08          	add    0x8(%rdx),%rbp
  405482:	48 2b 6a 10          	sub    0x10(%rdx),%rbp
	for (i=0; i<eh->e_phnum; i++, ph=(void *)((char *)ph+eh->e_phentsize)) {
  405486:	4c 01 d2             	add    %r10,%rdx
  405489:	4c 39 c9             	cmp    %r9,%rcx
  40548c:	75 e0                	jne    40546e <__vdsosym+0x9e>
			dynv = (void *)((char *)eh + ph->p_offset);
	}
	if (!dynv || base==(size_t)-1) return 0;
  40548e:	48 85 c0             	test   %rax,%rax
  405491:	0f 84 8c 00 00 00    	je     405523 <__vdsosym+0x153>
  405497:	48 83 fd ff          	cmp    $0xffffffffffffffff,%rbp
  40549b:	0f 84 82 00 00 00    	je     405523 <__vdsosym+0x153>
	Sym *syms = 0;
	Elf_Symndx *hashtab = 0;
	uint16_t *versym = 0;
	Verdef *verdef = 0;
	
	for (i=0; dynv[i]; i+=2) {
  4054a1:	48 8b 18             	mov    (%rax),%rbx
  4054a4:	48 85 db             	test   %rbx,%rbx
  4054a7:	74 7a                	je     405523 <__vdsosym+0x153>
  4054a9:	48 83 c0 08          	add    $0x8,%rax
  4054ad:	45 31 ed             	xor    %r13d,%r13d
  4054b0:	45 31 c0             	xor    %r8d,%r8d
  4054b3:	31 c9                	xor    %ecx,%ecx
  4054b5:	45 31 c9             	xor    %r9d,%r9d
  4054b8:	45 31 e4             	xor    %r12d,%r12d
  4054bb:	eb 22                	jmp    4054df <__vdsosym+0x10f>
  4054bd:	0f 1f 00             	nopl   (%rax)
		void *p = (void *)(base + dynv[i+1]);
		switch(dynv[i]) {
  4054c0:	48 83 fb 04          	cmp    $0x4,%rbx
  4054c4:	0f 84 96 00 00 00    	je     405560 <__vdsosym+0x190>
		case DT_STRTAB: strings = p; break;
  4054ca:	48 83 fb 05          	cmp    $0x5,%rbx
  4054ce:	4c 0f 44 e2          	cmove  %rdx,%r12
  4054d2:	48 83 c0 10          	add    $0x10,%rax
	for (i=0; dynv[i]; i+=2) {
  4054d6:	48 8b 58 f8          	mov    -0x8(%rax),%rbx
  4054da:	48 85 db             	test   %rbx,%rbx
  4054dd:	74 2f                	je     40550e <__vdsosym+0x13e>
		void *p = (void *)(base + dynv[i+1]);
  4054df:	48 89 ea             	mov    %rbp,%rdx
  4054e2:	48 03 10             	add    (%rax),%rdx
		switch(dynv[i]) {
  4054e5:	48 83 fb 06          	cmp    $0x6,%rbx
  4054e9:	74 5d                	je     405548 <__vdsosym+0x178>
  4054eb:	76 d3                	jbe    4054c0 <__vdsosym+0xf0>
  4054ed:	48 81 fb f0 ff ff 6f 	cmp    $0x6ffffff0,%rbx
  4054f4:	74 5a                	je     405550 <__vdsosym+0x180>
		case DT_SYMTAB: syms = p; break;
		case DT_HASH: hashtab = p; break;
		case DT_VERSYM: versym = p; break;
		case DT_VERDEF: verdef = p; break;
  4054f6:	48 81 fb fc ff ff 6f 	cmp    $0x6ffffffc,%rbx
  4054fd:	4c 0f 44 ea          	cmove  %rdx,%r13
  405501:	48 83 c0 10          	add    $0x10,%rax
	for (i=0; dynv[i]; i+=2) {
  405505:	48 8b 58 f8          	mov    -0x8(%rax),%rbx
  405509:	48 85 db             	test   %rbx,%rbx
  40550c:	75 d1                	jne    4054df <__vdsosym+0x10f>
		}
	}	

	if (!strings || !syms || !hashtab) return 0;
  40550e:	4d 85 e4             	test   %r12,%r12
  405511:	0f 94 c2             	sete   %dl
  405514:	4d 85 c9             	test   %r9,%r9
  405517:	0f 94 c0             	sete   %al
  40551a:	08 c2                	or     %al,%dl
  40551c:	75 05                	jne    405523 <__vdsosym+0x153>
  40551e:	48 85 c9             	test   %rcx,%rcx
  405521:	75 50                	jne    405573 <__vdsosym+0x1a3>
		if (!libc.auxv[i]) return 0;
  405523:	31 c0                	xor    %eax,%eax
			continue;
		return (void *)(base + syms[i].st_value);
	}

	return 0;
}
  405525:	48 83 c4 28          	add    $0x28,%rsp
  405529:	5b                   	pop    %rbx
  40552a:	5d                   	pop    %rbp
  40552b:	41 5c                	pop    %r12
  40552d:	41 5d                	pop    %r13
  40552f:	41 5e                	pop    %r14
  405531:	41 5f                	pop    %r15
  405533:	c3                   	retq   
  405534:	0f 1f 40 00          	nopl   0x0(%rax)
			dynv = (void *)((char *)eh + ph->p_offset);
  405538:	4c 89 d8             	mov    %r11,%rax
  40553b:	48 03 42 08          	add    0x8(%rdx),%rax
  40553f:	e9 1e ff ff ff       	jmpq   405462 <__vdsosym+0x92>
  405544:	0f 1f 40 00          	nopl   0x0(%rax)
		case DT_SYMTAB: syms = p; break;
  405548:	49 89 d1             	mov    %rdx,%r9
  40554b:	eb 85                	jmp    4054d2 <__vdsosym+0x102>
  40554d:	0f 1f 00             	nopl   (%rax)
		case DT_VERSYM: versym = p; break;
  405550:	49 89 d0             	mov    %rdx,%r8
  405553:	e9 7a ff ff ff       	jmpq   4054d2 <__vdsosym+0x102>
  405558:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40555f:	00 
		case DT_HASH: hashtab = p; break;
  405560:	48 89 d1             	mov    %rdx,%rcx
  405563:	e9 6a ff ff ff       	jmpq   4054d2 <__vdsosym+0x102>
  405568:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40556f:	00 
		if (!libc.auxv[i]) return 0;
  405570:	31 c0                	xor    %eax,%eax
}
  405572:	c3                   	retq   
	for (i=0; i<hashtab[1]; i++) {
  405573:	44 8b 51 04          	mov    0x4(%rcx),%r10d
	if (!verdef) versym = 0;
  405577:	4d 85 ed             	test   %r13,%r13
  40557a:	4c 0f 44 c3          	cmove  %rbx,%r8
	for (i=0; i<hashtab[1]; i++) {
  40557e:	45 85 d2             	test   %r10d,%r10d
  405581:	74 a0                	je     405523 <__vdsosym+0x153>
  405583:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  405588:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  40558d:	4d 89 cf             	mov    %r9,%r15
		if (!(1<<(syms[i].st_info&0xf) & OK_TYPES)) continue;
  405590:	41 be 27 00 00 00    	mov    $0x27,%r14d
  405596:	eb 1c                	jmp    4055b4 <__vdsosym+0x1e4>
  405598:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40559f:	00 
	for (i=0; i<hashtab[1]; i++) {
  4055a0:	48 83 c3 01          	add    $0x1,%rbx
  4055a4:	44 89 d0             	mov    %r10d,%eax
  4055a7:	49 83 c7 18          	add    $0x18,%r15
  4055ab:	48 39 d8             	cmp    %rbx,%rax
  4055ae:	0f 86 6f ff ff ff    	jbe    405523 <__vdsosym+0x153>
		if (!(1<<(syms[i].st_info&0xf) & OK_TYPES)) continue;
  4055b4:	41 0f b6 47 04       	movzbl 0x4(%r15),%eax
  4055b9:	89 c6                	mov    %eax,%esi
  4055bb:	83 e6 0f             	and    $0xf,%esi
  4055be:	41 0f a3 f6          	bt     %esi,%r14d
  4055c2:	73 dc                	jae    4055a0 <__vdsosym+0x1d0>
		if (!(1<<(syms[i].st_info>>4) & OK_BINDS)) continue;
  4055c4:	c0 e8 04             	shr    $0x4,%al
  4055c7:	be 06 04 00 00       	mov    $0x406,%esi
  4055cc:	0f a3 c6             	bt     %eax,%esi
  4055cf:	73 cf                	jae    4055a0 <__vdsosym+0x1d0>
		if (!syms[i].st_shndx) continue;
  4055d1:	66 41 83 7f 06 00    	cmpw   $0x0,0x6(%r15)
  4055d7:	74 c7                	je     4055a0 <__vdsosym+0x1d0>
		if (strcmp(name, strings+syms[i].st_name)) continue;
  4055d9:	41 8b 37             	mov    (%r15),%esi
  4055dc:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  4055e1:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  4055e6:	48 89 0c 24          	mov    %rcx,(%rsp)
  4055ea:	4c 01 e6             	add    %r12,%rsi
  4055ed:	e8 9e 03 00 00       	callq  405990 <strcmp>
  4055f2:	85 c0                	test   %eax,%eax
  4055f4:	48 8b 0c 24          	mov    (%rsp),%rcx
  4055f8:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
  4055fd:	75 36                	jne    405635 <__vdsosym+0x265>
		if (versym && !checkver(verdef, versym[i], vername, strings))
  4055ff:	4d 85 c0             	test   %r8,%r8
  405602:	74 6d                	je     405671 <__vdsosym+0x2a1>
  405604:	41 0f b7 3c 58       	movzwl (%r8,%rbx,2),%edi
  405609:	4c 89 ee             	mov    %r13,%rsi
  40560c:	66 81 e7 ff 7f       	and    $0x7fff,%di
  405611:	eb 08                	jmp    40561b <__vdsosym+0x24b>
  405613:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		def = (Verdef *)((char *)def + def->vd_next);
  405618:	48 01 c6             	add    %rax,%rsi
		if (!(def->vd_flags & VER_FLG_BASE)
  40561b:	f6 46 02 01          	testb  $0x1,0x2(%rsi)
  40561f:	75 0d                	jne    40562e <__vdsosym+0x25e>
		  && (def->vd_ndx & 0x7fff) == vsym)
  405621:	0f b7 46 04          	movzwl 0x4(%rsi),%eax
  405625:	66 25 ff 7f          	and    $0x7fff,%ax
  405629:	66 39 c7             	cmp    %ax,%di
  40562c:	74 1a                	je     405648 <__vdsosym+0x278>
		if (def->vd_next == 0)
  40562e:	8b 46 10             	mov    0x10(%rsi),%eax
  405631:	85 c0                	test   %eax,%eax
  405633:	75 e3                	jne    405618 <__vdsosym+0x248>
  405635:	44 8b 51 04          	mov    0x4(%rcx),%r10d
  405639:	e9 62 ff ff ff       	jmpq   4055a0 <__vdsosym+0x1d0>
	for (i=0; libc.auxv[i] != AT_SYSINFO_EHDR; i+=2)
  40563e:	b8 08 00 00 00       	mov    $0x8,%eax
  405643:	e9 ca fd ff ff       	jmpq   405412 <__vdsosym+0x42>
	Verdaux *aux = (Verdaux *)((char *)def + def->vd_aux);
  405648:	8b 46 0c             	mov    0xc(%rsi),%eax
	return !strcmp(vername, strings + aux->vda_name);
  40564b:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
  405650:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  405655:	48 89 0c 24          	mov    %rcx,(%rsp)
  405659:	8b 34 06             	mov    (%rsi,%rax,1),%esi
  40565c:	4c 01 e6             	add    %r12,%rsi
  40565f:	e8 2c 03 00 00       	callq  405990 <strcmp>
		if (versym && !checkver(verdef, versym[i], vername, strings))
  405664:	85 c0                	test   %eax,%eax
  405666:	48 8b 0c 24          	mov    (%rsp),%rcx
  40566a:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
  40566f:	75 c4                	jne    405635 <__vdsosym+0x265>
		return (void *)(base + syms[i].st_value);
  405671:	48 89 e8             	mov    %rbp,%rax
  405674:	49 03 47 08          	add    0x8(%r15),%rax
  405678:	e9 a8 fe ff ff       	jmpq   405525 <__vdsosym+0x155>
  40567d:	0f 1f 00             	nopl   (%rax)

0000000000405680 <__expand_heap>:
 * allocated, which will be larger than requested due to page alignment
 * and mmap minimum size rules. The caller is responsible for locking
 * to prevent concurrent calls. */

void *__expand_heap(size_t *pn)
{
  405680:	55                   	push   %rbp
  405681:	53                   	push   %rbx
	static uintptr_t brk;
	static unsigned mmap_step;
	size_t n = *pn;

	if (n > SIZE_MAX/2 - PAGE_SIZE) {
  405682:	48 ba ff ef ff ff ff 	movabs $0x7fffffffffffefff,%rdx
  405689:	ff ff 7f 
{
  40568c:	48 83 ec 18          	sub    $0x18,%rsp
	size_t n = *pn;
  405690:	48 8b 07             	mov    (%rdi),%rax
	if (n > SIZE_MAX/2 - PAGE_SIZE) {
  405693:	48 39 d0             	cmp    %rdx,%rax
  405696:	0f 87 34 01 00 00    	ja     4057d0 <__expand_heap+0x150>
		errno = ENOMEM;
		return 0;
	}
	n += -n & PAGE_SIZE-1;
  40569c:	48 89 c2             	mov    %rax,%rdx

	if (!brk) {
  40569f:	48 8b 35 d2 2a 20 00 	mov    0x202ad2(%rip),%rsi        # 608178 <brk.1890>
  4056a6:	48 89 fd             	mov    %rdi,%rbp
	n += -n & PAGE_SIZE-1;
  4056a9:	48 f7 da             	neg    %rdx
  4056ac:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  4056b2:	48 01 c2             	add    %rax,%rdx
	if (!brk) {
  4056b5:	48 85 f6             	test   %rsi,%rsi
  4056b8:	75 20                	jne    4056da <__expand_heap+0x5a>
	__asm__ __volatile__ ("syscall" : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
  4056ba:	b8 0c 00 00 00       	mov    $0xc,%eax
  4056bf:	48 89 f7             	mov    %rsi,%rdi
  4056c2:	0f 05                	syscall 
		brk = __syscall(SYS_brk, 0);
		brk += -brk & PAGE_SIZE-1;
  4056c4:	48 89 c6             	mov    %rax,%rsi
  4056c7:	48 f7 de             	neg    %rsi
  4056ca:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
  4056d0:	48 01 c6             	add    %rax,%rsi
  4056d3:	48 89 35 9e 2a 20 00 	mov    %rsi,0x202a9e(%rip)        # 608178 <brk.1890>
	}

	if (n < SIZE_MAX-brk && !traverses_stack_p(brk, brk+n)
  4056da:	48 89 f0             	mov    %rsi,%rax
  4056dd:	48 f7 d0             	not    %rax
  4056e0:	48 39 c2             	cmp    %rax,%rdx
  4056e3:	72 5b                	jb     405740 <__expand_heap+0xc0>
		*pn = n;
		brk += n;
		return (void *)(brk-n);
	}

	size_t min = (size_t)PAGE_SIZE << mmap_step/2;
  4056e5:	8b 0d 85 2a 20 00    	mov    0x202a85(%rip),%ecx        # 608170 <mmap_step.1891>
  4056eb:	be 00 10 00 00       	mov    $0x1000,%esi
  4056f0:	48 89 d3             	mov    %rdx,%rbx
	if (n < min) n = min;
	void *area = __mmap(0, n, PROT_READ|PROT_WRITE,
  4056f3:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
	size_t min = (size_t)PAGE_SIZE << mmap_step/2;
  4056f9:	d1 e9                	shr    %ecx
  4056fb:	48 d3 e6             	shl    %cl,%rsi
	void *area = __mmap(0, n, PROT_READ|PROT_WRITE,
  4056fe:	b9 22 00 00 00       	mov    $0x22,%ecx
  405703:	48 39 d6             	cmp    %rdx,%rsi
  405706:	ba 03 00 00 00       	mov    $0x3,%edx
  40570b:	48 0f 43 de          	cmovae %rsi,%rbx
  40570f:	45 31 c9             	xor    %r9d,%r9d
  405712:	31 ff                	xor    %edi,%edi
  405714:	48 89 de             	mov    %rbx,%rsi
  405717:	e8 3f f2 ff ff       	callq  40495b <__mmap>
		MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (area == MAP_FAILED) return 0;
  40571c:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  405720:	0f 84 c2 00 00 00    	je     4057e8 <__expand_heap+0x168>
	*pn = n;
	mmap_step++;
  405726:	83 05 43 2a 20 00 01 	addl   $0x1,0x202a43(%rip)        # 608170 <mmap_step.1891>
	*pn = n;
  40572d:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
	return area;
}
  405731:	48 83 c4 18          	add    $0x18,%rsp
  405735:	5b                   	pop    %rbx
  405736:	5d                   	pop    %rbp
  405737:	c3                   	retq   
  405738:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40573f:	00 
	b = (uintptr_t)libc.auxv;
  405740:	4c 8b 05 09 4b a0 10 	mov    0x10a04b09(%rip),%r8        # 10e0a250 <__libc+0x10>
	if (n < SIZE_MAX-brk && !traverses_stack_p(brk, brk+n)
  405747:	48 8d 3c 32          	lea    (%rdx,%rsi,1),%rdi
	a = b > len ? b-len : 0;
  40574b:	b8 00 00 00 00       	mov    $0x0,%eax
  405750:	49 8d 88 00 00 80 ff 	lea    -0x800000(%r8),%rcx
  405757:	49 81 f8 01 00 80 00 	cmp    $0x800001,%r8
  40575e:	48 0f 42 c8          	cmovb  %rax,%rcx
	if (new>a && old<b) return 1;
  405762:	48 39 cf             	cmp    %rcx,%rdi
  405765:	76 09                	jbe    405770 <__expand_heap+0xf0>
  405767:	49 39 f0             	cmp    %rsi,%r8
  40576a:	0f 87 75 ff ff ff    	ja     4056e5 <__expand_heap+0x65>
	b = (uintptr_t)&b;
  405770:	48 8d 4c 24 08       	lea    0x8(%rsp),%rcx
	a = b > len ? b-len : 0;
  405775:	48 8d 84 24 08 00 80 	lea    -0x7ffff8(%rsp),%rax
  40577c:	ff 
  40577d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  405783:	48 81 f9 01 00 80 00 	cmp    $0x800001,%rcx
  40578a:	49 0f 42 c0          	cmovb  %r8,%rax
	if (new>a && old<b) return 1;
  40578e:	48 39 c7             	cmp    %rax,%rdi
  405791:	76 09                	jbe    40579c <__expand_heap+0x11c>
  405793:	48 39 f1             	cmp    %rsi,%rcx
  405796:	0f 87 49 ff ff ff    	ja     4056e5 <__expand_heap+0x65>
  40579c:	b8 0c 00 00 00       	mov    $0xc,%eax
  4057a1:	0f 05                	syscall 
	    && __syscall(SYS_brk, brk+n)==brk+n) {
  4057a3:	48 8b 0d ce 29 20 00 	mov    0x2029ce(%rip),%rcx        # 608178 <brk.1890>
  4057aa:	48 8d 34 0a          	lea    (%rdx,%rcx,1),%rsi
  4057ae:	48 39 c6             	cmp    %rax,%rsi
  4057b1:	0f 85 2e ff ff ff    	jne    4056e5 <__expand_heap+0x65>
		*pn = n;
  4057b7:	48 89 55 00          	mov    %rdx,0x0(%rbp)
		brk += n;
  4057bb:	48 89 35 b6 29 20 00 	mov    %rsi,0x2029b6(%rip)        # 608178 <brk.1890>
		return (void *)(brk-n);
  4057c2:	48 89 c8             	mov    %rcx,%rax
  4057c5:	e9 67 ff ff ff       	jmpq   405731 <__expand_heap+0xb1>
  4057ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
		errno = ENOMEM;
  4057d0:	e8 db dc ff ff       	callq  4034b0 <__errno_location>
  4057d5:	c7 00 0c 00 00 00    	movl   $0xc,(%rax)
		return 0;
  4057db:	31 c0                	xor    %eax,%eax
  4057dd:	e9 4f ff ff ff       	jmpq   405731 <__expand_heap+0xb1>
  4057e2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
	if (area == MAP_FAILED) return 0;
  4057e8:	31 c0                	xor    %eax,%eax
  4057ea:	e9 42 ff ff ff       	jmpq   405731 <__expand_heap+0xb1>

00000000004057ef <wcrtomb>:
#include <errno.h>
#include "internal.h"

size_t wcrtomb(char *restrict s, wchar_t wc, mbstate_t *restrict st)
{
	if (!s) return 1;
  4057ef:	48 85 ff             	test   %rdi,%rdi
  4057f2:	b8 01 00 00 00       	mov    $0x1,%eax
  4057f7:	0f 84 fc 00 00 00    	je     4058f9 <wcrtomb+0x10a>
	if ((unsigned)wc < 0x80) {
  4057fd:	83 fe 7f             	cmp    $0x7f,%esi
  405800:	0f 86 f4 00 00 00    	jbe    4058fa <wcrtomb+0x10b>
{
  405806:	48 83 ec 08          	sub    $0x8,%rsp
  40580a:	89 f0                	mov    %esi,%eax
  40580c:	48 89 fa             	mov    %rdi,%rdx
  40580f:	64 48 8b 0c 25 00 00 	mov    %fs:0x0,%rcx
  405816:	00 00 
		*s = wc;
		return 1;
	} else if (MB_CUR_MAX == 1) {
  405818:	48 8b 89 c8 00 00 00 	mov    0xc8(%rcx),%rcx
  40581f:	48 8b 09             	mov    (%rcx),%rcx
  405822:	48 85 c9             	test   %rcx,%rcx
  405825:	75 1b                	jne    405842 <wcrtomb+0x53>
		if (!IS_CODEUNIT(wc)) {
  405827:	2d 80 df 00 00       	sub    $0xdf80,%eax
  40582c:	83 f8 7f             	cmp    $0x7f,%eax
  40582f:	0f 87 b4 00 00 00    	ja     4058e9 <wcrtomb+0xfa>
		*s = wc;
  405835:	40 88 37             	mov    %sil,(%rdi)
		return 1;
  405838:	b8 01 00 00 00       	mov    $0x1,%eax
  40583d:	e9 b6 00 00 00       	jmpq   4058f8 <wcrtomb+0x109>
			errno = EILSEQ;
			return -1;
		}
		*s = wc;
		return 1;
	} else if ((unsigned)wc < 0x800) {
  405842:	81 fe ff 07 00 00    	cmp    $0x7ff,%esi
  405848:	77 1d                	ja     405867 <wcrtomb+0x78>
		*s++ = 0xc0 | (wc>>6);
  40584a:	89 f1                	mov    %esi,%ecx
		*s = 0x80 | (wc&0x3f);
  40584c:	83 e0 3f             	and    $0x3f,%eax
		*s++ = 0xc0 | (wc>>6);
  40584f:	c1 f9 06             	sar    $0x6,%ecx
		*s = 0x80 | (wc&0x3f);
  405852:	83 c8 80             	or     $0xffffff80,%eax
		*s++ = 0xc0 | (wc>>6);
  405855:	83 c9 c0             	or     $0xffffffc0,%ecx
		*s = 0x80 | (wc&0x3f);
  405858:	88 47 01             	mov    %al,0x1(%rdi)
		return 2;
  40585b:	b8 02 00 00 00       	mov    $0x2,%eax
		*s++ = 0xc0 | (wc>>6);
  405860:	88 0f                	mov    %cl,(%rdi)
		return 2;
  405862:	e9 91 00 00 00       	jmpq   4058f8 <wcrtomb+0x109>
	} else if ((unsigned)wc < 0xd800 || (unsigned)wc-0xe000 < 0x2000) {
  405867:	8d 8e 00 20 ff ff    	lea    -0xe000(%rsi),%ecx
  40586d:	81 f9 ff 1f 00 00    	cmp    $0x1fff,%ecx
  405873:	76 08                	jbe    40587d <wcrtomb+0x8e>
  405875:	81 fe ff d7 00 00    	cmp    $0xd7ff,%esi
  40587b:	77 28                	ja     4058a5 <wcrtomb+0xb6>
		*s++ = 0xe0 | (wc>>12);
  40587d:	89 c1                	mov    %eax,%ecx
  40587f:	c1 f9 0c             	sar    $0xc,%ecx
  405882:	83 c9 e0             	or     $0xffffffe0,%ecx
  405885:	88 0a                	mov    %cl,(%rdx)
		*s++ = 0x80 | ((wc>>6)&0x3f);
  405887:	89 c1                	mov    %eax,%ecx
		*s = 0x80 | (wc&0x3f);
  405889:	83 e0 3f             	and    $0x3f,%eax
		*s++ = 0x80 | ((wc>>6)&0x3f);
  40588c:	c1 f9 06             	sar    $0x6,%ecx
		*s = 0x80 | (wc&0x3f);
  40588f:	83 c8 80             	or     $0xffffff80,%eax
		*s++ = 0x80 | ((wc>>6)&0x3f);
  405892:	83 e1 3f             	and    $0x3f,%ecx
		*s = 0x80 | (wc&0x3f);
  405895:	88 42 02             	mov    %al,0x2(%rdx)
		return 3;
  405898:	b8 03 00 00 00       	mov    $0x3,%eax
		*s++ = 0x80 | ((wc>>6)&0x3f);
  40589d:	83 c9 80             	or     $0xffffff80,%ecx
  4058a0:	88 4a 01             	mov    %cl,0x1(%rdx)
		return 3;
  4058a3:	eb 53                	jmp    4058f8 <wcrtomb+0x109>
	} else if ((unsigned)wc-0x10000 < 0x100000) {
  4058a5:	8d 8e 00 00 ff ff    	lea    -0x10000(%rsi),%ecx
  4058ab:	81 f9 ff ff 0f 00    	cmp    $0xfffff,%ecx
  4058b1:	77 36                	ja     4058e9 <wcrtomb+0xfa>
		*s++ = 0xf0 | (wc>>18);
  4058b3:	89 f1                	mov    %esi,%ecx
		*s++ = 0x80 | ((wc>>12)&0x3f);
		*s++ = 0x80 | ((wc>>6)&0x3f);
		*s = 0x80 | (wc&0x3f);
  4058b5:	83 e0 3f             	and    $0x3f,%eax
		*s++ = 0xf0 | (wc>>18);
  4058b8:	c1 f9 12             	sar    $0x12,%ecx
		*s = 0x80 | (wc&0x3f);
  4058bb:	83 c8 80             	or     $0xffffff80,%eax
		*s++ = 0xf0 | (wc>>18);
  4058be:	83 c9 f0             	or     $0xfffffff0,%ecx
		*s = 0x80 | (wc&0x3f);
  4058c1:	88 47 03             	mov    %al,0x3(%rdi)
		return 4;
  4058c4:	b8 04 00 00 00       	mov    $0x4,%eax
		*s++ = 0xf0 | (wc>>18);
  4058c9:	88 0f                	mov    %cl,(%rdi)
		*s++ = 0x80 | ((wc>>12)&0x3f);
  4058cb:	89 f1                	mov    %esi,%ecx
  4058cd:	c1 f9 0c             	sar    $0xc,%ecx
  4058d0:	83 e1 3f             	and    $0x3f,%ecx
  4058d3:	83 c9 80             	or     $0xffffff80,%ecx
  4058d6:	88 4f 01             	mov    %cl,0x1(%rdi)
		*s++ = 0x80 | ((wc>>6)&0x3f);
  4058d9:	89 f1                	mov    %esi,%ecx
  4058db:	c1 f9 06             	sar    $0x6,%ecx
  4058de:	83 e1 3f             	and    $0x3f,%ecx
  4058e1:	83 c9 80             	or     $0xffffff80,%ecx
  4058e4:	88 4f 02             	mov    %cl,0x2(%rdi)
		return 4;
  4058e7:	eb 0f                	jmp    4058f8 <wcrtomb+0x109>
	}
	errno = EILSEQ;
  4058e9:	e8 c2 db ff ff       	callq  4034b0 <__errno_location>
  4058ee:	c7 00 54 00 00 00    	movl   $0x54,(%rax)
	return -1;
  4058f4:	48 83 c8 ff          	or     $0xffffffffffffffff,%rax
}
  4058f8:	5a                   	pop    %rdx
  4058f9:	c3                   	retq   
		*s = wc;
  4058fa:	40 88 37             	mov    %sil,(%rdi)
		return 1;
  4058fd:	b8 01 00 00 00       	mov    $0x1,%eax
}
  405902:	c3                   	retq   

0000000000405903 <close_file>:
weak_alias(dummy_file, __stdout_used);
weak_alias(dummy_file, __stderr_used);

static void close_file(FILE *f)
{
	if (!f) return;
  405903:	48 85 ff             	test   %rdi,%rdi
  405906:	74 47                	je     40594f <close_file+0x4c>
{
  405908:	53                   	push   %rbx
	FFINALLOCK(f);
  405909:	8b 87 8c 00 00 00    	mov    0x8c(%rdi),%eax
  40590f:	48 89 fb             	mov    %rdi,%rbx
  405912:	85 c0                	test   %eax,%eax
  405914:	78 05                	js     40591b <close_file+0x18>
  405916:	e8 bc f3 ff ff       	callq  404cd7 <__lockfile>
	if (f->wpos > f->wbase) f->write(f, 0, 0);
  40591b:	48 8b 43 38          	mov    0x38(%rbx),%rax
  40591f:	48 39 43 28          	cmp    %rax,0x28(%rbx)
  405923:	76 0a                	jbe    40592f <close_file+0x2c>
  405925:	31 d2                	xor    %edx,%edx
  405927:	31 f6                	xor    %esi,%esi
  405929:	48 89 df             	mov    %rbx,%rdi
  40592c:	ff 53 48             	callq  *0x48(%rbx)
	if (f->rpos < f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  40592f:	48 8b 73 08          	mov    0x8(%rbx),%rsi
  405933:	48 8b 43 10          	mov    0x10(%rbx),%rax
  405937:	48 39 c6             	cmp    %rax,%rsi
  40593a:	73 12                	jae    40594e <close_file+0x4b>
  40593c:	48 29 c6             	sub    %rax,%rsi
  40593f:	48 89 df             	mov    %rbx,%rdi
  405942:	48 8b 43 50          	mov    0x50(%rbx),%rax
}
  405946:	5b                   	pop    %rbx
	if (f->rpos < f->rend) f->seek(f, f->rpos-f->rend, SEEK_CUR);
  405947:	ba 01 00 00 00       	mov    $0x1,%edx
  40594c:	ff e0                	jmpq   *%rax
}
  40594e:	5b                   	pop    %rbx
  40594f:	c3                   	retq   

0000000000405950 <__stdio_exit>:

void __stdio_exit(void)
{
  405950:	53                   	push   %rbx
	FILE *f;
	for (f=*__ofl_lock(); f; f=f->next) close_file(f);
  405951:	e8 05 bd ff ff       	callq  40165b <__ofl_lock>
  405956:	48 8b 18             	mov    (%rax),%rbx
  405959:	48 85 db             	test   %rbx,%rbx
  40595c:	74 0e                	je     40596c <__stdio_exit+0x1c>
  40595e:	48 89 df             	mov    %rbx,%rdi
  405961:	e8 9d ff ff ff       	callq  405903 <close_file>
  405966:	48 8b 5b 70          	mov    0x70(%rbx),%rbx
  40596a:	eb ed                	jmp    405959 <__stdio_exit+0x9>
	close_file(__stdin_used);
  40596c:	48 c7 c0 80 81 60 00 	mov    $0x608180,%rax
  405973:	48 8b 38             	mov    (%rax),%rdi
  405976:	e8 88 ff ff ff       	callq  405903 <close_file>
	close_file(__stdout_used);
  40597b:	48 c7 c0 a8 71 60 00 	mov    $0x6071a8,%rax
}
  405982:	5b                   	pop    %rbx
	close_file(__stdout_used);
  405983:	48 8b 38             	mov    (%rax),%rdi
  405986:	e9 78 ff ff ff       	jmpq   405903 <close_file>
  40598b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000405990 <strcmp>:
#include <string.h>

int strcmp(const char *l, const char *r)
{
	for (; *l==*r && *l; l++, r++);
  405990:	0f b6 07             	movzbl (%rdi),%eax
  405993:	0f b6 16             	movzbl (%rsi),%edx
  405996:	38 c2                	cmp    %al,%dl
  405998:	75 1c                	jne    4059b6 <strcmp+0x26>
  40599a:	84 d2                	test   %dl,%dl
  40599c:	75 06                	jne    4059a4 <strcmp+0x14>
  40599e:	eb 20                	jmp    4059c0 <strcmp+0x30>
  4059a0:	84 c0                	test   %al,%al
  4059a2:	74 1c                	je     4059c0 <strcmp+0x30>
  4059a4:	48 83 c7 01          	add    $0x1,%rdi
  4059a8:	48 83 c6 01          	add    $0x1,%rsi
  4059ac:	0f b6 07             	movzbl (%rdi),%eax
  4059af:	0f b6 16             	movzbl (%rsi),%edx
  4059b2:	38 d0                	cmp    %dl,%al
  4059b4:	74 ea                	je     4059a0 <strcmp+0x10>
  4059b6:	29 d0                	sub    %edx,%eax
  4059b8:	c3                   	retq   
  4059b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  4059c0:	31 c0                	xor    %eax,%eax
	return *(unsigned char *)l - *(unsigned char *)r;
}
  4059c2:	c3                   	retq   

Disassembly of section .fini:

00000000004059c3 <_fini>:

.section .fini
.global _fini
_fini:
	push %rax
  4059c3:	50                   	push   %rax

.section .fini
	pop %rax
  4059c4:	58                   	pop    %rax
	ret
  4059c5:	c3                   	retq   
